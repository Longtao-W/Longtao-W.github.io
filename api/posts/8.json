{"total":78,"pageSize":10,"pageCount":8,"data":[{"title":"git的使用","slug":"tools/git","date":"2019-10-21T12:12:11.000Z","updated":"2024-06-30T10:35:56.312Z","comments":true,"path":"api/articles/tools/git.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635172820git_animado.gif","content":"<p>[toc]</p>\n<h2 id=\"git-attributes文件\"><a href=\"#git-attributes文件\" class=\"headerlink\" title=\"git attributes文件\"></a>git attributes文件</h2><p>gitattributes是一个文本文件</p>\n<p>格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">匹配的文件如(*.py) 属性1(如text)  属性2(如eol&#x3D;lf)</span><br></pre></td></tr></table></figure>\n\n<p>属性有4种状态，以text为例</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*           text=auto #设置值</span><br><span class=\"line\">*.sh\t\ttext #设置text</span><br><span class=\"line\">*.jpg\t\t-text 不设置</span><br><span class=\"line\">*.py\t\t未声明</span><br></pre></td></tr></table></figure>\n\n<p>常见属性说明</p>\n<p>txt：行尾规范化，值为auto时，进入git库行尾自动转为LF，若git库中已经CRLF则不转换</p>\n<p>eol: 值为CRLF时进入工作目录为CRLF，值为LF时进入工作目录为LF</p>\n<h2 id=\"git-操作\"><a href=\"#git-操作\" class=\"headerlink\" title=\"git 操作\"></a>git 操作</h2><h3 id=\"克隆指定分支\"><a href=\"#克隆指定分支\" class=\"headerlink\" title=\"克隆指定分支\"></a>克隆指定分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b feature-vnuma ssh:&#x2F;&#x2F;git@dev.zstack.io:9022&#x2F;mingmin.wen&#x2F;zstack.git</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch    <span class=\"comment\">#查看本地分支</span></span><br><span class=\"line\">git branch -a <span class=\"comment\">#查看所有分支，包括本地和远程</span></span><br><span class=\"line\">git branch -r <span class=\"comment\">#查看远程分支</span></span><br><span class=\"line\">git branch -vv <span class=\"comment\">#查看上有</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同步远程分支\"><a href=\"#同步远程分支\" class=\"headerlink\" title=\"同步远程分支\"></a>同步远程分支</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch <span class=\"comment\">#本地分支与远程分支保持同步</span></span><br><span class=\"line\">git checkout -b 本地分支 origin/远程分支 <span class=\"comment\">#拉去远程分支并创建对应的本地分支</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-reset-区别\"><a href=\"#git-reset-区别\" class=\"headerlink\" title=\"git reset 区别\"></a>git reset 区别</h3><h3 id=\"stage-index-区域\"><a href=\"#stage-index-区域\" class=\"headerlink\" title=\"stage(index) 区域\"></a>stage(index) 区域</h3><p>暂存区<code>Stage</code>只是一个简单的索引文件而已， <code>.git/index</code>文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211117/1637113648cc3510e8f32578ed0f39756e298749de.png\" alt=\"git 数据流程图示意图\"></p>\n<h3 id=\"合并不同分支\"><a href=\"#合并不同分支\" class=\"headerlink\" title=\"合并不同分支\"></a>合并不同分支</h3><ol>\n<li>切换到要最终合并到的目标分支targetB <code>git checkout targetB</code></li>\n<li>将要合进的分支sourceB合并到目标分支 <code>git merge sourceB </code> 即可将sourceB合并到targetB</li>\n<li>如果有冲突请看下一节</li>\n</ol>\n<h3 id=\"处理合并冲突\"><a href=\"#处理合并冲突\" class=\"headerlink\" title=\"处理合并冲突\"></a>处理合并冲突</h3><ol>\n<li>一般ide都会提示你进入冲突处理，逐行处理冲突（使用目标分支的还是你自己分支的）</li>\n<li>使用<code>git mergetool</code> 进入处理冲突,但是需要自己配置git mergertool</li>\n</ol>\n<h3 id=\"配置mergetool\"><a href=\"#配置mergetool\" class=\"headerlink\" title=\"配置mergetool\"></a>配置mergetool</h3><ol>\n<li><p>检查当前系统插件<code>git mergetool --tool-help</code> 看一下支持列表</p>\n</li>\n<li><p>选一个工具下载下载，例如 beyound compare</p>\n</li>\n<li><p>配置<code>git config --global merge.tool bc4</code> <code>git config --global mergetool.bc4.path &quot;bcomp.exe的路径&quot;</code></p>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"应用","path":"api/tags/应用.json"}]},{"title":"git常见问题","slug":"tools/gittrouble","date":"2019-10-21T12:12:11.000Z","updated":"2024-06-30T10:35:56.312Z","comments":true,"path":"api/articles/tools/gittrouble.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635172820git_animado.gif","content":"<h2 id=\"git-attributes文件\"><a href=\"#git-attributes文件\" class=\"headerlink\" title=\"git attributes文件\"></a>git attributes文件</h2><p>gitattributes是一个文本文件</p>\n<p>格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">匹配的文件如(*.py) 属性1(如text)  属性2(如eol&#x3D;lf)</span><br></pre></td></tr></table></figure>\n\n<p>属性有4种状态，以text为例</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*           text=auto #设置值 c</span><br><span class=\"line\">*.sh\t\ttext #设置text</span><br><span class=\"line\">*.jpg\t\t-text 不设置</span><br><span class=\"line\">*.py\t\t未声明</span><br></pre></td></tr></table></figure>\n\n<p>常见属性说明</p>\n<p>txt：行尾规范化，值为auto时，进入git库行尾自动转为LF，若git库中已经CRLF则不转换</p>\n<p>eol: 值为CRLF时进入工作目录为CRLF，值为LF时进入工作目录为LF</p>\n<h2 id=\"git-操作\"><a href=\"#git-操作\" class=\"headerlink\" title=\"git 操作\"></a>git 操作</h2><h3 id=\"克隆指定分支\"><a href=\"#克隆指定分支\" class=\"headerlink\" title=\"克隆指定分支\"></a>克隆指定分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b feature-vnuma ssh:&#x2F;&#x2F;git@dev.zstack.io:9022&#x2F;mingmin.wen&#x2F;zstack.git</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch    <span class=\"comment\">#查看本地分支</span></span><br><span class=\"line\">git branch -a <span class=\"comment\">#查看所有分支，包括本地和远程</span></span><br><span class=\"line\">git branch -r <span class=\"comment\">#查看远程分支</span></span><br><span class=\"line\">git branch -vv <span class=\"comment\">#查看上有</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同步远程分支\"><a href=\"#同步远程分支\" class=\"headerlink\" title=\"同步远程分支\"></a>同步远程分支</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch <span class=\"comment\">#本地分支与远程分支保持同步</span></span><br><span class=\"line\">git checkout -b 本地分支 origin/远程分支 <span class=\"comment\">#拉去远程分支并创建对应的本地分支</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-reset-区别\"><a href=\"#git-reset-区别\" class=\"headerlink\" title=\"git reset 区别\"></a>git reset 区别</h3><h3 id=\"stage-index-区域\"><a href=\"#stage-index-区域\" class=\"headerlink\" title=\"stage(index) 区域\"></a>stage(index) 区域</h3><p>暂存区<code>Stage</code>只是一个简单的索引文件而已， <code>.git/index</code>文件</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211117/1637113648cc3510e8f32578ed0f39756e298749de.png\" alt=\"git 数据流程图示意图\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"应用","path":"api/tags/应用.json"}]},{"title":"vscode代码高亮设置","slug":"tools/vscodeset","date":"2019-10-08T13:20:21.000Z","updated":"2024-06-30T10:35:56.312Z","comments":true,"path":"api/articles/tools/vscodeset.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211026/1635177963vscode.jpg","content":"<ol>\n<li> 打开File&gt;Preferences-&gt;settings</li>\n<li> 找到workbench.colorCustomizations</li>\n<li> 修改setting.json</li>\n</ol>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;editor.renderLineHighlight&quot;</span>: <span class=\"string\">&quot;all&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;workbench.colorCustomizations&quot;</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;editor.selectionHighlightBackground&quot;</span>: <span class=\"string\">&quot;#9805ec&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;editor.lineHighlightBorder&quot;</span>: <span class=\"string\">&quot;#ff0000&quot;</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"自旋锁与忙等待","slug":"language/common/busyspinandspinwait","date":"2019-09-09T15:20:21.000Z","updated":"2024-06-30T10:35:56.304Z","comments":true,"path":"api/articles/language/common/busyspinandspinwait.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635133679tennis-1381230__480.jpg","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Busy Spin<br>忙碌的旋转<br>A technique which is used in a way that it loop is running until other thread have to complete his work.<br>一种技术，其使用方式是循环运行，直到其他线程必须完成他的工作。<br>Spin Wait<br>旋转等待<br>A spin wait that you have to wait until condition for thread is true.<br>一种旋转等待，您必须等待，直到线程的条件为真。<br>Spin Loop<br>自旋回路<br>Spin loop is also similar to both of above busy spin and wait spin. It means that threads have to wait for other thread for completing his work.<br>自旋环也类似于上述两种繁忙的自旋和等待自旋。这意味着线程必须等待其他线程完成他的工作。</p>\n<h2 id=\"暴论\"><a href=\"#暴论\" class=\"headerlink\" title=\"暴论\"></a>暴论</h2><p>我们常常听到自旋锁、忙等待、Spin Wait、Spin Loop 、Busy Wait、busy-waiting、busy-looping、 spinning等术语，其实他们都是一个东西。<br>维基百科这么描述<code>busy-waiting, busy-looping or spinning is a technique in which a repeatedly checks to see if a condition is true, such as whether keyboard input or a lock is available</code></p>\n<p>通俗来说就是在循环中判断（等待），不过正确实现自旋锁是很难的，这是因为可能有碰撞产生（例如锁竞争时同时访问锁）。不过我们可以使用一些支持原子操作的语句实现。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h4 id=\"CAS-compare-and-swap-算法\"><a href=\"#CAS-compare-and-swap-算法\" class=\"headerlink\" title=\"CAS(compare and swap)算法\"></a>CAS(compare and swap)算法</h4><p>比较并交换(compare and swap, CAS)，是原子操作的一无锁算法。无锁编程使用，一般用于实现乐观锁，自旋锁</p>\n<p>缺点:ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作</p>\n<p>java中实现自旋锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">spinLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//java 泛型；调用CAS库AtomicReference泛型类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;Thread&gt; cas = <span class=\"keyword\">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">// 利用CAS(Compare And Swap)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!cas.compareAndSet(<span class=\"keyword\">null</span>, current)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// DO nothing</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread current = Thread.currentThread();</span><br><span class=\"line\">        cas.compareAndSet(current, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>golang</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> spinLock <span class=\"keyword\">uint32</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sl *spinLock)</span> <span class=\"title\">Lock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> !atomic.CompareAndSwapUint32((*<span class=\"keyword\">uint32</span>)(sl), <span class=\"number\">0</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        runtime.Gosched()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sl *spinLock)</span> <span class=\"title\">Unlock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    atomic.StoreUint32((*<span class=\"keyword\">uint32</span>)(sl), <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSpinLock</span><span class=\"params\">()</span> <span class=\"title\">sync</span>.<span class=\"title\">Locker</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lock spinLock</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;lock</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"}]},{"title":"golang的bufio包","slug":"language/golang/bufiopackage","date":"2019-09-09T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/bufiopackage.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635134014gopher-48499__340.png","content":"<p>原理</p>\n<p>bufio通过缓冲提高效率</p>\n<p>把文件读取进缓冲(内存)避免每次读取触发系统io</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">participant 程序 as A</span><br><span class=\"line\">participant 缓冲区buf as B</span><br><span class=\"line\">participant 文件 as C</span><br><span class=\"line\">B--A:写入内容小于buf</span><br><span class=\"line\">B--A:</span><br><span class=\"line\">C--B:buf没空间，写入文件，清空buf</span><br><span class=\"line\">C--A:写入内容大于buf</span><br></pre></td></tr></table></figure>\n\n\n\n<p>把文件写入缓冲，多次写入后，最后一次性写入文件·</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序--缓冲区buf:写入内容小于buf</span><br><span class=\"line\">程序--缓冲区buf:</span><br><span class=\"line\">缓冲区buf--文件:buf没空间，写入文件，清空buf</span><br><span class=\"line\">程序--文件:写入内容大于buf</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br><span class=\"line\">619</span><br><span class=\"line\">620</span><br><span class=\"line\">621</span><br><span class=\"line\">622</span><br><span class=\"line\">623</span><br><span class=\"line\">624</span><br><span class=\"line\">625</span><br><span class=\"line\">626</span><br><span class=\"line\">627</span><br><span class=\"line\">628</span><br><span class=\"line\">629</span><br><span class=\"line\">630</span><br><span class=\"line\">631</span><br><span class=\"line\">632</span><br><span class=\"line\">633</span><br><span class=\"line\">634</span><br><span class=\"line\">635</span><br><span class=\"line\">636</span><br><span class=\"line\">637</span><br><span class=\"line\">638</span><br><span class=\"line\">639</span><br><span class=\"line\">640</span><br><span class=\"line\">641</span><br><span class=\"line\">642</span><br><span class=\"line\">643</span><br><span class=\"line\">644</span><br><span class=\"line\">645</span><br><span class=\"line\">646</span><br><span class=\"line\">647</span><br><span class=\"line\">648</span><br><span class=\"line\">649</span><br><span class=\"line\">650</span><br><span class=\"line\">651</span><br><span class=\"line\">652</span><br><span class=\"line\">653</span><br><span class=\"line\">654</span><br><span class=\"line\">655</span><br><span class=\"line\">656</span><br><span class=\"line\">657</span><br><span class=\"line\">658</span><br><span class=\"line\">659</span><br><span class=\"line\">660</span><br><span class=\"line\">661</span><br><span class=\"line\">662</span><br><span class=\"line\">663</span><br><span class=\"line\">664</span><br><span class=\"line\">665</span><br><span class=\"line\">666</span><br><span class=\"line\">667</span><br><span class=\"line\">668</span><br><span class=\"line\">669</span><br><span class=\"line\">670</span><br><span class=\"line\">671</span><br><span class=\"line\">672</span><br><span class=\"line\">673</span><br><span class=\"line\">674</span><br><span class=\"line\">675</span><br><span class=\"line\">676</span><br><span class=\"line\">677</span><br><span class=\"line\">678</span><br><span class=\"line\">679</span><br><span class=\"line\">680</span><br><span class=\"line\">681</span><br><span class=\"line\">682</span><br><span class=\"line\">683</span><br><span class=\"line\">684</span><br><span class=\"line\">685</span><br><span class=\"line\">686</span><br><span class=\"line\">687</span><br><span class=\"line\">688</span><br><span class=\"line\">689</span><br><span class=\"line\">690</span><br><span class=\"line\">691</span><br><span class=\"line\">692</span><br><span class=\"line\">693</span><br><span class=\"line\">694</span><br><span class=\"line\">695</span><br><span class=\"line\">696</span><br><span class=\"line\">697</span><br><span class=\"line\">698</span><br><span class=\"line\">699</span><br><span class=\"line\">700</span><br><span class=\"line\">701</span><br><span class=\"line\">702</span><br><span class=\"line\">703</span><br><span class=\"line\">704</span><br><span class=\"line\">705</span><br><span class=\"line\">706</span><br><span class=\"line\">707</span><br><span class=\"line\">708</span><br><span class=\"line\">709</span><br><span class=\"line\">710</span><br><span class=\"line\">711</span><br><span class=\"line\">712</span><br><span class=\"line\">713</span><br><span class=\"line\">714</span><br><span class=\"line\">715</span><br><span class=\"line\">716</span><br><span class=\"line\">717</span><br><span class=\"line\">718</span><br><span class=\"line\">719</span><br><span class=\"line\">720</span><br><span class=\"line\">721</span><br><span class=\"line\">722</span><br><span class=\"line\">723</span><br><span class=\"line\">724</span><br><span class=\"line\">725</span><br><span class=\"line\">726</span><br><span class=\"line\">727</span><br><span class=\"line\">728</span><br><span class=\"line\">729</span><br><span class=\"line\">730</span><br><span class=\"line\">731</span><br><span class=\"line\">732</span><br><span class=\"line\">733</span><br><span class=\"line\">734</span><br><span class=\"line\">735</span><br><span class=\"line\">736</span><br><span class=\"line\">737</span><br><span class=\"line\">738</span><br><span class=\"line\">739</span><br><span class=\"line\">740</span><br><span class=\"line\">741</span><br><span class=\"line\">742</span><br><span class=\"line\">743</span><br><span class=\"line\">744</span><br><span class=\"line\">745</span><br><span class=\"line\">746</span><br><span class=\"line\">747</span><br><span class=\"line\">748</span><br><span class=\"line\">749</span><br><span class=\"line\">750</span><br><span class=\"line\">751</span><br><span class=\"line\">752</span><br><span class=\"line\">753</span><br><span class=\"line\">754</span><br><span class=\"line\">755</span><br><span class=\"line\">756</span><br><span class=\"line\">757</span><br><span class=\"line\">758</span><br><span class=\"line\">759</span><br><span class=\"line\">760</span><br><span class=\"line\">761</span><br><span class=\"line\">762</span><br><span class=\"line\">763</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">// Use of this source code is governed by a BSD-style</span></span><br><span class=\"line\"><span class=\"comment\">// license that can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer</span></span><br><span class=\"line\"><span class=\"comment\">// object, creating another object (Reader or Writer) that also implements</span></span><br><span class=\"line\"><span class=\"comment\">// the interface but provides buffering and some help for textual I/O.</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> bufio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;unicode/utf8&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tdefaultBufSize = <span class=\"number\">4096</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tErrInvalidUnreadByte = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadByte&quot;</span>)</span><br><span class=\"line\">\tErrInvalidUnreadRune = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadRune&quot;</span>)</span><br><span class=\"line\">\tErrBufferFull        = errors.New(<span class=\"string\">&quot;bufio: buffer full&quot;</span>)</span><br><span class=\"line\">\tErrNegativeCount     = errors.New(<span class=\"string\">&quot;bufio: negative count&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered input.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reader implements buffering for an io.Reader object.对io.Reader的封装</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbuf          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\trd           io.Reader <span class=\"comment\">// reader provided by the client</span></span><br><span class=\"line\">\tr, w         <span class=\"keyword\">int</span>       <span class=\"comment\">// buf read and write positions</span></span><br><span class=\"line\">\terr          error</span><br><span class=\"line\">\tlastByte     <span class=\"keyword\">int</span> <span class=\"comment\">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class=\"line\">\tlastRuneSize <span class=\"keyword\">int</span> <span class=\"comment\">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minReadBufferSize = <span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxConsecutiveEmptyReads = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReaderSize</span><span class=\"params\">(rd io.Reader, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Reader?</span></span><br><span class=\"line\">\tb, ok := rd.(*Reader)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt; minReadBufferSize &#123;</span><br><span class=\"line\">\t\tsize = minReadBufferSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr := <span class=\"built_in\">new</span>(Reader)</span><br><span class=\"line\">\tr.reset(<span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size), rd)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReader</span><span class=\"params\">(rd io.Reader)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any buffered data, resets all state, and switches</span></span><br><span class=\"line\"><span class=\"comment\">// the buffered reader to read from r.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Reset</span><span class=\"params\">(r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\tb.reset(b.buf, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">reset</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>, r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\t*b = Reader&#123;</span><br><span class=\"line\">\t\tbuf:          buf,</span><br><span class=\"line\">\t\trd:           r,</span><br><span class=\"line\">\t\tlastByte:     <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\tlastRuneSize: <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeRead = errors.New(<span class=\"string\">&quot;bufio: reader returned negative count from Read&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fill reads a new chunk into the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">fill</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Slide existing data to beginning.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(b.buf, b.buf[b.r:b.w])</span><br><span class=\"line\">\t\tb.w -= b.r</span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to fill full buffer&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Read new data: try a limited number of times.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := maxConsecutiveEmptyReads; i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tn, err := b.rd.Read(b.buf[b.w:])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tb.err = err</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.err = io.ErrNoProgress</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">readErr</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\terr := b.err</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Peek returns the next n bytes without advancing the reader. The bytes stop</span></span><br><span class=\"line\"><span class=\"comment\">// being valid at the next read call. If Peek returns fewer than n bytes, it</span></span><br><span class=\"line\"><span class=\"comment\">// also returns an error explaining why the read is short. The error is</span></span><br><span class=\"line\"><span class=\"comment\">// ErrBufferFull if n is larger than b&#x27;s buffer size.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Calling Peek prevents a UnreadByte or UnreadRune call from succeeding</span></span><br><span class=\"line\"><span class=\"comment\">// until the next read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Peek</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &gt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.buf[b.r:b.w], ErrBufferFull</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 0 &lt;= n &lt;= len(b.buf)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> avail := b.w - b.r; avail &lt; n &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// not enough data in buffer</span></span><br><span class=\"line\">\t\tn = avail</span><br><span class=\"line\">\t\terr = b.readErr()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b.buf[b.r : b.r+n], err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Discard skips the next n bytes, returning the number of bytes discarded.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If Discard skips fewer than n bytes, it also returns an error.</span></span><br><span class=\"line\"><span class=\"comment\">// If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without</span></span><br><span class=\"line\"><span class=\"comment\">// reading from the underlying io.Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Discard</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(discarded <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tremain := n</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tskip := b.Buffered()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tb.fill()</span><br><span class=\"line\">\t\t\tskip = b.Buffered()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip &gt; remain &#123;</span><br><span class=\"line\">\t\t\tskip = remain</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.r += skip</span><br><span class=\"line\">\t\tremain -= skip</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> remain == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n - remain, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read reads data into p.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes read into p.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes are taken from at most one Read on the underlying Reader,</span></span><br><span class=\"line\"><span class=\"comment\">// hence n may be less than len(p).</span></span><br><span class=\"line\"><span class=\"comment\">// To read exactly len(p) bytes, use io.ReadFull(b, p).</span></span><br><span class=\"line\"><span class=\"comment\">// At EOF, the count will be zero and err will be io.EOF.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Read</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn = <span class=\"built_in\">len</span>(p)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(p) &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large read, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Read directly into p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.rd.Read(p)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tb.lastByte = <span class=\"keyword\">int</span>(p[n<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// One read.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Do not use b.fill, which will loop.</span></span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tn, b.err = b.rd.Read(b.buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// copy as much as we can</span></span><br><span class=\"line\">\tn = <span class=\"built_in\">copy</span>(p, b.buf[b.r:b.w])</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadByte reads and returns a single byte.</span></span><br><span class=\"line\"><span class=\"comment\">// If no byte is available, returns an error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadByte</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := b.buf[b.r]</span><br><span class=\"line\">\tb.r++</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(c)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte unreads the last byte. Only the most recently read byte can be unread.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte returns an error if the most recent method called on the</span></span><br><span class=\"line\"><span class=\"comment\">// Reader was not a read operation. Notably, Peek is not considered a</span></span><br><span class=\"line\"><span class=\"comment\">// read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadByte</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastByte &lt; <span class=\"number\">0</span> || b.r == <span class=\"number\">0</span> &amp;&amp; b.w &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadByte</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// b.r &gt; 0 || b.w == 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.r--</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r == 0 &amp;&amp; b.w == 0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.r] = <span class=\"keyword\">byte</span>(b.lastByte)</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadRune reads a single UTF-8 encoded Unicode character and returns the</span></span><br><span class=\"line\"><span class=\"comment\">// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte</span></span><br><span class=\"line\"><span class=\"comment\">// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadRune</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">rune</span>, size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r+utf8.UTFMax &gt; b.w &amp;&amp; !utf8.FullRune(b.buf[b.r:b.w]) &amp;&amp; b.err == <span class=\"literal\">nil</span> &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr, size = <span class=\"keyword\">rune</span>(b.buf[b.r]), <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &gt;= utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\tr, size = utf8.DecodeRune(b.buf[b.r:b.w])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += size</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r, size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadRune unreads the last rune. If the most recent method called on</span></span><br><span class=\"line\"><span class=\"comment\">// the Reader was not a ReadRune, UnreadRune returns an error. (In this</span></span><br><span class=\"line\"><span class=\"comment\">// regard it is stricter than UnreadByte, which will unread the last byte</span></span><br><span class=\"line\"><span class=\"comment\">// from any read operation.)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadRune</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastRuneSize &lt; <span class=\"number\">0</span> || b.r &lt; b.lastRuneSize &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadRune</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r -= b.lastRuneSize</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that can be read from the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.w - b.r &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice pointing at the bytes in the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes stop being valid at the next read.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadSlice encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns all the data in the buffer and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.</span></span><br><span class=\"line\"><span class=\"comment\">// Because the data returned from ReadSlice will be overwritten</span></span><br><span class=\"line\"><span class=\"comment\">// by the next I/O operation, most clients should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes or ReadString instead.</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice returns err != nil if and only if line does not end in delim.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadSlice</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\ts := <span class=\"number\">0</span> <span class=\"comment\">// search start index</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Search buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ti += s</span><br><span class=\"line\">\t\t\tline = b.buf[b.r : b.r+i+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tb.r += i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Pending error?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = b.buf[b.r:b.w]</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\terr = b.readErr()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Buffer full?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\tline = b.buf</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts = b.w - b.r <span class=\"comment\">// do not rescan area we scanned before</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Handle last byte, if any.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i := <span class=\"built_in\">len</span>(line) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.lastByte = <span class=\"keyword\">int</span>(line[i])</span><br><span class=\"line\">\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadLine is a low-level line-reading primitive. Most callers should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes(&#x27;\\n&#x27;) or ReadString(&#x27;\\n&#x27;) instead or use a Scanner.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine tries to return a single line, not including the end-of-line bytes.</span></span><br><span class=\"line\"><span class=\"comment\">// If the line was too long for the buffer then isPrefix is set and the</span></span><br><span class=\"line\"><span class=\"comment\">// beginning of the line is returned. The rest of the line will be returned</span></span><br><span class=\"line\"><span class=\"comment\">// from future calls. isPrefix will be false when returning the last fragment</span></span><br><span class=\"line\"><span class=\"comment\">// of the line. The returned buffer is only valid until the next call to</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine. ReadLine either returns a non-nil line or it returns an error,</span></span><br><span class=\"line\"><span class=\"comment\">// never both.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// The text returned from ReadLine does not include the line end (&quot;\\r\\n&quot; or &quot;\\n&quot;).</span></span><br><span class=\"line\"><span class=\"comment\">// No indication or error is given if the input ends without a final line end.</span></span><br><span class=\"line\"><span class=\"comment\">// Calling UnreadByte after ReadLine will always unread the last byte read</span></span><br><span class=\"line\"><span class=\"comment\">// (possibly a character belonging to the line end) even if that byte is not</span></span><br><span class=\"line\"><span class=\"comment\">// part of the line returned by ReadLine.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadLine</span><span class=\"params\">()</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, isPrefix <span class=\"keyword\">bool</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tline, err = b.ReadSlice(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == ErrBufferFull &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Handle the case where &quot;\\r\\n&quot; straddles the buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">0</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Put the &#x27;\\r&#x27; back on buf and drop it from line.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Let the next call to ReadLine check for &quot;\\r\\n&quot;.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> b.r == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// should be unreachable</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to rewind past start of buffer&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tb.r--</span><br><span class=\"line\">\t\t\tline = line[:<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> line, <span class=\"literal\">true</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\n&#x27;</span> &#123;</span><br><span class=\"line\">\t\tdrop := <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">1</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-2</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\tdrop = <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tline = line[:<span class=\"built_in\">len</span>(line)-drop]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadBytes encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadBytes</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Use ReadSlice to look for array,</span></span><br><span class=\"line\">\t<span class=\"comment\">// accumulating full buffers.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> frag []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> full [][]<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e error</span><br><span class=\"line\">\t\tfrag, e = b.ReadSlice(delim)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">// got final fragment</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e != ErrBufferFull &#123; <span class=\"comment\">// unexpected error</span></span><br><span class=\"line\">\t\t\terr = e</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Make a copy of the buffer.</span></span><br><span class=\"line\">\t\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(frag))</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(buf, frag)</span><br><span class=\"line\">\t\tfull = <span class=\"built_in\">append</span>(full, buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Allocate new buffer to hold the full pieces and the fragment.</span></span><br><span class=\"line\">\tn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">len</span>(full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn += <span class=\"built_in\">len</span>(frag)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Copy full pieces and fragment in.</span></span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\tn = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">copy</span>(buf[n:], full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(buf[n:], frag)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> buf, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadString reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a string containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadString encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadString returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadString</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tbytes, err := b.ReadBytes(delim)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(bytes), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteTo implements io.WriterTo.</span></span><br><span class=\"line\"><span class=\"comment\">// This may make multiple calls to the Read method of the underlying Reader.</span></span><br><span class=\"line\"><span class=\"comment\">// If the underlying reader supports the WriteTo method,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying WriteTo without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">WriteTo</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn, err = b.writeBuf(w)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r, ok := b.rd.(io.WriterTo); ok &#123;</span><br><span class=\"line\">\t\tm, err := r.WriteTo(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> w, ok := w.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\tm, err := w.ReadFrom(b.rd)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r &lt; b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r &lt; b.w =&gt; buffer is not empty</span></span><br><span class=\"line\">\t\tm, err := b.writeBuf(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err == io.EOF &#123;</span><br><span class=\"line\">\t\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeWrite = errors.New(<span class=\"string\">&quot;bufio: writer returned negative count from Write&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// writeBuf writes the Reader&#x27;s buffer to the writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">writeBuf</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(<span class=\"keyword\">int64</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tn, err := w.Write(b.buf[b.r:b.w])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(errNegativeWrite)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int64</span>(n), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Writer implements buffering for an io.Writer object.</span></span><br><span class=\"line\"><span class=\"comment\">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class=\"line\"><span class=\"comment\">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class=\"line\"><span class=\"comment\">// After all data has been written, the client should call the</span></span><br><span class=\"line\"><span class=\"comment\">// Flush method to guarantee all data has been forwarded to</span></span><br><span class=\"line\"><span class=\"comment\">// the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\terr error</span><br><span class=\"line\">\tbuf []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\tn   <span class=\"keyword\">int</span></span><br><span class=\"line\">\twr  io.Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriterSize returns a new Writer whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Writer is already a Writer with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriterSize</span><span class=\"params\">(w io.Writer, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Writer?</span></span><br><span class=\"line\">\tb, ok := w.(*Writer)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tsize = defaultBufSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Writer&#123;</span><br><span class=\"line\">\t\tbuf: <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size),</span><br><span class=\"line\">\t\twr:  w,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriter returns a new Writer whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriter</span><span class=\"params\">(w io.Writer)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewWriterSize(w, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any unflushed buffered data, clears any error, and</span></span><br><span class=\"line\"><span class=\"comment\">// resets b to write its output to w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Reset</span><span class=\"params\">(w io.Writer)</span></span> &#123;</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\tb.wr = w</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Flush writes any buffered data to the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Flush</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn, err := b.wr.Write(b.buf[<span class=\"number\">0</span>:b.n])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; b.n &amp;&amp; err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = io.ErrShortWrite</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &amp;&amp; n &lt; b.n &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">copy</span>(b.buf[<span class=\"number\">0</span>:b.n-n], b.buf[n:b.n])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n -= n</span><br><span class=\"line\">\t\tb.err = err</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Available returns how many bytes are unused in the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Available</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) - b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that have been written into the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Write writes the contents of p into the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If nn &lt; len(p), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Write</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(nn <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(p) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> n <span class=\"keyword\">int</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large write, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Write directly from p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.wr.Write(p)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tn = <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\t\t\tb.n += n</span><br><span class=\"line\">\t\t\tb.Flush()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\tp = p[n:]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteByte writes a single byte.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteByte</span><span class=\"params\">(c <span class=\"keyword\">byte</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Available() &lt;= <span class=\"number\">0</span> &amp;&amp; b.Flush() != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.n] = c</span><br><span class=\"line\">\tb.n++</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteRune writes a single Unicode code point, returning</span></span><br><span class=\"line\"><span class=\"comment\">// the number of bytes written and any error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteRune</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"params\">(size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &lt; utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\terr = b.WriteByte(<span class=\"keyword\">byte</span>(r))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := b.Available()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Flush(); b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tn = b.Available()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Can only happen if buffer is silly small.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> b.WriteString(<span class=\"keyword\">string</span>(r))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsize = utf8.EncodeRune(b.buf[b.n:], r)</span><br><span class=\"line\">\tb.n += size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteString writes a string.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If the count is less than len(s), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteString</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tnn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(s) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\t\tb.n += n</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\ts = s[n:]</span><br><span class=\"line\">\t\tb.Flush()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadFrom implements io.ReaderFrom. If the underlying writer</span></span><br><span class=\"line\"><span class=\"comment\">// supports the ReadFrom method, and b has no buffered data yet,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying ReadFrom without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">ReadFrom</span><span class=\"params\">(r io.Reader)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> w, ok := b.wr.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> w.ReadFrom(r)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err1 := b.Flush(); err1 != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> n, err1</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnr := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> nr &lt; maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\tm, err = r.Read(b.buf[b.n:])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> m != <span class=\"number\">0</span> || err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnr++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nr == maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, io.ErrNoProgress</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n += m</span><br><span class=\"line\">\t\tn += <span class=\"keyword\">int64</span>(m)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If we filled the buffer exactly, flush preemptively.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\terr = b.Flush()</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered input and output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadWriter stores pointers to a Reader and a Writer.</span></span><br><span class=\"line\"><span class=\"comment\">// It implements io.ReadWriter.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*Reader</span><br><span class=\"line\">\t*Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReadWriter allocates a new ReadWriter that dispatches to r and w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReadWriter</span><span class=\"params\">(r *Reader, w *Writer)</span> *<span class=\"title\">ReadWriter</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ReadWriter&#123;r, w&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"golang","path":"api/tags/golang.json"}]},{"title":"如何给HEXO博客文章进行加密","slug":"self/encrypthexo","date":"2019-08-09T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/self/encrypthexo.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351385831600banner.1.jpg","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"抱歉, 这个密码看着不太对, 请再试试.\" data-whm=\"抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"33fdac49e606782a7dbbfe4fc970fe915c1be79773f1b993df35f17db301ed8e\">3ecf1eeb34e97740ad8e82ab56d0b3049f46c88f4d637992895f9bcf6709f41affe7ea6b49f8e7aab122975b82622e06b0c16b052ac253d8c8014364ab54aee2e86b8c6d572c5572849ce25b137f20b9a07b5d8d9980d095b6572edb491095cef4477ec51ff50f31858e60111736bf9e14fefced5f5506a926eef884cbb469ffd903a950d338d399b7cb124fbbbd80c25f1ae415013e20627f39cddd2e37d5541645868f29357442f8139d20281ccf66b469d46687768c3f827688b939c8610f5d3fcb30c36cbaa5a32233651a0b01e5e6e19f879a69687ba60f437c52d6189068b74f263c7aed27f5a787ee58e5eafc9a14ef6b572ab0e54caea4155266ec09acee27aefc4cfb487f17ab94d6c9ab7d273c0217c9b74da80fdfec786f180a7670e586d69c8ffd0886b5bc426b83e844e9d1d481507bb31236a61beec295806ff3669241eff4cdf340686d2105838c631f4252d9e5f43167fdf32744b492d02cfbbabe7c6ecdea197149fb885d516f9f8d08a9379d2cb25901e3af8c1d876a584bbedbbb2d4f2cf2a4977f66ae7e56658110e8a8f0b3b082ac2dd43ca6f3702e69892436fae8f7a42ebdb364a5eb0fe0b22916b1eaade413a9ca8c659e0152fca63d02af63710609b4da40ffef022a385b348a35efbfa332623dc4a17ed00c6c8b85b211ead24796dfce9abeb21a29dd9e6b089baa522afe4cb34dcae7ae7f61c071516e538d78fcc45b5a3bd6ca844cf2c42cbf093ea2b30b25aa0054323a050c57fe8f129ef4655ce31f4df7076d32763ca4a5ad076c1bfce0110ca2c618c7c97ff2c364c7e7430b067fa3768440158d6d8153de85f71723bac0d68dacbf8eb52607013c4edea4f8e170365c516c63fc7bb0a2a9f0bccf61c2ccf0dc8531a9a3b21a4cbbcdb97260ef5b59dbb5e9a6890c419a293435fdcc4e2c4874e6a1cc2c90e945adb59b10881a6bda08002f7d206a55e35eefa0a2080e61bf6ec277ed940f500a80a4147b57b400cbcae2268a70ffae00a9bda985d3cc2073abb97042d0079edaca28003a2bd72fad63ea739b994d74311a81c42371f7a2744d3a94999aa44a538d7e0032109b5955ed104d67f6108a311271f703009c16cec27363ed7e3618b71f1213b4ff3742556cc89d6cc83963fac266856195a2213fee559849b458253a9dc7822369d048cfdcb1fdd9ff462eca6afa08e897f7cf27d2d096ccf9d3dbceabf76f3d3aa65ac197b921b4074dcf36f0992b734b4c0a5454f6c206e8c3327167dbae959c512a374a8a7e2175280ee0efb64c1f73be8409a0d267c98d8bb3413a8d80deb8b99527248e0fa71637a95cd953850c75e246577ba469477ac8378a866193b565802924aaa5bfe25ff18edc2c673d5306d46f75f2cc7fda3367817e53df4c00efa663bbe76c2af94417af18d01f9db355cf13f242c6133530461056e09cf58b34212ce070375b6f3b3c1ea79f419f8d6cecdfdd08b34d45c9d4f7c352ef64820bb332e4639e0b35e156f1a3fe24f3c812880e76084e5400be8093848bc4dda9c24741c2fc9272deb5097594e25c478590b5b7fc3d66e4be4339d219cbbbf415d6b36b9ca4e5731fb46d56e4b8a7014d3246b44d891a5ee7013b62f7323d7fb9e91da4edd1cbd64b0e2bbeccddfe027ed6e1aa4805da8995d8b16e62a403b38306d33f5b91311b28579e6cd103de72086cea1f600095df4f5b962af4cf7cfd313e171069bbeac8aa489bd2eb558bbac086d93accd69547e535e903d2a655671fef81e76ead1317d1881ac00a894d16b0c31200074ca26ae172be5b6e9659ad42534fa179777e34877bd1706aad4bd867aebcf2f419a229fdc52c85acb05472f8cfe1990090fb62c410312aff72127cf4e666d7f7c88d6ee3c56d5ccc2520786e88983f72cb38edf48dd46ed1d7d5d8409f9eece9961e13a3643021994ce3f415c03a19a8a042a5da5a2302d5f7c71baa51a7d00535683a97f996eda6ed4d952e5ac0d2479026f7653402ebc3c1fe55cf74bb02ed324b10ddc59b35b9d7f482649802ed035fdc554ce0afcee02340ce5a2572dcd36a05a8880c68a5840ac46f341d3eacd415c1858f291aa1e3b9309e7ae5ed52826cdb82eec2ec8c16404255eb495be02db7c0e7b5ffe315bf2bc5d84f23023c7e27288c8004ff65f3a5da2f38791263f1d3d1f9c5bbc8ece9bee12e3131ff4ccbee3024288f31986efdb92cee19bba529d2a3c8674cb878fbf776a40fe465a91094d7af11b5e75f3d94c0b85b332a7dcfb748e645a3c64647a26e5b3374be78fc367f6f469d17904c4125e772d0125042d66180647b6620c52395e4279c7578afff2355d3606e8a1a3c0c5b02709f56c99b5ced92beae56c68823770d2b248e3850ae06c5428b4c84e68d1046138cb167424976f9c95fe405c5ffafc93cca35551570597b16414f4cfcd72cd67fd9c2485e25f5e4fc17bec0b398efc659c6c58fc70f1fe04e6ce27e4589549d20d405dd80bdceb34a0cf57aaa5a5c3298827febe1b2c1e9916c5c31202c569509b5d90ce3f8296508a98bf44d7b6c2c5acd2c0a087b80cd8ab5bbaf42febd6c026d32b4a4d3155d6cbfc67f649aa09262455cec28d874033f46b3e1bbb65353fbb2af6e215144a351116f83b03d0f4d3cd3a426a72133234197afcd37cf0cc489aff4288d0339398bfa55675e362954b56bad04003236367ffcabac838d1c432e7ed34d9284f8f9e3a041ae521ee34bcf29d949d9a2150099ee56d468c7a86d8a7f3ff2bf9d62612669f6f27e44fd2cf89303117eb92f87c03ed794f5e4534cb66a8aa478ed1656f7e7fbef292d87690c04933f76452a08cc83d357e031396dcb35166c9a51e255cdad2a6e5237d9f0d8245b1d647abd87bb72113e8fb32ae50c8455ac49ca0ec2935563e08c7b119fc735a89ae3f70c2143ada3d54379b249711540ff0e7a891c3068b91b8dba3f58f04879b04cb0fb6412e491a9db2b1a6f711986dcbd14a209d62f419c16b7210275fa741a90c07336d1626493532e50c36cbebb45b1b1d7183e26480b2d117e2cb812044f97e227e4c1b288ae7cd65181906f4db923f5de9c591fa0950de615d1f8070401b982f874fd35067bb7e2baf1e7cac5ee17a45117988cec24707c020a4a1073605f27741cf884afff3508028b00db5326a696a0cbc21ef429c0b09538cf86d6fef01a2819b3671ba45e6e465d083f844f070aa06645f0208f6df171dac859ac3affedd355ebf8a99d8f99c6c4105bd722210e076b49666ab66fe30516f0550e0bb9dc233aa2946113abe35fecd657e8393d29f1c5b7b1252b94493c95ef1d4c4ba5c25e7735b8f962d10cb0c984c47e5e057f8c6469ef031551850baa4c912b52226803564226a11311db39b9b0277e2a4e988a62d9615b385848fed34711efc14819dac55a6d63f2c2aa891cf9461a6a7df6c52d865a5799e73b2483b332043c493438c01f88721c6ca2cfbed30aec58f6a35f1a55f1bcb70109bb612737b41e12f7e007f22101cbdf982a6856f3d87420a1649a14d82a07e9f8da2ed202abc7f1ecf1ce3ebe5c744a0fe3a03a395e24cf1a01930bc241d620135a1014869224e635d575701e7cb19dc502f896f4793233c89d9850ccfe0e908d9e65d275d33b38de5cb7791c4a476d6222bba7fdc86fd52dbee9426041608e1b74829c0eb1b1404e12ad6fa0dc4b6c78bc2557d3eadb2ecb9e09be76d91c3ee7745b2590af8cef28505923c8a01ebf5e162240a3abbe4232000c6a470c60683390f9f3227f2320b09a0e4c9c2140b47c7b8569fd83f1c9d34a2db6b2880dc446a69ac12065c9a23f1508f80fd91408cd122a4f9e6bc38f12b5d0fa653a3f56a31818a39fcb0093aa32afe0b23e03233fd890c071c5a566b2cff43cac3caaca1b2bea06e6cb34191f69728625c9e525dadaf9a8faaf8da5781f6b24e6ec67e42619699d7acdfd3fdfbb598f0f94f43b36f6b68195713d663ee61512aa4743bd97f00ccc42307e1cf016793e1512d6803330489e1acf5cab4edd68e84fcaf6e956193572a263fbe9dfca81c3880f53f397a01bf08913bd86f536657e20d0e521ccb2f0f8b4af081da79ec0a87df33a7884d4ce4e240652896ac28e65ae665c7417be118989549c1ede07a83458f7cf7369f337859bd5da248644babab1961f10d9232ec9af0241d24e3a42c9aa1862beed13c91e02265722e305b50d11ac2e541e68f63d28684db6cdca9b1b99674b3c58358ab859f6b1f35ae0bacaa52111099985fddc35d9a77d6962d9a96fc28f80ffc904ba8bea9950155a0cbca069c280beaf4fdd47d885cac45976cd53477ea31a4e6939eeb2d5769fe4415fdbf369de5434ed3fd4a7cbe6a9938ce381dfdb0782154daf06254fbab21030f9c72b2ed3fbd87aac575736dc5407af6220207b9083c7e9ec2d7680dfc60cf9dd9ab15782841ec082fcdc2e9a37a299a05bbd35a1f2b74c6faff93a0bfdfceae2bf579fa02dc6fb3e3ac0cf41a36342e085994c58b7c8c0ff752abf40bde5a29d97694645707cf95b6a8153001a344e6ef4272cfe5f16f8da6217a8aeea2d149abbf27b65c1161dfd77cf5edd595f2b64ada7e03387e3dbb0e41af67a4890e5c934a616887933eb42f6c2cb977fbe68b38844a4310116f79706dc8ea50b48b58c06b340312f7dbc7ce0ebc74c232c7666d92f9f1d1c4bf2dce9f522cbf1d57ea67c3d8cd3b4dfc1f06f631d266646b1edefc2c0f9dba7284dda6aa4b8829b72116579f673787ed65ae46a5e61fcb1aee3431c8af141be432c10feb1b4cca89925cf549f0f00c94be8b370f9fb466266f5ed54f33fffb46a5bd4785c4950b5b427fd33a39ed0b696ffb4028b45479a481fb4588c63edd089340a370a79891d779a72c1b0b9bae00d2deff5f7dc2b00b728d322788bab26c9c81cbbe5a61d79c137833441ddd249695b0e667b48735c13fdf686c6c172bef2a244541073e115a09e125a2fb8fbdfd9327f5ef535ad117789a3aef4fc22e2c304783e0f9d80b2c5f3795bc0bb077864f377f165040b8962fbe820528e76f68bf36e5f8c1f5b9c68fd5056c342d62c16d246c5602978f3628eea1d39c551ad8977719843ffa3b7cf2633f072013327c8202656d7b753b033a7c70f0e1681581c3c1a217f7d7cd32954bb0ff194a9b696d6f43899cde3b83d8cb3fd7c97bbdc17fed94efd839168c8dc7413a7d994272d48879d788323ebeaa7c8c38006efc610df1daf5763bef8eab0cc3f5eb45e825b71ba26f47c10f0776fb2e4dec49ce8e45ada0d806a8323af704c55db21d6c4d92e62e3e5ca85d6a6</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">密码是  漫步科技人生</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","raw":null,"categories":[{"name":"创作工具","path":"api/categories/创作工具.json"}],"tags":[{"name":"创作工具","path":"api/tags/创作工具.json"}]},{"title":"go的内置包","slug":"language/golang/built-inpackage","date":"2019-07-19T14:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/built-inpackage.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635134047ground-squirrel-5831591__340.jpg","content":"<h2 id=\"库与包\"><a href=\"#库与包\" class=\"headerlink\" title=\"库与包\"></a>库与包</h2><h4 id=\"archive\"><a href=\"#archive\" class=\"headerlink\" title=\"archive\"></a>archive</h4><h5 id=\"tar包：负责打包、解包-注意tar不负责压缩和解压\"><a href=\"#tar包：负责打包、解包-注意tar不负责压缩和解压\" class=\"headerlink\" title=\"tar包：负责打包、解包,注意tar不负责压缩和解压\"></a>tar包：负责打包、解包,注意tar不负责压缩和解压</h5><p>打包实现原理</p>\n<p>先创建一个文件x.tar，然后向x.tar写入tar头部信息。打开要被tar的文件，向x.tar写入头部信息，然后向x.tar写入文件信息。重复第二步直到所有文件都被写入到x.tar中，关闭x.tar，整个过程就这样完成了</p>\n<p>解包实现原理</p>\n<p>先打开tar文件，然后从这个tar头部中循环读取存储在这个归档文件内的文件头信息，从这个文件头里读取文件名，以这个文件名创建文件，然后向这个文件里写入数据</p>\n<h5 id=\"zip包：打包、解包，并进行压缩\"><a href=\"#zip包：打包、解包，并进行压缩\" class=\"headerlink\" title=\"zip包：打包、解包，并进行压缩\"></a>zip包：打包、解包，并进行压缩</h5><p>压缩实现原理</p>\n<p>工具类：bufio、bytes、string、path、strconv、io/ioutils等，没有领域知识，比较简单</p>\n<p>系统包：os、net、sync、fmt</p>\n<h2 id=\"linux-说明\"><a href=\"#linux-说明\" class=\"headerlink\" title=\"linux 说明\"></a>linux 说明</h2><h4 id=\"linux文件头信息-标志\"><a href=\"#linux文件头信息-标志\" class=\"headerlink\" title=\"linux文件头信息(标志)\"></a>linux文件头信息(标志)</h4><p>使用file命令可以查看文件类型</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# file test ./test/1</span><br><span class=\"line\">test:     directory</span><br><span class=\"line\">./test/1: ASCII text</span><br></pre></td></tr></table></figure>\n\n\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"golang","path":"api/tags/golang.json"}]},{"title":"机器学习算法","slug":"systemstructure/algorithm/machine","date":"2018-01-25T10:24:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/algorithm/machine.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138820R-C.a85787a0d06496906299e72de39ffb00?rik=9SM14JX30i1BPQ&riu=http%3a%2f%2fimg.mp.itc.cn%2fupload%2f20170420%2ff813101deccb4bcea732569ecbcf2ab7_th.jpeg&ehk=Mprq0bxfRYz7AO70UBj3%2fqUqXpN6ELRfJqKVMtD3pUY%3d&risl=&pid=ImgRaw&r=0","content":"<p>线性代数</p>\n<p>概率论</p>\n<p>贝叶斯概率公式</p>\n<p>P(A|B)=$\\frac{P(A)*P(B|A)}{P(B)}$</p>\n<p>也就是</p>\n<p>P(A$\\cap$B) = P(A)*P(B|A)</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"算法，机器学习","path":"api/tags/算法，机器学习.json"}]}]}