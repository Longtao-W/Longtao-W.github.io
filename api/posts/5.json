{"total":78,"pageSize":10,"pageCount":8,"data":[{"title":"网络查询、嗅探","slug":"systemstructure/security/netoperate","date":"2020-09-26T15:00:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/security/netoperate.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171718Computer-Networking-Featured.jpg","content":"<p>[toc]</p>\n<h4 id=\"查自己的公网ip\"><a href=\"#查自己的公网ip\" class=\"headerlink\" title=\"查自己的公网ip\"></a>查自己的公网ip</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ curl http://members.3322.org/dyndns/getip</span><br><span class=\"line\">150.118.52.133</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 或者</span></span><br><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ curl ip.</span><br><span class=\"line\">150.118.52.133</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询域名的ip地址\"><a href=\"#查询域名的ip地址\" class=\"headerlink\" title=\"查询域名的ip地址\"></a>查询域名的ip地址</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ nslookup www.baidu.com</span><br><span class=\"line\">Server:\t\t127.0.0.53 #dns服务器</span><br><span class=\"line\">Address:\t127.0.0.53#53</span><br><span class=\"line\"></span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">www.baidu.com\tcanonical name = www.a.shifen.com.# 域名实际对应的主机名记录</span><br><span class=\"line\">Name:\twww.a.shifen.com </span><br><span class=\"line\">Address: 150.101.49.12 #域名负载均衡</span><br><span class=\"line\">Name:\twww.a.shifen.com</span><br><span class=\"line\">Address: 150.101.49.11</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询目标ip对应的mac地址\"><a href=\"#查询目标ip对应的mac地址\" class=\"headerlink\" title=\"查询目标ip对应的mac地址\"></a>查询目标ip对应的mac地址</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 用ping获取arp缓存再查找</span></span><br><span class=\"line\">[root@localhost ~]# ping 127.0.1.21 -c 1 &gt;&gt; /dev/null;arp -a 127.0.1.21|awk -F &quot; &quot; &#x27;&#123;print $4&#125;&#x27;</span><br><span class=\"line\">14:02:ec:32:cc:24</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改网卡mac地址\"><a href=\"#修改网卡mac地址\" class=\"headerlink\" title=\"修改网卡mac地址\"></a>修改网卡mac地址</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig eth0 hw ether B3:00:00:00:00:A2#临时修改</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"嗅探目标ip的信息\"><a href=\"#嗅探目标ip的信息\" class=\"headerlink\" title=\"嗅探目标ip的信息\"></a>嗅探目标ip的信息</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 嗅探目标ip端口开发情况</span></span><br><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ sudo nmap -PS 180.101.49.12</span><br><span class=\"line\">Starting Nmap 7.80 ( https://nmap.org ) at 2021-08-20 15:08 CST</span><br><span class=\"line\">Nmap scan report for 180.101.49.12</span><br><span class=\"line\">Host is up (0.0079s latency).</span><br><span class=\"line\">Not shown: 998 filtered ports</span><br><span class=\"line\">PORT    STATE SERVICE</span><br><span class=\"line\">80/tcp  open  http</span><br><span class=\"line\">443/tcp open  https</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 嗅探目标ip系统信息</span></span><br><span class=\"line\">sudo nmap -O 180.101.49.12</span><br><span class=\"line\">tarting Nmap 7.80 ( https://nmap.org ) at 2021-08-20 14:59 CST</span><br><span class=\"line\">Nmap scan report for 180.101.49.12</span><br><span class=\"line\">Host is up (0.0084s latency).</span><br><span class=\"line\">Not shown: 998 filtered ports</span><br><span class=\"line\">PORT    STATE SERVICE</span><br><span class=\"line\">80/tcp  open  http</span><br><span class=\"line\">443/tcp open  https</span><br><span class=\"line\">Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port</span><br><span class=\"line\">Aggressive OS guesses: Linux 2.6.18 - 2.6.22 (92%), D-Link DWL-624+ or DWL-2000AP, or TRENDnet TEW-432BRP WAP (90%), OneAccess 1641 router (90%), 3Com SuperStack 3 Switch 3870 (88%), HP ProCurve 2524 switch or 9100c Digital Sender printer (86%), Blue Coat PacketShaper appliance (86%), Satel ETHM-2 intruder alarm (86%), Apple TV 5.2.1 or 5.3 (86%), AVtech Room Alert 26W environmental monitor (85%)</span><br><span class=\"line\">No exact OS matches for host (test conditions non-ideal).</span><br><span class=\"line\"></span><br><span class=\"line\">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class=\"line\">Nmap done: 1 IP address (1 host up) scanned in 9.61 seconds</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 扫描整个网段所有ip</span></span><br><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ nmap  172.20.65.0/24</span><br><span class=\"line\">Starting Nmap 7.80 ( https://nmap.org ) at 2021-08-20 15:12 CST</span><br><span class=\"line\">Nmap scan report for 172.20.65.50</span><br><span class=\"line\">Host is up (0.00048s latency).</span><br><span class=\"line\">Not shown: 998 closed ports</span><br><span class=\"line\">PORT   STATE SERVICE</span><br><span class=\"line\">22/tcp open  ssh</span><br><span class=\"line\">80/tcp open  http</span><br><span class=\"line\"></span><br><span class=\"line\">Nmap scan report for 172.20.65.62</span><br><span class=\"line\">Host is up (0.00022s latency).</span><br><span class=\"line\">Not shown: 996 closed ports</span><br><span class=\"line\">PORT     STATE SERVICE</span><br><span class=\"line\">22/tcp   open  ssh</span><br><span class=\"line\">80/tcp   open  http</span><br><span class=\"line\">8080/tcp open  http-proxy</span><br><span class=\"line\">8888/tcp open  sun-answerbook</span><br><span class=\"line\"></span><br><span class=\"line\">Nmap scan report for 172.20.65.77</span><br><span class=\"line\">Host is up (0.00023s latency).</span><br><span class=\"line\">Not shown: 998 closed ports</span><br><span class=\"line\">PORT   STATE SERVICE</span><br><span class=\"line\">22/tcp open  ssh</span><br><span class=\"line\">80/tcp open  http</span><br><span class=\"line\"></span><br><span class=\"line\">Nmap scan report for 172.20.65.84</span><br><span class=\"line\">Host is up (0.00046s latency).</span><br><span class=\"line\">Not shown: 997 closed ports</span><br><span class=\"line\">PORT    STATE SERVICE</span><br><span class=\"line\">22/tcp  open  ssh</span><br><span class=\"line\">80/tcp  open  http</span><br><span class=\"line\">999/tcp open  garcon</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"模拟发包\"><a href=\"#模拟发包\" class=\"headerlink\" title=\"模拟发包\"></a>模拟发包</h4><p>使用hping3模拟发包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c --count count 发送数据包的次数</span><br><span class=\"line\">-i --interval 包发送间隔时间（单位是毫秒）缺省时间是1秒</span><br><span class=\"line\">-n -nmeric 数字输出，象征性输出主机地址。</span><br><span class=\"line\">-I --interface 网络接口名如eth0。</span><br><span class=\"line\">-v --verbose 显示很多信息，</span><br><span class=\"line\">-D --debug 进入debug模式</span><br><span class=\"line\">-z --bind 快捷键的使用。</span><br><span class=\"line\">-Z --unbind 消除快捷键。</span><br><span class=\"line\">-O --rawip RAWIP模式，在此模式下HPING会发送带数据的IP头。</span><br><span class=\"line\">-1 --icmp ICMP模式，此模式下HPING会发送IGMP应答报，你可以用--ICMPTYPE --ICMPCODE选项发送其他类型/模式的ICMP报文。</span><br><span class=\"line\">-2 --udp UDP 模式，缺省下，HPING会发送UDP报文到主机的0端口，你可以用--baseport --destport --keep选项指定其模式。</span><br><span class=\"line\">-9 --listen signatuer hping的listen模式，用此模式，HPING会接收指定的数据。</span><br><span class=\"line\">-a --spoof hostname 伪造IP攻击，防火墙就不会记录你的真实IP了，当然回应的包你也接收不到了。</span><br><span class=\"line\">-t --ttl time to live 可以指定发出包的TTL值。</span><br><span class=\"line\">-H --ipproto 在RAW IP模式里选择IP协议。</span><br><span class=\"line\">-w --WINID UNIX ,WINDIWS的id回应不同的，这选项可以让你的ID回应和WINDOWS一样。</span><br><span class=\"line\">-r --rel 更改ID的，可以让ID曾递减输出，详见HPING-HOWTO。</span><br><span class=\"line\">-F --FRAG 更改包的FRAG，这可以测试对方对于包碎片的处理能力，缺省的“virtual mtu”是16字节。</span><br><span class=\"line\">-x --morefrag 此功能可以发送碎片使主机忙于恢复碎片而造成主机的拒绝服务。</span><br><span class=\"line\">-y -dontfrag 发送不可恢复的IP碎片，这可以让你了解更多的MTU PATH DISCOVERY。</span><br><span class=\"line\">-G --fragoff fragment offset value set the fragment offset</span><br><span class=\"line\">-m --mtu mtu value 用此项后ID数值变得很大，50000没指定此项时3000-20000左右。</span><br><span class=\"line\">-G --rroute 记录路由，可以看到详悉的数据等等，最多可以经过9个路由，即使主机屏蔽了ICMP报文</span><br><span class=\"line\">-C --ICMPTYPE type 指定ICMP类型，缺省是ICMP echo REQUEST</span><br><span class=\"line\">-K --ICMPCODE CODE 指定ICMP代号，缺省0</span><br><span class=\"line\">--icmp-ipver 把IP版本也插入IP头</span><br><span class=\"line\">--icmp-iphlen 设置IP头的长度，缺省为5（32字节）</span><br><span class=\"line\">--icmp-iplen 设置IP包长度</span><br><span class=\"line\">-s --baseport source port hping 用源端口猜测回应的包</span><br><span class=\"line\">-p --deskport [+][+]desk port 设置目标端口，缺省为0，一个加号设置为:每发送一个请求包到达后，端口加1，两个加号为：每发一个包，端口数加1</span><br><span class=\"line\">-w --win 发windows包，64BYTE</span><br><span class=\"line\">-O --tcpoff 设置tcp偏移</span><br><span class=\"line\">-m --tcpseq 设置TCP序列数</span><br><span class=\"line\">-l --tcpck 设置TCP ack</span><br><span class=\"line\">-Q --seqnum 搜集序列号</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"什么是不经意传输","slug":"greatprinciple/otprotocol","date":"2020-09-19T15:20:21.000Z","updated":"2024-06-30T10:35:56.304Z","comments":true,"path":"api/articles/greatprinciple/otprotocol.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351336111635133609communication-1015376__340.jpg","content":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>不经意传输（Oblivious Transfer，OT）指发送方发送了许多信息中的其中一个给接收方，但是发送方不知道接收方接受的是哪一个信息</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>不经意传输是密码学的一类协议。</p>\n<ol>\n<li><p>不经意传输的第一种形式是由Michael Oser Rabin(1976年图灵奖-非确定自动机),这种形式的不经意传输发送方会有 1/2 的概率将消息发送给接收方，而发送方不知道接收方是否接收到该消息,传输方案基于RSA加密算法</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211011/1633944256v2-770e7258668450e33a53bc510a14fc83_1440w.jpg\" alt=\"img\"></p>\n</li>\n<li><p>1-2不经意传输(1-n不经意传输)是一种更为常用的不经意传输方案，这种方案被Oded Goldreich、Abraham Lempel和Shimon Even发展成为安全多方计算协议，在这种协议下用户仅能获得数据库中的一个元素，而服务器不知道用户查询了哪一个元素。不经意传输是私有信息检索的加强版本。</p>\n</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211011/1633944253v2-4f565ca6dc1d08e72721030b8d8698d6_1440w.jpg\" alt=\"img\"></p>\n <iframe  \n height=850 \n width=90% \n src=\"https://longtao.fun/ppt/%E5%A7%9A%E6%9C%9F%E6%99%BA.html\"  \n frameborder=0  \n allowfullscreen>\n </iframe>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"密码学","path":"api/tags/密码学.json"},{"name":"图灵奖","path":"api/tags/图灵奖.json"}]},{"title":"获取系统信息","slug":"systemstructure/security/linuxinfo","date":"2020-09-09T15:40:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/security/linuxinfo.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171571Linux-system-info-Tools.jpg","content":"<h3 id=\"版本信息\"><a href=\"#版本信息\" class=\"headerlink\" title=\"版本信息\"></a>版本信息</h3><h4 id=\"uname工具\"><a href=\"#uname工具\" class=\"headerlink\" title=\"uname工具\"></a>uname工具</h4><p>uname工具是对sys/utsname函数的一个封装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a或--all：显示全部的信息；</span><br><span class=\"line\">-m或--machine：显示电脑类型；</span><br><span class=\"line\">-n或-nodename：显示在网络上的主机名称；</span><br><span class=\"line\">-r或--release：显示操作系统的发行编号；</span><br><span class=\"line\">-s或--sysname：显示操作系统名称；</span><br><span class=\"line\">-v：显示操作系统的版本；</span><br><span class=\"line\">-p或--processor：输出处理器类型或&quot;unknown&quot;；</span><br><span class=\"line\">-i或--hardware-platform：输出硬件平台或&quot;unknown&quot;；</span><br><span class=\"line\">-o或--operating-system：输出操作系统名称；</span><br></pre></td></tr></table></figure>\n\n<p>简单实例如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;sys/utsname.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">utsname</span> <span class=\"title\">uts</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Put information about the system in NAME.  */</span></span><br><span class=\"line\">    uname(&amp;uts);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name=%s\\n&quot;</span>,uts.sysname);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;version=%s\\n&quot;</span>,uts.version);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;release=%s\\n&quot;</span>,uts.release);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nodename=%s\\n&quot;</span>,uts.nodename);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;machine=%s\\n&quot;</span>,uts.machine);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**out：</span></span><br><span class=\"line\"><span class=\"comment\">    name=Linux</span></span><br><span class=\"line\"><span class=\"comment\">\tversion=#29~20.04.1-Ubuntu SMP Mon Aug 01 20:58:17 UTC 2021</span></span><br><span class=\"line\"><span class=\"comment\">\trelease=5.11.0-27-generic</span></span><br><span class=\"line\"><span class=\"comment\">\tnodename=longtaoXiaoXinPro13-2020</span></span><br><span class=\"line\"><span class=\"comment\">\tmachine=x86_64 </span></span><br><span class=\"line\"><span class=\"comment\">\t**/</span></span><br></pre></td></tr></table></figure>\n\n<p>utsname结构体如下,如果定义了_GNU_SOURCE还可以再打印个domainname</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">utsname</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Name of the implementation of the operating system.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> sysname[_UTSNAME_SYSNAME_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Name of this node on the network.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> nodename[_UTSNAME_NODENAME_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Current release level of this implementation.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> release[_UTSNAME_RELEASE_LENGTH];</span><br><span class=\"line\">    <span class=\"comment\">/* Current version level of this release.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> version[_UTSNAME_VERSION_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Name of the hardware type the system is running on.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> machine[_UTSNAME_MACHINE_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> _UTSNAME_DOMAIN_LENGTH - 0</span></span><br><span class=\"line\">    <span class=\"comment\">/* Name of the domain of this node on the network.  */</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">ifdef</span> __USE_GNU</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> domainname[_UTSNAME_DOMAIN_LENGTH];</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> __domainname[_UTSNAME_DOMAIN_LENGTH];</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"通过文件查看\"><a href=\"#通过文件查看\" class=\"headerlink\" title=\"通过文件查看\"></a>通过文件查看</h4><h5 id=\"内核信息\"><a href=\"#内核信息\" class=\"headerlink\" title=\"内核信息\"></a>内核信息</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;proc&#x2F;version</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"发行信息\"><a href=\"#发行信息\" class=\"headerlink\" title=\"发行信息\"></a>发行信息</h5><p>简要</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;etc&#x2F;issue</span><br></pre></td></tr></table></figure>\n\n<p>完整</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;etc&#x2F;*-release</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"CPU信息\"><a href=\"#CPU信息\" class=\"headerlink\" title=\"CPU信息\"></a>CPU信息</h5><p>lscpu命令或</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure>\n\n<p>除此之外还可以获取一些其他信息</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ ls /proc|grep info</span><br><span class=\"line\">buddyinfo </span><br><span class=\"line\">cpuinfo</span><br><span class=\"line\">meminfo</span><br><span class=\"line\">pagetypeinfo</span><br><span class=\"line\">slabinfo</span><br><span class=\"line\">vmallocinfo</span><br><span class=\"line\">zoneinfo</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"内存信息\"><a href=\"#内存信息\" class=\"headerlink\" title=\"内存信息\"></a>内存信息</h5><p>lsmem命令或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;proc&#x2F;memeinfo</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"其他信息\"><a href=\"#其他信息\" class=\"headerlink\" title=\"其他信息\"></a>其他信息</h5><p>buddyindo物理内存debug信息，lunux使用buddy算法解决物理内存的碎片问题</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ cat /proc/buddyinfo </span><br><span class=\"line\">Node 0, zone      DMA      1      0      0      1      2      1      1      0      1      2      2 </span><br><span class=\"line\">Node 0, zone    DMA32   2261   1007    541    301    455    234     60     24     12      4    321 </span><br><span class=\"line\">Node 0, zone   Normal   1120    593    346    660    116     36     32      6      5      4      1</span><br></pre></td></tr></table></figure>\n\n<p>zoneinfo显示内存空间的统计信息，对分析虚拟内存行为很有用</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"幽灵熔断","slug":"systemstructure/linux/meltdownspectre","date":"2020-08-25T14:24:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/meltdownspectre.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139657R-C.b99abc88fde8d7734d20066ed62d574f?rik=ikTwDJb6AKBbIg&riu=http%3a%2f%2fimg1.mydrivers.com%2fimg%2f20180326%2f7ad298a21c1e40f69f4eac81007e74a9.png&ehk=oGDeClWmtgCwNv4GlhChppBQcmJ1P2UGK34htcD2Ry0%3d&risl=&pid=ImgRaw&r=0","content":"<p>[toc]</p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>Meltdown/Spectre被发现于2018年, 是很有影响力的cpu漏洞。</p>\n<p>Meltdown（熔断）对应编号恶意数据缓存加载 CVE-2017-5754 。</p>\n<p>Spectre （幽灵）对应编号边界检查绕过 CVE-2017-5753 、分支目标注入 CVE-2017-5715 。</p>\n<p>Meltdown 影响几乎所有的 Intel CPU（从1995年起）以及部分 ARM CPU。 Spectre 拥有更广的影响范围，在 Meltdown 的情况下，恶意程序可读取某些自身无权限访问的数据。利用此漏洞低权限用户可以访问到本身无权限访问的内容，例如用户密码、加密密钥。</p>\n<p>Spectre 恶意利用程序，可导致用户的帐号、密码泄漏。在公共云服务器上，可能打破界限，从一台虚拟机器获取到另一个用户的权限。</p>\n<h3 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h3><p>指令周期：CPU取出一条指令并执行该指令所需的时间称为指令周期，指令周期的长短与指令的复杂程度有关，一般多个CPU周期组成指令周期。</p>\n<p>CPU周期：又称机器周期，通常用从主存读取一条指令的最短时间来规定CPU周期，一般多个时钟周期组成CPU周期</p>\n<p>时钟周期：时钟周期是处理操作的最基本时间单位，由机器的主频决定（超到20GHZ，全人类感谢你）</p>\n<h3 id=\"CPU的执行\"><a href=\"#CPU的执行\" class=\"headerlink\" title=\"CPU的执行\"></a>CPU的执行</h3><h4 id=\"基本过程\"><a href=\"#基本过程\" class=\"headerlink\" title=\"基本过程\"></a>基本过程</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211027/16353092843-4-257058.jpg\" alt=\"img\"></p>\n<p>cpu一般按照 取指令–&gt;指令译码—&gt;指令执行–&gt;存储访问–&gt;写回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">取指令 --&gt; 指令译码;</span><br><span class=\"line\">指令译码--&gt;指令执行;</span><br><span class=\"line\">指令执行--&gt;存储访问;</span><br><span class=\"line\">存储访问--&gt;写回;</span><br></pre></td></tr></table></figure>\n\n<p> 取指令:Instruction Fetch,从存储器取指令到CPU</p>\n<p>指令译码:Instruction Decode，对取回的指令进行拆分和解释，识别和区分出不同的指令类别及各种获取操作数的方法</p>\n<p>指令执行:Instruction Execute，使用硬件功能单元执行指令，最常见功能单元为算术逻辑部件运算器（Arithmetic Logical Unit，ALU）</p>\n<p>存储访问:Memory Access，根据指令需要，有可能要访问主存，读取操作数，具体见下表</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>算法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>隐含寻址</td>\n<td>默认操作数地址</td>\n<td>不访存</td>\n<td>数据范围受限</td>\n</tr>\n<tr>\n<td>立即寻址</td>\n<td>D = A</td>\n<td>不访存</td>\n<td>操作数值范围受限</td>\n</tr>\n<tr>\n<td>直接寻址</td>\n<td>EA = A</td>\n<td>简单</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>间接寻址</td>\n<td>EA = (A)</td>\n<td>地址范围大</td>\n<td>多次访存</td>\n</tr>\n<tr>\n<td>寄存器寻址</td>\n<td>EA = R</td>\n<td>不访存</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>寄存器间接寻址</td>\n<td>EA = ®</td>\n<td>地址范围大</td>\n<td>访存</td>\n</tr>\n<tr>\n<td>偏移寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>段寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>堆栈寻址</td>\n<td>EA = SP</td>\n<td>不访存</td>\n<td>应用受限</td>\n</tr>\n</tbody></table>\n<p>写回:把执行指令阶段的运行结果数据“写回”到某种存储形式，经常是写到cpu内部寄存器以便下次快速使用</p>\n<h4 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h4><p>若处理器无流水线结构，一条指令执行一般需要五个处理器周期；流水线使用锁存器（latch，用来缓存电信号）让不同指令的各步操作重叠，从而实现多条指令在不同周期并行处理，只执行一条指令的话，流水线不会提高效率。</p>\n<h4 id=\"分支预测\"><a href=\"#分支预测\" class=\"headerlink\" title=\"分支预测\"></a>分支预测</h4><p>流水线架构对顺序执行的命令，性能提升明显，但遇到命令跳转（goto系列等）就会性能降低，那么就出现了分支预测期，提前把预测到的指令存入流水线，分支跳转指令完成后如果预测正确，流水线正常运行，若错误，清空流水线然后执行正确的指令</p>\n<h4 id=\"乱序执行\"><a href=\"#乱序执行\" class=\"headerlink\" title=\"乱序执行\"></a>乱序执行</h4><p>打乱程序原本的执行顺序（类似上层使用异步，编译器也会乱序执行）</p>\n<p>cpu的乱序执行一般都使用Tomasulo算法，包括</p>\n<ul>\n<li>Common Data Bus (CDB).</li>\n<li>Unified Reservation Station (Scheduler).</li>\n<li>Register Renaming (Reorder Buffer).</li>\n</ul>\n<p>该算法虽然是乱序执行, 但是会顺序完成 (retire), 只有在retire后它的输出才会architectually visible (简单地说, 不影响程序逻辑), 但是没有architectually visible不等于没有影响, 当输出更新到reservation station后, 因为cdb的存在, 其他指令已经可以读到. 另外, 非常重要的一点, 异常只有在指令retire的时候才会触发, 对于上面的例子, 即使cpu已经检查到第一条指令没有访问权限, 也只能等到该指令retire时才会触发, 取决于该指令在ROB的位置, 可能马上触发也可能很久之后, ROB容量可以很容易做到比如192这个级别.</p>\n<h3 id=\"熔断漏洞（利用乱序执行）\"><a href=\"#熔断漏洞（利用乱序执行）\" class=\"headerlink\" title=\"熔断漏洞（利用乱序执行）\"></a>熔断漏洞（利用乱序执行）</h3><p>cpu在执行A语句的同时将B语句中的内存位置的信息加载到cache中，这个加载的过程忽略了权限的判断之后再执行B、C语句，在执行B语句时发现并没有权限，所以放弃乱序执行的结果，回滚到最初的状态依次执行。此时cache中的信息没有还原。之后通过边信道攻击来测试数据，发现对于某一个数据的访问要远远快于其他数据的访问，那么就可推断数据在cache中，并且可以反推回它的内存地址。</p>\n<h3 id=\"幽灵漏洞（利用分支预测）\"><a href=\"#幽灵漏洞（利用分支预测）\" class=\"headerlink\" title=\"幽灵漏洞（利用分支预测）\"></a>幽灵漏洞（利用分支预测）</h3><p>和熔断差不多，比如if else 中，提前预测某一条，预测错误，状态回滚，边信道攻击，反推内存地址</p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>打补丁，关闭乱序执行、分支预测，不过个人电脑建议别关，关了会影响性能。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"内置库re","slug":"language/python/re","date":"2020-08-20T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/python/re.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138518python3-print-function.png","content":"<p>re是python中的正则表达式内置库</p>\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>re.I</td>\n<td>IGNORECASE，忽略大小写</td>\n</tr>\n<tr>\n<td>re.L</td>\n<td>LOCALE，只对8位字节有效，不建议使用，由当前语言区域决定 <code>\\w</code>, <code>\\W</code>, <code>\\b</code>, <code>\\B</code> 和大小写敏感匹配</td>\n</tr>\n<tr>\n<td>re.U</td>\n<td>UNICODE，根据Unicode字符集解析字符。由当前语言区域决定 <code>\\w</code>, <code>\\W</code>, <code>\\b</code>, <code>\\B</code> 和大小写敏感匹配</td>\n</tr>\n<tr>\n<td>re.M</td>\n<td>MULTILINE，多行匹配，影响 ^ 和 $</td>\n</tr>\n<tr>\n<td>re.S</td>\n<td>DOTALL，.可以匹配除换行符外所有内容</td>\n</tr>\n<tr>\n<td>re.X</td>\n<td>VERBOSE，忽略空格和注释</td>\n</tr>\n</tbody></table>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"python","path":"api/tags/python.json"}]},{"title":"DOS与DDOS","slug":"systemstructure/security/dosandddos","date":"2020-08-15T15:34:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/security/dosandddos.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171524DDoS-Attack.jpg","content":"<p>　TCP报头中一共有六个标志位：URG/ACK/PSH/RST/SYN/FIN。<br>SYN<br>　　表示建立一个方向的连接。<br>ACK<br>　　收到数据或请求后发送响应时发送ACK报文。<br>RST<br>　　关闭异常连接<br>FIN<br>　　表示关闭连接 　<br>PSH<br>　　　发送端需要发送一段数据，这个数据需要接收端一收到就进行向上交付。而接收端在收到PSH标志位有效的数据时，迅速将数据交付给应用层。所以PSH又叫急迫比特。<br>　　　但是现在已经不需要将数据交付给应用层了，因为这些效果在TCP栈已经可以自行处理这些问题了。<br>URG<br>　　URG成为紧急指针，意为URG位有效的数据包，是一个紧急需要处理的数据包，需要接收端在接收到之后迅速处理。</p>\n<p>dos全称是denial of service，dos攻击是使目标计算机或网络无法提供正常服务(拒绝服务)</p>\n<p>产生dos攻击效果的方式有很多</p>\n<p>syn攻击</p>\n<p>半连接攻击，向服务器端连续发送大量只有SYN标志的TCP链接请求，服务器会吧这些半连接排到链接缓冲区(Backlog queue)中，缓冲区满，无法接受新的请求，其他合法用户的请求就会被拒绝</p>\n<p>rst攻击</p>\n<p>自己攻击自己</p>\n<p>消耗资源攻击(带宽、磁盘等)</p>\n<p>泛洪攻击(flood)发送大量报文syc、ack、rst、udp、icmp、dns、http/https等</p>\n<p>反射攻击，伪装成被攻击对象向其它机器发送请求，其他机器响应请求，发送大量报文给攻击目标，从而早成攻击目标的性能耗尽一般用udp报文，因为udp的响应报文比请求报文更大，能实现攻击流量放大的作用</p>\n<p>畸形报文攻击</p>\n<p>发送大量有缺陷或者特殊控制作用的报文，造成主机处理报文时系统崩溃</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"内存超分原理","slug":"systemstructure/linux/memoryoverscore","date":"2020-07-25T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/memoryoverscore.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139713OIP-C.xGR2ur4Cwbjx7OEW-pjD9gHaDa?pid=ImgDet&rs=1","content":"<p>KVM中内存也是允许过载使用（over-commit）的，KVM能够让分配给客户机的内存总数大于实际可用的物理内存总数。由于客户机操作系统及其上的应用程序并非一直100%地利用其分配到的内存，而且宿主机上的多个客户机一般也不会同时达到100%的内存使用率，所以内存过载分配是可行的。一般来说，有如下三种方式来实现内存的过载使用。</p>\n<ol>\n<li>内存交换（swapping）：用交换空间（swap space）来弥补内存的不足。</li>\n<li>气球（ballooning）：通过virio_balloon驱动来实现宿主机Hypervisor和客户机之间的协作来完成。</li>\n<li>页共享（page sharing）：通过KSM（Kernel Samepage Merging）合并多个客户机进程使用的相同内存页。</li>\n</ol>\n<p>其中，第一种内存交换的方式是最成熟的（Linux中很早就开始应用），也是目前被广泛使用的，不过，它相比于KSM和ballooning的方式效率较为低一些。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"SYN攻击","slug":"systemstructure/network/synattack","date":"2020-07-23T12:45:23.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/synattack.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171435tcp-three-way-handshake-and-syn-flood-attack.png","content":"<p>SYN：同步序列编号（***Synchronize Sequence Numbers***）。</p>\n<p>是TCP/IP建立连接时使用的握手信号。在客户机和<a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571\">服务器</a>之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以<a href=\"https://baike.baidu.com/item/ACK/3692629\">ACK</a>消息响应。这样在<a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E6%9C%BA/5168153\">客户机</a>和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递</p>\n<h3 id=\"TCP报文首部\"><a href=\"#TCP报文首部\" class=\"headerlink\" title=\"TCP报文首部\"></a>TCP报文首部</h3><p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>\n<ol>\n<li>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</li>\n<li>序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li>\n<li>确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li>\n<li>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li>\n<li>保留，占6位，保留今后使用，但目前应都位0；</li>\n<li>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li>\n<li>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</li>\n<li>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</li>\n<li>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</li>\n<li>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</li>\n<li>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li>\n<li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li>\n<li>检验和，占2字节，校验首部和数据这两部分；</li>\n<li>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</li>\n<li>选项，长度可变，定义一些其他的可选的参数。</li>\n</ol>\n<h3 id=\"TCP连接的建立（三次握手）\"><a href=\"#TCP连接的建立（三次握手）\" class=\"headerlink\" title=\"TCP连接的建立（三次握手）\"></a>TCP连接的建立（三次握手）</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171424format,png\" alt=\"三次握手\"></p>\n<ol>\n<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>\n<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>\n<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>\n<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>\n<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>\n</ol>\n<p><strong>必须三次握手的原因：</strong>双方必须确认对方正确知道对方的seq序号并以ack返回</p>\n<h3 id=\"TCP连接的释放（四次挥手）\"><a href=\"#TCP连接的释放（四次挥手）\" class=\"headerlink\" title=\"TCP连接的释放（四次挥手）\"></a>TCP连接的释放（四次挥手）</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png\" alt=\"四次挥手\"></p>\n<ol>\n<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>\n<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>\n<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>\n<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>\n<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>\n<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>\n</ol>\n<p><strong>point：</strong></p>\n<ol>\n<li>服务端和客户端都可以主动断开连接</li>\n<li>在收到FIN包，只是发送方这边不再发送数据了，但是接收方可能还有数据在发送给发送方，所以此时不能直接断开连接，也因此不能立马发送FIN包。</li>\n<li><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171435tcp-three-way-handshake-and-syn-flood-attack.png\" alt=\"See the source image\"></li>\n</ol>\n<p>author:longtao.wu</p>\n<p>blog:<a href=\"http://www.longtao.fun/\">www.longtao.fun</a></p>\n<p><strong>refrence：</strong></p>\n<ol>\n<li><a href=\"https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md\">https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md</a></li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"网卡驱动","slug":"systemstructure/network/nicdriver","date":"2020-07-19T12:30:22.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/nicdriver.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171258170855_4Tcf_3260790.png","content":"<p>驱动程序（Device Driver）全称为“设备驱动程序”，是一种可以使计算机中央处理器——CPU控制和使用设备的特殊程序，相当于硬件的接口，操作系统通过这个接口，控制硬件设备的工作。</p>\n<p>网卡设备与字符设备和块设备不同， 网络设备并不对应于/dev目录下的文件,不过会存放在/sys/class/net目录下</p>\n<p>Linux系统对网络设备驱动定义了4个层次， 这4个层次到下分为:</p>\n<p>网络协议接口层:</p>\n<p>实现统一的数据包收发的协议,该层主要负责调用dev_queue_xmit()函数发送数据， netif_rx()函数接收数据</p>\n<p>网络设备接口层:</p>\n<p>通过net_device结构体来描述一个具体的网络设备的信息,实现不同的硬件的统一</p>\n<p>设备驱动功能层：</p>\n<p>用来负责驱动网络设备硬件来完成各个功能, 它通过hard_start_xmit() 函数启动发送操作， 并通过网络设备上的中断触发接收操作,</p>\n<p>网络设备与媒介层：</p>\n<p>用来负责完成数据包发送和接收的物理实体, 设备驱动功能层的函数都在这物理上驱动的</p>\n<p><strong>层次结构如下图所示:</strong></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351712071182576-20171031190853498-1599050801.png\" alt=\"img\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171258170855_4Tcf_3260790.png\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"内置库os","slug":"language/python/import","date":"2020-06-20T15:20:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/python/import.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138518python3-print-function.png","content":"<p>一个 <a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-module\">module</a> 内的 Python 代码通过 <a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-importing\">importing</a> 操作就能够访问另一个模块内的代码。 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import\"><code>import</code></a> 语句是发起调用导入机制的最常用方式，但不是唯一的方式。 <a href=\"https://docs.python.org/zh-cn/3/library/importlib.html#importlib.import_module\"><code>importlib.import_module()</code></a> 以及内置的 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#import__\"><code>__import__()</code></a> 等函数也可以被用来发起调用导入机制。</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import\"><code>import</code></a> 语句结合了两个操作；它先搜索指定名称的模块，然后将搜索结果绑定到当前作用域中的名称。 <code>import</code> 语句的搜索操作被定义为对 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#import__\"><code>__import__()</code></a> 函数的调用并带有适当的参数。 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#import__\"><code>__import__()</code></a> 的返回值会被用于执行 <code>import</code> 语句的名称绑定操作。 请参阅 <code>import</code> 语句了解名称绑定操作的更多细节。</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>py2和py3在import时即使没有使用，也会初始化import的module文件</li>\n<li>在import文件初始化时，会对类属性进行初始化！</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"python","path":"api/tags/python.json"}]}]}