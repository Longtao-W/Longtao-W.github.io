{"total":78,"pageSize":10,"pageCount":8,"data":[{"title":"shc与upx加密混淆压缩","slug":"systemstructure/linux/shcandupx","date":"2021-04-25T15:27:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/shcandupx.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635140046OIP-C.6nySy7QLC94Nm0SNCoL5UwHaGE?pid=ImgDet&rs=1","content":"<p>[toc]</p>\n<h2 id=\"shc混淆\"><a href=\"#shc混淆\" class=\"headerlink\" title=\"shc混淆\"></a>shc混淆</h2><h3 id=\"shc安装\"><a href=\"#shc安装\" class=\"headerlink\" title=\"shc安装\"></a>shc安装</h3><p>从官网下载<a href=\"http://www.datsi.fi.upm.es/~frosal/sources/\">http://www.datsi.fi.upm.es/~frosal/sources/</a> (最新2015年的shc-3.8.9b.tgz)，或者源码下载<a href=\"https://github.com/neurobin/shc\">https://github.com/neurobin/shc</a> (有最新的)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://www.datsi.fi.upm.es/~frosal/sources/shc-3.8.9b.tgz</span><br><span class=\"line\">tar zxvf shc-3.8.9b.tgz</span><br><span class=\"line\">cd shc-3.8.9b</span><br><span class=\"line\">make clean</span><br><span class=\"line\">make test # 等待paused 然后回车</span><br><span class=\"line\">make strings&amp;install # 等待继续输入yes</span><br></pre></td></tr></table></figure>\n\n<p>shc命令说明</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-e %s  Expiration date in dd/mm/yyyy format [none]</span><br><span class=\"line\">-m %s  Message to display upon expiration [&quot;Please contact your provider&quot;]</span><br><span class=\"line\">-f %s  File name of the script to compile</span><br><span class=\"line\">-i %s  Inline option for the shell interpreter i.e: -e</span><br><span class=\"line\">-x %s  eXec command, as a printf format i.e: exec(&#x27;%s&#x27;,@ARGV);</span><br><span class=\"line\">-l %s  Last shell option i.e: --</span><br><span class=\"line\">-r     Relax security. Make a redistributable binary</span><br><span class=\"line\">-v     Verbose compilation</span><br><span class=\"line\">-D     Switch ON debug exec calls [OFF]</span><br><span class=\"line\">-T     Allow binary to be traceable [no]</span><br><span class=\"line\">-C     Display license and exit</span><br><span class=\"line\">-A     Display abstract and exit</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用shc给hello-world脚本加密\"><a href=\"#使用shc给hello-world脚本加密\" class=\"headerlink\" title=\"使用shc给hello world脚本加密\"></a>使用shc给hello world脚本加密</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 我们先创建一个sh</span></span><br><span class=\"line\">[root@localhost ~]# echo &#x27;#!/bin/bash&#x27; &gt; hello.sh;echo &quot;echo hello world&quot; &gt;&gt; hello.sh</span><br><span class=\"line\">[root@localhost ~]# chmod +x hello.sh;./hello.sh</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@localhost ~]# shc -f hello.sh</span><br><span class=\"line\">[root@localhost ~]# ./hello.sh.x</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<p>我们使用readelf查看发现是elf文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# readelf -h hello.sh.x </span><br><span class=\"line\">ELF 头：</span><br><span class=\"line\">  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class=\"line\">  Class:                             ELF64</span><br><span class=\"line\">  Data:                              2&#x27;s complement, little endian</span><br><span class=\"line\">  Version:                           1 (current)</span><br><span class=\"line\">  OS/ABI:                            UNIX - System V</span><br><span class=\"line\">  ABI Version:                       0</span><br><span class=\"line\">  Type:                              EXEC (可执行文件)</span><br><span class=\"line\">  Machine:                           Advanced Micro Devices X86-64</span><br><span class=\"line\">  Version:                           0x1</span><br><span class=\"line\">  入口点地址：              0x400d00</span><br><span class=\"line\">  程序头起点：              64 (bytes into file)</span><br><span class=\"line\">  Start of section headers:          9376 (bytes into file)</span><br><span class=\"line\">  标志：             0x0</span><br><span class=\"line\">  本头的大小：       64 (字节)</span><br><span class=\"line\">  程序头大小：       56 (字节)</span><br><span class=\"line\">  Number of program headers:         9</span><br><span class=\"line\">  节头大小：         64 (字节)</span><br><span class=\"line\">  节头数量：         28</span><br><span class=\"line\">  字符串表索引节头： 27</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"shc简单的原理介绍\"><a href=\"#shc简单的原理介绍\" class=\"headerlink\" title=\"shc简单的原理介绍\"></a>shc简单的原理介绍</h3><p>我们在使用<code>shc -f hello.sh</code>时会发现还生成了一个hello.sh.x.c的文件，阅读c我们知道shc是将脚本用rc4进行加密，然后将加密后的脚本、密钥、解密程序再用c编译成elf文件，在执行elf时再将加密的脚本解密运行。  看了shc的混淆方式，我们也可以用其他编译行语言(例如go、rust、c++)等自己实现，更换加解密算法，甚至不用加解密算法。</p>\n<h3 id=\"从shc-可执行文件获取源码-逆向\"><a href=\"#从shc-可执行文件获取源码-逆向\" class=\"headerlink\" title=\"从shc 可执行文件获取源码(逆向)\"></a>从shc 可执行文件获取源码(逆向)</h3><ol>\n<li>使用IDA等反编译工具动态调试，找解密后的函数</li>\n<li>使用coredump 从内存读取。</li>\n<li>使用一些现有的工具，例如<a href=\"https://github.com/yanncam/UnSHc%EF%BC%8C%E6%96%B0%E7%9A%84shc%E5%8A%A0%E5%85%A5%E4%BA%86linux%E5%86%85%E6%A0%B8%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%A5%BD%E5%83%8F%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86\">https://github.com/yanncam/UnSHc，新的shc加入了linux内核本身的安全机制，好像不能用了</a></li>\n</ol>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><ol>\n<li>使用gzexe混淆</li>\n<li> shc -e 过期时间挺好用的</li>\n</ol>\n<h2 id=\"使用upx加壳\"><a href=\"#使用upx加壳\" class=\"headerlink\" title=\"使用upx加壳\"></a>使用upx加壳</h2><h3 id=\"upx安装\"><a href=\"#upx安装\" class=\"headerlink\" title=\"upx安装\"></a>upx安装</h3><p>从<a href=\"https://github.com/upx/upx\">https://github.com/upx/upx</a> 下载源码安装或其他包管理器安装</p>\n<h3 id=\"upx-演示\"><a href=\"#upx-演示\" class=\"headerlink\" title=\"upx 演示\"></a>upx 演示</h3><p>在我们刚刚使用shc对helloworld脚本编译生成elf后，我们可以使用upx对此elf进行加壳压缩，也算是一种混淆方式</p>\n<p>upx压缩前 11k</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# ls -lh ./hello.sh.x</span><br><span class=\"line\">-rwx--x--x. 1 root root 11K 7月  23 10:19 ./hello.sh.x</span><br></pre></td></tr></table></figure>\n\n<p>upx 压缩后 6.9k, -9代表压缩等级（1-9,9个等级）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# upx -9 ./hello.sh.x;ls -lh ./hello.sh.x</span><br><span class=\"line\">                       Ultimate Packer for eXecutables</span><br><span class=\"line\">                          Copyright (C) 1996 - 2013</span><br><span class=\"line\">UPX 3.91        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Sep 30th 2013</span><br><span class=\"line\"></span><br><span class=\"line\">        File size         Ratio      Format      Name</span><br><span class=\"line\">   --------------------   ------   -----------   -----------</span><br><span class=\"line\">     11168 -&gt;      7004   62.71%  linux/ElfAMD   hello.sh.x                    </span><br><span class=\"line\"></span><br><span class=\"line\">Packed 1 file.</span><br><span class=\"line\">-rwx--x--x. 1 root root 6.9K 7月  23 10:19 ./hello.sh.x</span><br></pre></td></tr></table></figure>\n\n<p>我们压缩后的helloworld依然正常运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# ./hello.sh.x </span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"upx原理\"><a href=\"#upx原理\" class=\"headerlink\" title=\"upx原理\"></a>upx原理</h3><p>对elf文件进行压缩并插入解压代码，在运行时（加载到内存时）解压代码</p>\n<h3 id=\"脱壳工具\"><a href=\"#脱壳工具\" class=\"headerlink\" title=\"脱壳工具\"></a>脱壳工具</h3><p>略</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"zeroconf与mDNS","slug":"tools/zeroconf","date":"2021-04-22T15:20:21.000Z","updated":"2024-06-30T10:35:56.312Z","comments":true,"path":"api/articles/tools/zeroconf.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635172543v2-63f3b744dfd677033510885cd655a34c_r.jpg","content":"<p>[toc]</p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>路由中有以下几种形式</p>\n<p>单播：在网络地址和网络节点之间存在一一对应的关系。</p>\n<p>任播：根据路由拓扑自动决定送到“最近”或“最好”的目的地</p>\n<p>多播：是一种群组通信，它把信息同时传递给一组目的计算机。常指IP多播，组播地址224.0.0.0～224.0.0.255</p>\n<p>广播:向指定网络范围内所以设备发送信息，主机标识段host ID 为全1 的IP 地址为广播地址，ARP、DHCP都使用了广播</p>\n<p>地域性广播：一种“特殊”的多播</p>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>Domain Name System,域名服务，将域名和ip地址互相影射的分布式数据库，使用TCP和UDP的53端口</p>\n<p>TCP：面向连接的协议，提供可靠的数据传输，一般服务质量要求比较高的情况，使用这个协议。</p>\n<p>UDP：用户数据报协议，是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>\n<h2 id=\"zeroConf\"><a href=\"#zeroConf\" class=\"headerlink\" title=\"zeroConf\"></a>zeroConf</h2><p>Zero configuration networking,零配置网络服务规范是一种让用户武穴使用DHCP、DNS等设置就能自动连接设备的一种规范，主要包含以下协议</p>\n<ul>\n<li>Link-Local Address： 无需利用DHCP Server 取得设备地址和IP的相关资料 【RFC3927】</li>\n<li>Multicast Dns： 不需要DNS Server 就可以解决domain 和ip的绑定关系 【RFC6762】</li>\n<li>DNS-SD（dns-based service discovery）： 不需要目录服务器，就可以自动发现设备服务 【RFC6763】</li>\n</ul>\n<h2 id=\"mDNS\"><a href=\"#mDNS\" class=\"headerlink\" title=\"mDNS\"></a>mDNS</h2><h4 id=\"原理和特点\"><a href=\"#原理和特点\" class=\"headerlink\" title=\"原理和特点\"></a>原理和特点</h4><p>Multicast DNS (mDNS)，多播DNS，使用5353端口，组播地址为 <code>224.0.0.251</code> 或 <code>[FF02::FB]</code> 。在一个没有常规DNS服务器的小型网络内可以使用mDNS来实现类似DNS的编程接口、包格式和操作语义,mdns协议使用DNS协议一样的数据包</p>\n<p>若主机开启了mDNS，在进入局域网内时会向224.0.0.251地址发送信息，信息内容包含，ip地址端口号，服务名等；</p>\n<p>同时其mDNS服务会向其它mDNS询问获取局域网内的服务。</p>\n<p>mDNS的顶级域名用 <code>.local</code> 和普通域名区分开的.</p>\n<h2 id=\"DNS-SD\"><a href=\"#DNS-SD\" class=\"headerlink\" title=\"DNS-SD\"></a>DNS-SD</h2><p>DNS Service Discovery是一种基于 DNS 协议的服务发现协议，设备之间可以通过该协议自动发现服务</p>\n<p>使用如下格式</p>\n<p><code>&lt;instance&gt;.&lt;service&gt;.&lt;transport&gt;.&lt;domain&gt;</code></p>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>启动DNS-SD的主机在进入局域网后或启动DNS-SD后会向组播地址发送组播消息，包括主机名、IP信息等，其他拥有相应服务的主机会响应</p>\n<p>关闭DNS-SD的主机在关闭DNS-SD后会向组播地址刷新组播消息，清除信息</p>\n<h2 id=\"技术应用\"><a href=\"#技术应用\" class=\"headerlink\" title=\"技术应用\"></a>技术应用</h2><p>avahi、bonjour、WiSe-Zeroconf是zeroconf协议的常用实现</p>\n<p>在苹果家族中常使用Bonjour、linux中常用avahi、在嵌入式领域常用WiSe-Zeroconf</p>\n<h3 id=\"小玩具\"><a href=\"#小玩具\" class=\"headerlink\" title=\"小玩具\"></a>小玩具</h3><h4 id=\"安装-amp-下载-rocket\"><a href=\"#安装-amp-下载-rocket\" class=\"headerlink\" title=\"安装&amp;下载:rocket:\"></a>安装&amp;下载:rocket:</h4><p>使用golang的<code>zeroconf</code>包进行简单封装的玩具</p>\n<p>server端：<a href=\"http://192.168.200.150/mirror/longtao.wu/tools/mdnsToy/mdns-server-linux-amd64\">amd64-linux</a> <a href=\"http://192.168.200.150/mirror/longtao.wu/tools/mdnsToy/mdns-server-mac-amd64\">amd64-mac</a> <a href=\"http://192.168.200.150/mirror/longtao.wu/tools/mdnsToy/mdns-server-win-amd64.exe\">amd64-win</a></p>\n<p>client端：<a href=\"http://192.168.200.150/mirror/longtao.wu/tools/mdnsToy/mdns-client-linux-amd64\">amd64-linux</a> <a href=\"http://192.168.200.150/mirror/longtao.wu/tools/mdnsToy/mdns-client-mac-amd64\">amd64-mac</a> <a href=\"http://192.168.200.150/mirror/longtao.wu/tools/mdnsToy/mdns-client-win-amd64.exe\">amd64-win</a></p>\n<h4 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h4><h3 id=\"AVAHI\"><a href=\"#AVAHI\" class=\"headerlink\" title=\"AVAHI\"></a>AVAHI</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install nss-mDNS avahi avahi-tools -y</span><br></pre></td></tr></table></figure>\n\n<p>avahi-tools是avahi的工具包，包含avahi-browse、avahi-publish-address 、 avahi-resolve-host-nameavahi-browse-domains、avahi-publish-service、avahi-set-host-name、avahi-daemon、avahi-resolve、avahi-publish、avahi-resolve-address</p>\n<p>常用的avahi-browse的功能如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-D --browse-domains  浏览域而不是服务</span><br><span class=\"line\">-a --all             显示所有服务，忽略类型</span><br><span class=\"line\">-d --domain=DOMAIN   要浏览的域</span><br><span class=\"line\">-v --verbose         启用详述模式</span><br><span class=\"line\">-t --terminate       导出一个完整列表后终止</span><br><span class=\"line\">-c --cache           导出缓存中的所有条目后终止</span><br><span class=\"line\">-l --ignore-local    忽略本地服务</span><br><span class=\"line\">-r --resolve         解析找到的服务</span><br><span class=\"line\">-f --no-fail         如果 daemon 不可用也不中断</span><br><span class=\"line\">-p --parsable        输出可解析格式</span><br><span class=\"line\">-k --no-db-lookup    不查询服务类型</span><br><span class=\"line\">-b --dump-db         导出服务类型数据库</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"添加服务\"><a href=\"#添加服务\" class=\"headerlink\" title=\"添加服务\"></a>添加服务</h4><p>创建文件 /etc/avahi/services/wltHello.service</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; standalone&#x3D;&#39;no&#39;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE service-group SYSTEM &quot;avahi-service.dtd&quot;&gt;</span><br><span class=\"line\">&lt;service-group&gt;</span><br><span class=\"line\">    &lt;name&gt;wlt@*Hello&lt;&#x2F;name&gt;</span><br><span class=\"line\">    &lt;service&gt;</span><br><span class=\"line\">        &lt;type&gt;_wlt@*Hello._tcp&lt;&#x2F;type&gt;</span><br><span class=\"line\">        &lt;port&gt;5678&lt;&#x2F;port&gt;</span><br><span class=\"line\">    &lt;&#x2F;service&gt;</span><br><span class=\"line\">&lt;&#x2F;service-group&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重启服务\"><a href=\"#重启服务\" class=\"headerlink\" title=\"重启服务\"></a>重启服务</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart dbus</span><br><span class=\"line\">systemctl restart avahi-daemon</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询服务\"><a href=\"#查询服务\" class=\"headerlink\" title=\"查询服务\"></a>查询服务</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# avahi-browse -vrtp _wlt@*Hello._tcp</span><br><span class=\"line\">+;eth0;IPv4;wlt\\064\\042Hello;_wlt\\064\\042Hello._tcp;local</span><br><span class=\"line\">=;eth0;IPv4;wlt\\064\\042Hello;_wlt\\064\\042Hello._tcp;local;linux.local;172.20.65.36;5678;</span><br></pre></td></tr></table></figure>\n\n<p>通过avahi-browse即可在局域网内通过avahi-browse发现服务</p>\n<p>在实际生产中，我们可以在开启服务时同时添加mDNS服务，消费者机器通过avahi-browse查询服务得到开启服务的ip地址，再进一步与服务建立链接。除此之外avahi还暴露了一些api：<a href=\"https://www.avahi.org/doxygen/v0.7/html/index.html\">https://www.avahi.org/doxygen/v0.7/html/index.html</a></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"应用","path":"api/tags/应用.json"}]},{"title":"中间人攻击与HTTPS","slug":"systemstructure/network/maninthemiddleattackandhttps","date":"2021-04-15T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/maninthemiddleattackandhttps.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635168198HTTP-vs-HTTPS.png","content":"<p>[toc]</p>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>HTTP(hypertext transfer protocol )协议是一种七层协议，是万维网通信的基石，通常使用tcp协议(HTTP3使用quic(udp))，默认端口80</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>GET、HEAD：获取资源</p>\n<p>POST：上传资源</p>\n<p>PUT：修改资源</p>\n<p>DELETE：删除资源</p>\n<p>TRACE：回显请求</p>\n<p>OPTIONS：回复资源所有可用方法</p>\n<p>CONNECT：留给SSL加密使用</p>\n<h3 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h3><p>在函数式编程中，幂等函数是对任何值x具有f（f（x））= f（x）属性的函数，在编程领域，则意为同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的</p>\n<p>GET、HEAD、PUT、DELETE、OPTIONS、TRACE都是幂等的，而GET、HEAD、OPTIONS、TRACE一般来说没有副作用。</p>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><ul>\n<li>1xx消息：请求已被服务器接收，继续处理</li>\n<li>2xx成功：请求成功</li>\n<li>3xx重定向：重定向</li>\n<li>4xx请求错误：客户端错误</li>\n<li>5xx服务器错误：服务器错误</li>\n</ul>\n<h3 id=\"HTTP-keeep-alive\"><a href=\"#HTTP-keeep-alive\" class=\"headerlink\" title=\"HTTP keeep-alive\"></a>HTTP keeep-alive</h3><p>HTTP1.1加入</p>\n<p>优点：同时打开的TCP链接少了、降低延时</p>\n<p>缺点：请求后保持链接，可能会影响性能</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>HTTPS(hypertext transfer protocol secure)是使用HTTP通信，使用SSL/TLS加密数据包，默认端口443</p>\n<h3 id=\"传输过程\"><a href=\"#传输过程\" class=\"headerlink\" title=\"传输过程\"></a>传输过程</h3><p>证书验证阶段：</p>\n<ol>\n<li>浏览器发起HTTPS请求</li>\n<li>服务端返回HTTPS证书和SSL非对称加密公钥</li>\n<li>浏览器，验证HTTPS证书合法性，合法就生成随机数</li>\n</ol>\n<p>传输阶段：</p>\n<ol>\n<li>浏览器通过SSL公钥加密随机数，传输到服务端</li>\n<li>服务端通过SSL私钥解密，通过随机数构造对称加密(TLS)，通过TLS传输</li>\n</ol>\n<h4 id=\"如何验证证书合法性\"><a href=\"#如何验证证书合法性\" class=\"headerlink\" title=\"如何验证证书合法性\"></a>如何验证证书合法性</h4><p>证书包含：公钥、持有者信息、证书机构信息(CA)、数字签名和算法、有效期等</p>\n<p>证书签发：</p>\n<ol>\n<li>CA把各种信息打包通过计算得到hash值</li>\n<li>CA使用私钥对hash值加密生成证书签名</li>\n<li>将证书签名加到文件证书上，形成数字证书</li>\n</ol>\n<p>证书校验：</p>\n<ol>\n<li>浏览器通过同样hash算法得到hash值</li>\n<li>浏览器用公钥对CA数字签名解密与自己算的hash值比较，若相同就是可信的</li>\n</ol>\n<p>证书信任链：通过当前证书-中间证书-根证书逐级担保信任</p>\n<h2 id=\"中间人攻击\"><a href=\"#中间人攻击\" class=\"headerlink\" title=\"中间人攻击\"></a>中间人攻击</h2><p>A与C进行通信时，需要经过B进行传输，B获取了A和C的通话信息，B分别伪装成A和C通信，伪装成C和A通信</p>\n<h3 id=\"非对称加密场景\"><a href=\"#非对称加密场景\" class=\"headerlink\" title=\"非对称加密场景\"></a>非对称加密场景</h3><p>A发送公钥给C时，B作为中间人攻击，B也生成公私钥，B将自己的公钥发给C和C通信，B通过A发送的公钥和A通信</p>\n<h3 id=\"HTTPS中的中间人攻击\"><a href=\"#HTTPS中的中间人攻击\" class=\"headerlink\" title=\"HTTPS中的中间人攻击\"></a>HTTPS中的中间人攻击</h3><p>在缺少证书验证环节时，可以进行HTTPS中间人攻击，具体流程如下</p>\n<ol>\n<li>A与C进行通信时，本地请求劫持，B成为中间人</li>\n<li>B返回自己伪造的证书给A，B与C通信</li>\n<li>A不会验证证书，直接创建随机数，与B进行通信</li>\n<li>B与C按照正常流程进行通信</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"udp offload","slug":"systemstructure/network/offload","date":"2021-03-25T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/offload.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171342R-C.3fd39d32acf22e924676ae13410bc7f8?rik=CpqSRGJGylO%2fBw&riu=http%3a%2f%2fwiki.networksecuritytoolkit.org%2fimages%2fthumb%2fNo_segmentation_offloading.png%2f964px-No_segmentation_offloading.png&ehk=pAE0DfOX5Ii0DGj2zezPKbufNwQEX0uE62lUjaW09OA%3d&risl=&pid=ImgRaw&r=0","content":"<h2 id=\"tx-udp-tnl-segmentation\"><a href=\"#tx-udp-tnl-segmentation\" class=\"headerlink\" title=\"tx-udp_tnl-segmentation\"></a><strong>tx-udp_tnl-segmentation</strong></h2><p>Overlay网络，例如VxLAN，现在应用的越来越多。Overlay网络可以使得用户不受物理网络的限制，进而创建，配置并管理所需要的虚拟网络连接。同时Overlay可以让多个租户共用一个物理网络，提高网络的利用率。Overlay网络有很多种，但是最具有代表性的是VxLAN。VxLAN是一个MAC in UDP的设计，具体格式如下所示。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455587v2-f6d9dcd0ad97394b4c4585ee161245f0_1440w.jpg\" alt=\"img\"></p>\n<p>从VxLAN的格式可以看出，以VxLAN为代表的Overlay网络在性能上存在两个问题。一个是Overhead的增加，VxLAN在原始的Ethernet Frame上再包了一层Ethernet+IP+UDP+VXLAN，这样每个Ethernet Frame比原来要多传输50个字节。所以可以预见的是，Overlay网络的效率必然要低于Underlay网络。另一个问题比传50个字节更为严重，那就是需要处理这额外的50个字节。这50个字节包括了4个Header，每个Header都涉及到拷贝，计算，都需要消耗CPU。而我们现在迫切的问题在于CPU可以用来处理每个网络数据包的时间更少了。</p>\n<p>首先，VxLAN的这50个字节是没法避免的。其次，那就只能降低它的影响。这里仍然可以采用Jumbo Frames的思想，因为50个字节是固定的，那网络数据包越大，50字节带来的影响就相对越小。</p>\n<p>先来看一下虚拟机的网络连接图。虚拟机通过QEMU连接到位于宿主机的TAP设备，之后再通过虚机交换机转到VTEP（VxLAN Tunnel EndPoint），封装VxLAN格式，发给宿主机网卡。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455592v2-a4653d5451d3cf9737399d07be171d6e_1440w.jpg\" alt=\"img\"></p>\n<p>理想情况就是，一大段VxLAN数据直接传给网卡，由网卡去完成剩下的分片，分段，并对分成的小的网络包分别封装VxLAN，计算校验和等工作。这样VxLAN对虚机网络带来影响就可以降到最低。实际中，这是可能的，但是需要一系列的前提条件。</p>\n<p>首先，虚拟机要把大的网络包发到宿主机。因为虚拟机里面也运行了一个操作系统，也有自己的TCP/IP协议栈，所以虚拟机完全有能力自己就把大的网络包分成多个小的网络包。从前面介绍的内容看，只有TSO才能真正将一个大的网络包发到网卡。GSO在发到网卡的时候，已经在进入驱动的前一刻将大的网络包分成了若干个小的网络数据包。所以这里要求：虚机的网卡支持TSO（Virtio默认支持），并且打开TSO（默认打开），同时虚机发出的是TCP数据。</p>\n<p>之后，经过QEMU，虚拟交换机的转发，VTEP的封装，这个大的TCP数据被封装成了VxLAN格式。50个字节的VxLAN数据被加到了这个大的TCP数据上。接下来问题来了，这本来是个TCP数据，但是因为做了VxLAN的封装，现在看起来像是个UDP的数据。如果操作系统不做任何处理，按照前面的介绍，那就应该走GSO做IP Fragmentation，并在发送给网卡的前一刻分成多个小包。这样，如果网卡本来支持TSO现在就用不上了。并且更加严重的是，现在还没做TCP Segmentation。我们在上一篇花了很大的篇幅介绍其必要性的TCP Segmentation在这里也丢失了。</p>\n<p>对于现代的网卡，除了TSO，GSO等offload选项外，还多了一个选项tx-udp_tnl-segmentation。如果这个选项打开，操作系统自己会识别封装成VxLAN的UDP数据是一个tunnel数据，并且操作系统会直接把这一大段VxLAN数据丢给网卡去处理。在网卡里面，网卡会针对内层的TCP数据，完成TCP Segmentation。之后再为每个TCP Segment加上VxLAN封装（50字节），如下图右所示。这样，VxLAN封装对于虚拟机网络来说，影响降到了最低。</p>\n<p>从前面描述看，要达成上述的效果，需要宿主机网卡同时支持TSO和tx-udp_tnl-segmentation。如果这两者任意一个不支持或者都不支持。那么系统内核会调用GSO，将封装成VxLAN格式的大段TCP数据，在发给网卡驱动前完成TCP Segmentation，并且为每个TCP Segment加上VxLAN封装。如下图左所示。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455599v2-539c4c2923a10f9c331325ef604b1864_1440w.jpg\" alt=\"img\"></p>\n<p>如果关闭虚拟机内的TSO，或者虚拟机内发送的是UDP数据。那么在虚拟机的TCP/IP协议栈会调用GSO，发给虚拟机网卡驱动的前一刻，完成了分段、分片。虚拟机最终发到QEMU的网络数据包就是多个小的网络数据包。这个时候，无论宿主机怎么配置，都需要处理多个小的网络包，并对他们做VxLAN封装。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171342R-C.3fd39d32acf22e924676ae13410bc7f8?rik=CpqSRGJGylO/Bw&riu=http://wiki.networksecuritytoolkit.org/images/thumb/No_segmentation_offloading.png/964px-No_segmentation_offloading.png&ehk=pAE0DfOX5Ii0DGj2zezPKbufNwQEX0uE62lUjaW09OA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"Linux IO模式","slug":"systemstructure/linux/linuxio","date":"2021-03-25T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/linuxio.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139551R-C.33d57d1aac13ec6a4e7f917e0a47bb69?rik=o%2fuWsKRpOPc7MA&riu=http%3a%2f%2fwww.thomas-krenn.com%2fde%2fwikiDE%2fimages%2fd%2fda%2fLinux-io-stack-diagram_v1.0.png&ehk=1OGRYIpfyG0jiVPRMEKwfpXnNXxZpCQUOMRDg4u7Pz0%3d&risl=&pid=ImgRaw&r=0","content":"<p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本文讨论的背景是Linux环境下的network IO。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"概念说明\"><a href=\"#概念说明\" class=\"headerlink\" title=\"概念说明\"></a>概念说明</h3><p>在进行解释之前，首先要说明几个概念：<br>- 用户空间和内核空间<br>- 进程切换<br>- 进程的阻塞<br>- 文件描述符<br>- 缓存 I/O</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a>用户空间与内核空间</h4><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>\n<h4 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h4><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>\n<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：<br>\\1. 保存处理机上下文，包括程序计数器和其他寄存器。<br>\\2. 更新PCB信息。<br>\\3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<br>\\4. 选择另一个进程执行，并更新其PCB。<br>\\5. 更新内存管理的数据结构。<br>\\6. 恢复处理机上下文。</p>\n<p>注：<strong>总而言之就是很耗资源</strong>，具体的可以参考这篇文章：<a href=\"http://guojing.me/linux-kernel-architecture/posts/process-switch/\">进程切换</a></p>\n<h4 id=\"进程的阻塞\"><a href=\"#进程的阻塞\" class=\"headerlink\" title=\"进程的阻塞\"></a>进程的阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p>\n<h4 id=\"文件描述符fd\"><a href=\"#文件描述符fd\" class=\"headerlink\" title=\"文件描述符fd\"></a>文件描述符fd</h4><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>\n<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>\n<h4 id=\"缓存-I-O\"><a href=\"#缓存-I-O\" class=\"headerlink\" title=\"缓存 I/O\"></a>缓存 I/O</h4><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>\n<p><strong>缓存 I/O 的缺点：</strong><br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>\n<h3 id=\"IO模式\"><a href=\"#IO模式\" class=\"headerlink\" title=\"IO模式\"></a>IO模式</h3><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：<br>\\1. 等待数据准备 (Waiting for the data to be ready)<br>\\2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p>\n<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。<br>- 阻塞 I/O（blocking IO）<br>- 非阻塞 I/O（nonblocking IO）<br>- I/O 多路复用（ IO multiplexing）<br>- 信号驱动 I/O（ signal driven IO）<br>- 异步 I/O（asynchronous IO）</p>\n<p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>\n<h4 id=\"阻塞-I-O（blocking-IO）\"><a href=\"#阻塞-I-O（blocking-IO）\" class=\"headerlink\" title=\"阻塞 I/O（blocking IO）\"></a>阻塞 I/O（blocking IO）</h4><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://segmentfault.com/img/bVm1c3\" alt=\"clipboard.png\"></p>\n<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>\n<blockquote>\n<p>  所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>\n</blockquote>\n<h4 id=\"非阻塞-I-O（nonblocking-IO）\"><a href=\"#非阻塞-I-O（nonblocking-IO）\" class=\"headerlink\" title=\"非阻塞 I/O（nonblocking IO）\"></a>非阻塞 I/O（nonblocking IO）</h4><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://segmentfault.com/img/bVm1c4\" alt=\"clipboard.png\"></p>\n<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>\n<blockquote>\n<p>  所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p>\n</blockquote>\n<h4 id=\"I-O-多路复用（-IO-multiplexing）\"><a href=\"#I-O-多路复用（-IO-multiplexing）\" class=\"headerlink\" title=\"I/O 多路复用（ IO multiplexing）\"></a>I/O 多路复用（ IO multiplexing）</h4><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://segmentfault.com/img/bVm1c5\" alt=\"clipboard.png\"></p>\n<p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>\n<blockquote>\n<p>  所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>\n</blockquote>\n<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>\n<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>\n<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>\n<h4 id=\"异步-I-O（asynchronous-IO）\"><a href=\"#异步-I-O（asynchronous-IO）\" class=\"headerlink\" title=\"异步 I/O（asynchronous IO）\"></a>异步 I/O（asynchronous IO）</h4><p>inux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139536bVm1c8\" alt=\"clipboard.png\"></p>\n<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><h5 id=\"blocking和non-blocking的区别\"><a href=\"#blocking和non-blocking的区别\" class=\"headerlink\" title=\"blocking和non-blocking的区别\"></a>blocking和non-blocking的区别</h5><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>\n<h5 id=\"synchronous-IO和asynchronous-IO的区别\"><a href=\"#synchronous-IO和asynchronous-IO的区别\" class=\"headerlink\" title=\"synchronous IO和asynchronous IO的区别\"></a>synchronous IO和asynchronous IO的区别</h5><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>- An asynchronous I/O operation does not cause the requesting process to be blocked;</p>\n<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>\n<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>\n<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>\n<p><strong>各个IO Model的比较如图所示：</strong><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139539bVm1c9\" alt=\"clipboard.png\"></p>\n<p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>\n<h3 id=\"I-O-多路复用之select、poll、epoll详解\"><a href=\"#I-O-多路复用之select、poll、epoll详解\" class=\"headerlink\" title=\"I/O 多路复用之select、poll、epoll详解\"></a>I/O 多路复用之select、poll、epoll详解</h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p>\n<h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>\n\n<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>\n<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>\n<h4 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>\n\n<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct pollfd &#123;</span><br><span class=\"line\">    int fd; &#x2F;* file descriptor *&#x2F;</span><br><span class=\"line\">    short events; &#x2F;* requested events to watch *&#x2F;</span><br><span class=\"line\">    short revents; &#x2F;* returned events witnessed *&#x2F;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>\n<blockquote>\n<p>  从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>\n</blockquote>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>\n<h5 id=\"epoll操作过程\"><a href=\"#epoll操作过程\" class=\"headerlink\" title=\"epoll操作过程\"></a>epoll操作过程</h5><p>epoll操作过程需要三个接口，分别如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int epoll_create(int size)；&#x2F;&#x2F;创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class=\"line\">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class=\"line\">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>\n\n<p><strong>1. int epoll_create(int size);</strong><br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>\n<p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong><br>函数是对指定描述符fd执行op操作。<br>- epfd：是epoll_create()的返回值。<br>- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。<br>- fd：是需要监听的fd（文件描述符）<br>- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct epoll_event &#123;</span><br><span class=\"line\">  __uint32_t events;  &#x2F;* Epoll events *&#x2F;</span><br><span class=\"line\">  epoll_data_t data;  &#x2F;* User data variable *&#x2F;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;events可以是以下几个宏的集合：</span><br><span class=\"line\">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class=\"line\">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class=\"line\">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class=\"line\">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class=\"line\">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class=\"line\">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class=\"line\">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>\n<h5 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h5><p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>\n<h6 id=\"LT模式\"><a href=\"#LT模式\" class=\"headerlink\" title=\"LT模式\"></a>LT模式</h6><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>\n<h6 id=\"ET模式\"><a href=\"#ET模式\" class=\"headerlink\" title=\"ET模式\"></a>ET模式</h6><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>\n<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h6 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h6><p><strong>假如有这样一个例子：</strong><br>\\1. 我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符<br>\\2. 这个时候从管道的另一端被写入了2KB的数据<br>\\3. 调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作<br>\\4. 然后我们读取了1KB的数据<br>\\5. 调用epoll_wait(2)……</p>\n<p><strong>LT模式：</strong><br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p>\n<p><strong>ET模式：</strong><br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>\n<p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，<br>读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(rs)&#123;</span><br><span class=\"line\">  buflen &#x3D; recv(activeevents[i].data.fd, buf, sizeof(buf), 0);</span><br><span class=\"line\">  if(buflen &lt; 0)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span><br><span class=\"line\">    &#x2F;&#x2F; 在这里就当作是该次事件已处理处.</span><br><span class=\"line\">    if(errno &#x3D;&#x3D; EAGAIN)&#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else if(buflen &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">     &#x2F;&#x2F; 这里表示对端的socket已正常关闭.</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> if(buflen &#x3D;&#x3D; sizeof(buf)&#123;</span><br><span class=\"line\">      rs &#x3D; 1;   &#x2F;&#x2F; 需要再次读取</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> else&#123;</span><br><span class=\"line\">      rs &#x3D; 0;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  <strong>Linux中的EAGAIN含义</strong></p>\n</blockquote>\n<p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p>\n<p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p>\n<h5 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h5><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define IPADDRESS   &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define PORT        8787</span><br><span class=\"line\">#define MAXSIZE     1024</span><br><span class=\"line\">#define LISTENQ     5</span><br><span class=\"line\">#define FDSIZE      1000</span><br><span class=\"line\">#define EPOLLEVENTS 100</span><br><span class=\"line\"></span><br><span class=\"line\">listenfd &#x3D; socket_bind(IPADDRESS,PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">struct epoll_event events[EPOLLEVENTS];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;创建一个描述符</span><br><span class=\"line\">epollfd &#x3D; epoll_create(FDSIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;添加监听描述符事件</span><br><span class=\"line\">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;循环等待</span><br><span class=\"line\">for ( ; ; )&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;该函数返回已经准备好的描述符事件数目</span><br><span class=\"line\">    ret &#x3D; epoll_wait(epollfd,events,EPOLLEVENTS,-1);</span><br><span class=\"line\">    &#x2F;&#x2F;处理接收到的连接</span><br><span class=\"line\">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;事件处理函数</span><br><span class=\"line\">static void handle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     int i;</span><br><span class=\"line\">     int fd;</span><br><span class=\"line\">     &#x2F;&#x2F;进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span><br><span class=\"line\">     for (i &#x3D; 0;i &lt; num;i++)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         fd &#x3D; events[i].data.fd;</span><br><span class=\"line\">        &#x2F;&#x2F;根据描述符的类型和事件类型进行处理</span><br><span class=\"line\">         if ((fd &#x3D;&#x3D; listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class=\"line\">            handle_accpet(epollfd,listenfd);</span><br><span class=\"line\">         else if (events[i].events &amp; EPOLLIN)</span><br><span class=\"line\">            do_read(epollfd,fd,buf);</span><br><span class=\"line\">         else if (events[i].events &amp; EPOLLOUT)</span><br><span class=\"line\">            do_write(epollfd,fd,buf);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;添加事件</span><br><span class=\"line\">static void add_event(int epollfd,int fd,int state)&#123;</span><br><span class=\"line\">    struct epoll_event ev;</span><br><span class=\"line\">    ev.events &#x3D; state;</span><br><span class=\"line\">    ev.data.fd &#x3D; fd;</span><br><span class=\"line\">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;处理接收到的连接</span><br><span class=\"line\">static void handle_accpet(int epollfd,int listenfd)&#123;</span><br><span class=\"line\">     int clifd;     </span><br><span class=\"line\">     struct sockaddr_in cliaddr;     </span><br><span class=\"line\">     socklen_t  cliaddrlen;     </span><br><span class=\"line\">     clifd &#x3D; accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class=\"line\">     if (clifd &#x3D;&#x3D; -1)         </span><br><span class=\"line\">     perror(&quot;accpet error:&quot;);     </span><br><span class=\"line\">     else &#123;         </span><br><span class=\"line\">         printf(&quot;accept a new client: %s:%d\\n&quot;,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       &#x2F;&#x2F;添加一个客户描述符和事件         </span><br><span class=\"line\">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;读处理</span><br><span class=\"line\">static void do_read(int epollfd,int fd,char *buf)&#123;</span><br><span class=\"line\">    int nread;</span><br><span class=\"line\">    nread &#x3D; read(fd,buf,MAXSIZE);</span><br><span class=\"line\">    if (nread &#x3D;&#x3D; -1)     &#123;         </span><br><span class=\"line\">        perror(&quot;read error:&quot;);         </span><br><span class=\"line\">        close(fd); &#x2F;&#x2F;记住close fd        </span><br><span class=\"line\">        delete_event(epollfd,fd,EPOLLIN); &#x2F;&#x2F;删除监听 </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (nread &#x3D;&#x3D; 0)     &#123;         </span><br><span class=\"line\">        fprintf(stderr,&quot;client close.\\n&quot;);</span><br><span class=\"line\">        close(fd); &#x2F;&#x2F;记住close fd       </span><br><span class=\"line\">        delete_event(epollfd,fd,EPOLLIN); &#x2F;&#x2F;删除监听 </span><br><span class=\"line\">    &#125;     </span><br><span class=\"line\">    else &#123;         </span><br><span class=\"line\">        printf(&quot;read message is : %s&quot;,buf);        </span><br><span class=\"line\">        &#x2F;&#x2F;修改描述符对应的事件，由读改为写         </span><br><span class=\"line\">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;写处理</span><br><span class=\"line\">static void do_write(int epollfd,int fd,char *buf) &#123;     </span><br><span class=\"line\">    int nwrite;     </span><br><span class=\"line\">    nwrite &#x3D; write(fd,buf,strlen(buf));     </span><br><span class=\"line\">    if (nwrite &#x3D;&#x3D; -1)&#123;         </span><br><span class=\"line\">        perror(&quot;write error:&quot;);        </span><br><span class=\"line\">        close(fd);   &#x2F;&#x2F;记住close fd       </span><br><span class=\"line\">        delete_event(epollfd,fd,EPOLLOUT);  &#x2F;&#x2F;删除监听    </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    memset(buf,0,MAXSIZE); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;删除事件</span><br><span class=\"line\">static void delete_event(int epollfd,int fd,int state) &#123;</span><br><span class=\"line\">    struct epoll_event ev;</span><br><span class=\"line\">    ev.events &#x3D; state;</span><br><span class=\"line\">    ev.data.fd &#x3D; fd;</span><br><span class=\"line\">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;修改事件</span><br><span class=\"line\">static void modify_event(int epollfd,int fd,int state)&#123;     </span><br><span class=\"line\">    struct epoll_event ev;</span><br><span class=\"line\">    ev.events &#x3D; state;</span><br><span class=\"line\">    ev.data.fd &#x3D; fd;</span><br><span class=\"line\">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;注：另外一端我就省了</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"epoll总结\"><a href=\"#epoll总结\" class=\"headerlink\" title=\"epoll总结\"></a>epoll总结</h5><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p>\n<p><strong>epoll的优点主要是一下几个方面：</strong><br>\\1. 监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>\n<ol>\n<li> IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>\n</ol>\n<blockquote>\n<p>  如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p>\n</blockquote>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139551R-C.33d57d1aac13ec6a4e7f917e0a47bb69?rik=o/uWsKRpOPc7MA&riu=http://www.thomas-krenn.com/de/wikiDE/images/d/da/Linux-io-stack-diagram_v1.0.png&ehk=1OGRYIpfyG0jiVPRMEKwfpXnNXxZpCQUOMRDg4u7Pz0=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/Anker/p/3269106.html\">用户空间与内核空间，进程上下文与中断上下文总结]</a><br><a href=\"http://guojing.me/linux-kernel-architecture/posts/process-switch/\">进程切换</a><br><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">维基百科-文件描述符</a><br><a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-directio/\">Linux 中直接 I/O 机制的介绍</a><br><a href=\"http://blog.csdn.net/historyasamirror/article/details/5778378\">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a><br><a href=\"http://www.cnblogs.com/bigwangdi/p/3182958.html\">Linux中select poll和epoll的区别</a><br><a href=\"http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html\">IO多路复用之select总结</a><br><a href=\"http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html\">IO多路复用之poll总结</a><br><a href=\"http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html\">IO多路复用之epoll总结</a></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"代码整洁之道","slug":"self/cleancode","date":"2021-03-23T15:24:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/self/cleancode.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138678command.jpg","content":"<h2 id=\"必要性\"><a href=\"#必要性\" class=\"headerlink\" title=\"必要性\"></a>必要性</h2><ol>\n<li> 要有代码，大胆写，<em>Imperfect</em> code is <em>Better Than</em> Perfect </li>\n<li> 现在就做，later equals never，Now is better than never</li>\n<li> 从开始就不要为了一时便利去破坏代码整洁</li>\n<li> 坚持同一规范</li>\n<li> 隔离与性能的权衡</li>\n</ol>\n<h2 id=\"什么是代码整洁\"><a href=\"#什么是代码整洁\" class=\"headerlink\" title=\"什么是代码整洁\"></a>什么是代码整洁</h2><p>应当有单元测试以及验收测试，使用有意义的命名，只提供一种做某一件事的途径（而非多种），尽量少的依赖关系，清晰并且尽量少的API</p>\n<ol>\n<li> 能通过所有测试</li>\n<li> 没有重复代码</li>\n<li> 体现系统全部设计理念</li>\n<li> 包括尽量少的实体，例如，类、方法、函数等</li>\n<li> 让读的过程轻松，即便会让写的过程更难</li>\n<li> 让营地比你来的时候 更干净</li>\n</ol>\n<h3 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h3><ol>\n<li> 名副其实</li>\n<li> 避免歧义，O I等，避免废话</li>\n<li> 使用可搜索的名称</li>\n<li> 类名不应当是动词</li>\n<li> 方法名应当是动词或动词短语</li>\n<li> 宁可明确，毋为好玩（生活和思想需要务虚，但code要务实）</li>\n<li> 避免双关语，一词一意</li>\n<li> 每个概念一个单词，一意一词</li>\n<li> 使用算法名、计算机术语、模式名、数学术语命名</li>\n<li> 使用所在领域命名</li>\n<li> 函数就该小</li>\n<li> 函数式编程，尽量少用副作用编程</li>\n<li> 做好隔离（抽象、封装、逻辑与业务隔离，实现与使用隔离）</li>\n<li> 函数应该做好一件事，只做一件事</li>\n<li> 函数参数越少越好，最好没有</li>\n<li> 抽离try catch代码块</li>\n<li> 相关联的函数应该放在一起，调用者尽可能放在被调用者上面</li>\n<li>tdd 规则<ol>\n<li> 在能产生不能通过的单元测试之前，不可编写生成代码</li>\n<li> 只允许编写刚好无法通过的代码</li>\n<li> 只可编写刚好足以通过当前失败测试的生成代码</li>\n</ol>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程思想","path":"api/tags/编程思想.json"},{"name":"编程哲学","path":"api/tags/编程哲学.json"}]},{"title":"trex测试流程","slug":"tools/trex","date":"2021-03-22T15:24:21.000Z","updated":"2024-06-30T10:35:56.312Z","comments":true,"path":"api/articles/tools/trex.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211026/1635177828R-C.d34f9c2395acdb73efab09b9a7eb54c8?rik=ySFewf9hg74oTQ&riu=http%3a%2f%2fwww.jianbihua.net%2fuploads%2fallimg%2f190926%2f1S1064S8_0.jpg&ehk=H2DKfkxH1czTQubUYuvnzsiMtIpOApDO%2fpIcY%2f7AVtI%3d&risl=&pid=ImgRaw&r=0","content":"<h2 id=\"Trex简单测试\"><a href=\"#Trex简单测试\" class=\"headerlink\" title=\"Trex简单测试\"></a>Trex简单测试</h2><h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li><p>trex主机与dut主机第一个network为管理网，第二个与第三个network为测试用网，trex主机与dut主机测试用网eth1互联，trex主机与dut主机测试用网eth2互联;</p>\n</li>\n<li><p>只可运行net_set.sh 一次，获得mac地址，若mac地址全为0，重启trex主机;</p>\n</li>\n<li><p>测试项可在run_trex.sh修改（-m 参数为几万pps  -d参数为测试时间）。</p>\n</li>\n</ol>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ol>\n<li>打开trex主机 运行trex_set.sh 并得到两个mac地址fa:ad:96:2e:3c:01 fa:0b:32:14:a9:02；</li>\n<li>打开dut主机运行 dut_set.sh fa:ad:96:2e:3c:01 fa:0b:32:14:a9:02；</li>\n<li>打开trex主机运行run_trex.sh ，等待运行结束得到trex结果。</li>\n</ol>\n<h3 id=\"镜像地址\"><a href=\"#镜像地址\" class=\"headerlink\" title=\"镜像地址\"></a>镜像地址</h3><p>dut：<a href=\"http://192.168.200.100/mirror/longtao.wu/image_store/linux_image/wlt-simpletrextest-dut.qcow2\">http://192.168.200.100/mirror/longtao.wu/image_store/linux_image/wlt-simpletrextest-dut.qcow2</a></p>\n<p>trex：<a href=\"http://192.168.200.100/mirror/longtao.wu/image_store/linux_image/wlt-simpletrextest-trex.qcow2\">http://192.168.200.100/mirror/longtao.wu/image_store/linux_image/wlt-simpletrextest-trex.qcow2</a></p>\n<h2 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h2><p>dut_set.sh</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip link set dev eth1 up</span><br><span class=\"line\">ip link set dev eth2 up</span><br><span class=\"line\">ip a add 192.168.155.3/24 dev eth1</span><br><span class=\"line\">ip a add 192.168.166.5/24 dev eth2</span><br><span class=\"line\">ip r add 16.0.0.0/8 via 192.168.155.2</span><br><span class=\"line\">ip r add 48.0.0.0/8 via 192.168.166.4</span><br><span class=\"line\">ip n add 192.168.155.2 dev eth1 lladdr $0</span><br><span class=\"line\">ip n add 192.168.166.4 dev eth2 lladdr $1</span><br><span class=\"line\">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>\n\n<p>net_set.sh</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=(`ip a | grep ^[1-9] | awk -F: &#x27;&#123;print $2&#125;&#x27; | sed &#x27;1,2d&#x27;`)</span><br><span class=\"line\">for ((i=0;i&lt;2;i++))</span><br><span class=\"line\">  do</span><br><span class=\"line\">    b[$i]=`ethtool -i $&#123;a[$i]&#125; |grep bus | awk -F &#x27;:&#x27; &#x27;&#123;print $3 $4 $5&#125;&#x27;|sed -e &#x27;s/../\\0:/&#x27;`</span><br><span class=\"line\">  done</span><br><span class=\"line\">for ((i=0;i&lt;2;i++))</span><br><span class=\"line\">  do</span><br><span class=\"line\">    echo $&#123;a[$i]&#125; $&#123;b[$i]&#125;</span><br><span class=\"line\">  done</span><br><span class=\"line\">for ((i=0;i&lt;2;i++))</span><br><span class=\"line\">  do</span><br><span class=\"line\">    e[$i]=`ip link show $&#123;a[$i]&#125; |head -2|tail -1|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class=\"line\">  done</span><br><span class=\"line\">cp /root/trex/v2.81/cfg/simple_cfg.yaml  /etc/trex_cfg.yaml.bak</span><br><span class=\"line\">sed &#x27;4,$d&#x27; /etc/trex_cfg.yaml.bak &gt;/etc/trex_cfg.yaml</span><br><span class=\"line\">echo -e &#x27;  interfaces    : [&quot;&#x27;$&#123;b[0]&#125;&#x27;&quot;,&quot;&#x27;$&#123;b[1]&#125;&#x27;&quot;]&#x27;&gt;&gt;/etc/trex_cfg.yaml</span><br><span class=\"line\">echo -e &#x27;  port_info       :  # Port IPs. Change to suit your needs. In case of loopback, you can leave as is.&#x27;&gt;&gt;/etc/trex_cfg.yaml</span><br><span class=\"line\">echo -e &#x27;          - ip         : 192.168.155.2&#x27;&gt;&gt;/etc/trex_cfg.yaml</span><br><span class=\"line\">echo -e &#x27;            default_gw : 192.168.155.3&#x27;&gt;&gt;/etc/trex_cfg.yaml</span><br><span class=\"line\">echo -e &#x27;          - ip         : 192.168.166.4&#x27;&gt;&gt;/etc/trex_cfg.yaml</span><br><span class=\"line\">echo -e &#x27;            default_gw : 192.168.166.5&#x27;&gt;&gt;/etc/trex_cfg.yaml</span><br><span class=\"line\">echo -e &#x27;\\n\\n&#x27;&gt;&gt;/etc/trex_cfg.yaml</span><br><span class=\"line\">cd ~/trex/v2.81/</span><br><span class=\"line\">./dpdk_setup_ports.py</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /etc/trex_cfg.yaml</span></span><br><span class=\"line\">cat /root/trex/v2.81/cfg/simple_cfg.yaml</span><br><span class=\"line\">cat /etc/trex_cfg.yaml</span><br><span class=\"line\">echo &#x27;config success ! dont config again!  if not configed please reboot your mechine and check your network  sum is 2 and the last 2 network are connected.&#x27;</span><br><span class=\"line\">echo -e &#x27;\\n&#x27;</span><br><span class=\"line\">echo $&#123;e[0]&#125;&#x27; &#x27;$&#123;e[1]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>run_trex.sh</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /root/trex/v2.81; ./t-rex-64 -f cap2/imix_longtao_1w.yaml -m 5 -d 5</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"应用","path":"api/tags/应用.json"}]},{"title":"vdbench的使用","slug":"tools/vdbench","date":"2021-03-16T15:21:21.000Z","updated":"2024-06-30T10:35:56.312Z","comments":true,"path":"api/articles/tools/vdbench.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211026/16351778984ff67260bec777fbef81d387df6f7416.jpeg","content":"<p>ssh免密配置</p>\n<p>参考：<a href=\"https://blog.csdn.net/SweeNeil/article/details/95338293\">https://blog.csdn.net/SweeNeil/article/details/95338293</a></p>\n<ol>\n<li> 使用Vdbench测试工具对所有虚拟机磁盘进行压力测试，vdbench测试工具脚本主机定义设置如下：</li>\n</ol>\n<p>hd=default,vdbench=/home/vdbench,user=root,shell=ssh</p>\n<p>hd=hd1,system=node1</p>\n<p>hd=hd2,system=node2</p>\n<p>hd=hd3,system=node3</p>\n<p>……</p>\n<ol>\n<li> 设置测试工具模型为8k块大小随机读，测试数据量为块存储总SSD缓存大小的1倍。在压力虚拟机上运行Vdbench测试工具。存储定义、工作负载定义、运行定义设置如下：</li>\n</ol>\n<p>sd=sd1,hd=hd1,lun=/dev/sdb,openflags=o_direct,hitarea=1G,threads=1（厂家自行调整）</p>\n<p>……</p>\n<p>wd=wd1,sd=sd*,seekpct=100,rdpct=100,rhpct=60,xfersize=8k </p>\n<p>rd=rd1,wd=wd1,iorate=max,elapsed=604800,maxdata=数据量,interval=5,warmup=30</p>\n<ol>\n<li> 记录平均读写IOPS</li>\n</ol>\n<p>master</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\">ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub root@172.18.2.197</span><br><span class=\"line\">ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub root@172.18.2.196</span><br><span class=\"line\">ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub root@172.18.2.185</span><br><span class=\"line\">ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub root@172.18.2.173</span><br><span class=\"line\">ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub root@172.18.2.171</span><br><span class=\"line\">ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub root@172.18.2.165</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hd&#x3D;default,vdbench&#x3D;&#x2F;home&#x2F;vdbench,user&#x3D;root,shell&#x3D;ssh</span><br><span class=\"line\">hd&#x3D;hd1,system&#x3D;172.18.2.197</span><br><span class=\"line\">hd&#x3D;hd2,system&#x3D;172.18.2.196</span><br><span class=\"line\">hd&#x3D;hd3,system&#x3D;172.18.2.185</span><br><span class=\"line\">hd&#x3D;hd4,system&#x3D;172.18.2.173</span><br><span class=\"line\">hd&#x3D;hd5,system&#x3D;172.18.2.171</span><br><span class=\"line\">hd&#x3D;hd6,system&#x3D;172.18.2.165</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sd&#x3D;sd1,hd&#x3D;hd1,lun&#x3D;&#x2F;dev&#x2F;sda,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd2,hd&#x3D;hd1,lun&#x3D;&#x2F;dev&#x2F;sdb,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd3,hd&#x3D;hd2,lun&#x3D;&#x2F;dev&#x2F;sda,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd4,hd&#x3D;hd2,lun&#x3D;&#x2F;dev&#x2F;sdb,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd5,hd&#x3D;hd3,lun&#x3D;&#x2F;dev&#x2F;sda,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd6,hd&#x3D;hd3,lun&#x3D;&#x2F;dev&#x2F;sdb,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd7,hd&#x3D;hd4,lun&#x3D;&#x2F;dev&#x2F;sda,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd8,hd&#x3D;hd4,lun&#x3D;&#x2F;dev&#x2F;sdb,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd9,hd&#x3D;hd5,lun&#x3D;&#x2F;dev&#x2F;sdb,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd10,hd&#x3D;h5,lun&#x3D;&#x2F;dev&#x2F;sda,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd11,hd&#x3D;hd6,lun&#x3D;&#x2F;dev&#x2F;sdb,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\">sd&#x3D;sd12,hd&#x3D;hd6,lun&#x3D;&#x2F;dev&#x2F;sda,openflags&#x3D;o_direct,hitarea&#x3D;1G,threads&#x3D;1</span><br><span class=\"line\"></span><br><span class=\"line\">wd&#x3D;wd1,sd&#x3D;sd*,seekpct&#x3D;100,rdpct&#x3D;0,rhpct&#x3D;60,xfersize&#x3D;8k</span><br><span class=\"line\"></span><br><span class=\"line\">rd&#x3D;rd1,wd&#x3D;wd1,iorate&#x3D;max,elapsed&#x3D;604800,maxdata&#x3D;150G,interval&#x3D;5,warmup&#x3D;30</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]},{"title":"使用qemu-imag打包iso","slug":"tools/qemu-img","date":"2021-02-22T15:10:21.000Z","updated":"2024-06-30T10:35:56.312Z","comments":true,"path":"api/articles/tools/qemu-img.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635177277R-C.017f4d23913d88e0026e0d0ffe1cab9b?rik=FsE6SpMRqvcnqQ&riu=http%3a%2f%2finews.gtimg.com%2fnewsapp_match%2f0%2f4764532864%2f0.jpg&ehk=biDiFq655BeTM1sXCzD%2bZEZuzr41ysdxXrvKKr68LLE%3d&risl=&pid=ImgRaw&r=0","content":"<h3 id=\"使用qemu-image-压缩qcow2镜像\"><a href=\"#使用qemu-image-压缩qcow2镜像\" class=\"headerlink\" title=\"使用qemu-image 压缩qcow2镜像\"></a>使用qemu-image 压缩qcow2镜像</h3><p>qemu-img convert -c -O qcow2 raw.qcow2 outZipped.qcow2</p>\n<p>raw.qcow2是原始镜像</p>\n<p>outZipped.qcow2是压缩后的目标镜像</p>\n<h3 id=\"转换并压缩\"><a href=\"#转换并压缩\" class=\"headerlink\" title=\"转换并压缩\"></a>转换并压缩</h3><p>qemu-img convert -f raw -O qcow2</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"应用","path":"api/tags/应用.json"}]},{"title":"swingbench介绍","slug":"tools/swingbench","date":"2021-02-12T15:20:21.000Z","updated":"2024-06-30T10:35:56.312Z","comments":true,"path":"api/articles/tools/swingbench.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635177524m0k5joh3q8it2uq0ftnle6hlg8c94gcbj12on46vg99vrlv98juah9rmfgem3q3.1200-0-90.jpg","content":"<p>Swingbench is a free load generator (and benchmarks) designed to stress test an Oracle database (10g,11g,12c).</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><ul>\n<li>Swingbench组件：<br>  Swingbench是一个图形界面，用户可以编辑配置参数。可以显示实时的图形。<br>  Minibench是一个图形界面，可以显示简单的实时图形。<br>  Charbench是一个命令行的工具，有很多的命令行选项。</li>\n<li>  四种基准测试</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Benchmark</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">读写比例</th>\n<th align=\"left\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Order Entry</td>\n<td align=\"left\">经典的Order Entry基准测试。像TPC。</td>\n<td align=\"left\">60/40</td>\n<td align=\"left\">TPC-C类似的，基于Oracle自带的两个Sample Schema：OE和SH</td>\n</tr>\n<tr>\n<td align=\"left\">Calling Circle</td>\n<td align=\"left\">电话公司自助系统</td>\n<td align=\"left\">70/30</td>\n<td align=\"left\">基于电话自助服务系统的基准测试，大小相对固定，每次运行都需要重新生成schema</td>\n</tr>\n<tr>\n<td align=\"left\">Stess Test</td>\n<td align=\"left\">简单的INSERT/DELETE/UPDATE/SELECT</td>\n<td align=\"left\">50/50</td>\n<td align=\"left\">Stress Test是最简单的测试，执行insert/update/delete/select的操作，数据是在运行时产生，可以用于测试TimesTen</td>\n</tr>\n<tr>\n<td align=\"left\">Sales History</td>\n<td align=\"left\">DSS基准测试</td>\n<td align=\"left\">100/0</td>\n<td align=\"left\">数据仓库基准测试，使用datagenerator产生数据，由disk和时间来决定最大的大小，基于Oracle自带的两个Sample Schema：OE和SH</td>\n</tr>\n</tbody></table>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><ul>\n<li>  Linux</li>\n<li>  Oracle Database 11</li>\n</ul>\n<h1 id=\"架构示意图\"><a href=\"#架构示意图\" class=\"headerlink\" title=\"架构示意图\"></a>架构示意图</h1><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/22/89110108255106186165209123221526149212127123_6500656c-5aef-11eb-9fab-fa1e86d74c00.png\" alt=\"img\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/22/505624220682411041642202111351681361168348_665819b4-5aef-11eb-9549-fa1e86d74c00.png\" alt=\"img\"></p>\n<h1 id=\"安装和设置\"><a href=\"#安装和设置\" class=\"headerlink\" title=\"安装和设置\"></a>安装和设置</h1><ul>\n<li><p>下载<br>  目前作者已经发布了最新的2.5版本，本次使用2.5。从dominicgiles.com下载，地址：<a href=\"http://dominicgiles.com/downloads.html%E3%80%82\">http://dominicgiles.com/downloads.html。</a></p>\n</li>\n<li><p>验证Java版本<br>  2.4和2.5版本需要使用Java 6/7 JVM。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#</span><br><span class=\"line\">yum install -y java-1.7.0-openjdk.x86_64</span><br><span class=\"line\">$</span><br><span class=\"line\">java -version</span><br><span class=\"line\">java version &quot;1.7.0_65&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>安装</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$</span><br><span class=\"line\">pwd &#x2F;home&#x2F;oracle</span><br><span class=\"line\">unzip swingbench25932.zip</span><br><span class=\"line\">&lt;略&gt;</span><br><span class=\"line\">cd swingbench</span><br><span class=\"line\">pwd</span><br><span class=\"line\">&#x2F;home&#x2F;oracle&#x2F;swingbench</span><br></pre></td></tr></table></figure></li>\n<li><p>用户设置<br>  Unix/Linux平台配置文件为swingbench.env，执行文件路径为bin；Windows下则为swingbenchenv.bat和winbin。在windows平台上注意一定要配置ORACLE_HOME，好像不认注册表。<br>  Linux平台下，swingbench是在Oracle用户下执行，请确保它被设置在环境变量以下。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$</span><br><span class=\"line\">export ORACLE_BASE&#x3D;&#x2F;u01&#x2F;app&#x2F;oracle</span><br><span class=\"line\">export ORACLE_HOME&#x3D;$ORACLE_BASE&#x2F;product&#x2F;11.2.0&#x2F;dbhome_1</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><ul>\n<li><p>配置OE仓库</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$</span><br><span class=\"line\">cd bin</span><br><span class=\"line\">.&#x2F;oewizard</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>1.按在欢迎屏幕[下一页]</p>\n<p>2.选择Benchmark版本，此处选择版本2.0，然后按[下一页]</p>\n<p>3.选择任务，选择“Create the Order Entry Schema（User,Tables,indexes,Data etc）”，然后按[下一页]</p>\n<p>4.在数据库的详细信息界面，输入必要的信息，然后按[下一页]</p>\n<p>5.在Schema Details界面输入所需信息，然后按[下一页]</p>\n<p>6.在Database Options输入所需的信息，然后按[下一页]<br>可默认</p>\n<p>7.大小细节，建议进入用户自定义，可以使用1GB按[下一步]。</p>\n<p>8.最后，指定并行度，然后按[完成]</p>\n<p>9.日志在一个单独的窗口中打开。</p>\n<p>10.打开完成后的模式创建完成界面。并按[确定]退出。</p>\n<ul>\n<li><p>测试</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$</span><br><span class=\"line\">cd &#x2F;home&#x2F;oracle&#x2F;swingbench&#x2F;bin</span><br><span class=\"line\">.&#x2F;swingbench -cs &#x2F;&#x2F;oracledb01&#x2F;orcl112 -dt thin  -rt 0:05</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"测试中遇到的问题和解决方法\"><a href=\"#测试中遇到的问题和解决方法\" class=\"headerlink\" title=\"测试中遇到的问题和解决方法\"></a>测试中遇到的问题和解决方法</h1><ol>\n<li><p>生成AWR<br> 在测试开始时可以生成awr快照，但是结束时没有自动生成awr快照。可以运行下列<br> 语句手工生成：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQL&gt;</span><br><span class=\"line\">exec DBMS_WORKLOAD_REPOSITORY.CREATE_SNAPSHOT ;</span><br></pre></td></tr></table></figure></li>\n<li><p>遇到等待事件<br> resmgr:cpu quantum<br> 根据metalink的note禁止资源管理</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQL&gt;</span><br><span class=\"line\">alter system set resource_manager_plan&#x3D;&#39;&#39; scope&#x3D;both;</span><br></pre></td></tr></table></figure></li>\n<li><p>运行swingbench, 没有显示cpu和disk的实时图形<br> ./swingbench -cpuloc localhost 带选项-cpuloc，如果是2.4版本，可以指定hostname和用户密码</p>\n</li>\n<li><p>遇到ora-03111错误<br> 查了metalink的note可以通过调节sdu来解决，不过有时还是会出现。<br> (SDU = 16384)<br> (TDU = 16384)</p>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]}]}