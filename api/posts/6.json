{"total":78,"pageSize":10,"pageCount":8,"data":[{"title":"内置库os","slug":"language/python/os","date":"2020-06-20T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/python/os.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138518python3-print-function.png","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listdir(path: AnyStr) -&gt; List[AnyStr] #列出目录下所有文件和文件夹</span><br></pre></td></tr></table></figure>\n\n<p>os.sep与os.path.sep</p>\n<p>根据系统返回分隔符，os.path对于文件路径更健壮</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"python","path":"api/tags/python.json"}]},{"title":"vlan和vxlan","slug":"systemstructure/network/vlanandvxlan","date":"2020-06-17T12:24:54.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/vlanandvxlan.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171476vlan-t.jpg","content":"<h1 id=\"vlan\"><a href=\"#vlan\" class=\"headerlink\" title=\"vlan\"></a>vlan</h1><p>VLAN(Virtual LAN)，翻译成中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。</p>\n<p>vlan被创建后，应将交换机端口分配给vlan，以此使得接入该端口的电脑属于该vlan，需要使用该vlan所属的网络IP。</p>\n<p> 广播风暴防范<br>限制网络上bai的广播，将网络划分为多个VLAN可减少参与广播风暴的设备数量。LAN分段可以防止广播风暴波及整个网络。VLAN可以提供建立防火墙的机制，防止交换网络的过量广播。使用VLAN，可以将某个交换端口或用户赋于某一个特定的VLAN组，该VLAN组可以在一个交换网中或跨接多个交换机，在一个VLAN中的广播不会送到VLAN之外。同样，相邻的端口不会收到其他VLAN产生的广 播。这样可以减少广播流量，释放带宽给用户应用，减少广播的产生。<br>2. 安全<br>　　增强局域网的安全性，含有敏感数据的用户组可与网络的其余部分隔离，从而降低泄露机密信息的可能性。不同VLAN内的报文在传输时是相互隔离的，即一个VLAN内的用户不能和其它VLAN内的用户直接通信，如果不同VLAN要进行通信，则需要通过路由器或三层交换机等三层设备。<br>　　　　　　　　3.成本降低<br>　　　　　　　　　　成本高昂的网络升级需求减少，现有带宽和上行链路的利用率更高，因此可节约成本。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"proc目录解析","slug":"systemstructure/linux/proc","date":"2020-05-23T13:23:23.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/proc.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351398132021100110022315.jpg","content":"<p>在linux中，proc是一个伪文件系统，提供了访问内核数据的一些方法</p>\n<p>proc中PID目录存有进程的一些信息</p>\n<h2 id=\"pid目录ls\"><a href=\"#pid目录ls\" class=\"headerlink\" title=\"pid目录ls\"></a>pid目录ls</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">root@longtaoXiaoXinPro13-2020#</span><span class=\"bash\"> ls /proc/1</span></span><br><span class=\"line\">arch_status         cwd        mem            patch_state   stat</span><br><span class=\"line\">attr                environ    mountinfo      personality   statm</span><br><span class=\"line\">autogroup           exe        mounts         projid_map    status</span><br><span class=\"line\">auxv                fd         mountstats     root          syscall</span><br><span class=\"line\">cgroup              fdinfo     net            sched         task</span><br><span class=\"line\">clear_refs          gid_map    ns             schedstat     timens_offsets</span><br><span class=\"line\">cmdline             io         numa_maps      sessionid     timers</span><br><span class=\"line\">comm                limits     oom_adj        setgroups     timerslack_ns</span><br><span class=\"line\">coredump_filter     loginuid   oom_score      smaps         uid_map</span><br><span class=\"line\">cpu_resctrl_groups  map_files  oom_score_adj  smaps_rollup  wchan</span><br><span class=\"line\">cpuset              maps       pagemap        stack</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"attr\"><a href=\"#attr\" class=\"headerlink\" title=\"attr\"></a>attr</h4><p>目录， 可读可写，安全相关的一些属性，用来支持安全模块，如SELinux等</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /proc/1/attr</span></span><br><span class=\"line\"><span class=\"meta\">apparmor#</span></span><br><span class=\"line\"><span class=\"bash\">current<span class=\"comment\">#当前安全属性</span></span></span><br><span class=\"line\"><span class=\"meta\">exec#</span><span class=\"bash\">执行execve时设置的安全属性</span></span><br><span class=\"line\"><span class=\"meta\">keycreate#</span><span class=\"bash\"> add_key时设置属性</span>  </span><br><span class=\"line\"><span class=\"meta\">smack#</span></span><br><span class=\"line\"><span class=\"bash\">context<span class=\"comment\">#</span></span>   </span><br><span class=\"line\"><span class=\"meta\">display#</span><span class=\"bash\"> </span></span><br><span class=\"line\"><span class=\"meta\">fscreate#</span><span class=\"bash\"> </span> </span><br><span class=\"line\"><span class=\"meta\">prev#</span><span class=\"bash\"> </span> </span><br><span class=\"line\"><span class=\"meta\">sockcreate#</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4>","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"VirtioSCSI和virtioBLK","slug":"systemstructure/linux/virtioscsiandvirtioblk","date":"2020-05-22T13:10:51.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/virtioscsiandvirtioblk.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635140092virtio-gpio-1.png","content":"<p><strong>qemu对设备的模拟可以分成两类：全模拟和半模拟。全模拟即完全模拟物理设备的工作过程，使得运行在虚拟机上的软件完全感知不到自身运行环境的差异</strong>。例如qemu中实现了对IDE磁盘、LSI控制器(其上可接SCSI磁盘)等物理存储设备的模拟，原先运行在物理机上的IDE驱动、LSI驱动或应用程序不做任何改动即可运行在虚拟机中。因此，<strong>全模拟的优点比较明显，即不用提供专门针对虚拟化场景的设备驱动，完全可以复用物理环境下的驱动程序。那么全模拟有何缺点呢？全模拟时，虚拟机内部驱动会频繁访问虚拟机IO端口，KVM平台下会导致大量的陷入和陷出操作；另外虚拟机内外数据传输时只能通过以字节为单位的拷贝方式进行，无法直接采用共享内存的方式，因此存在较大的访问性能问题</strong>。</p>\n<p>为解决全虚拟化在性能上的问题，半模拟技术应运而生。它构造了一种虚拟化环境所独有的存储设备，因此<strong>半虚拟化需要在虚拟机内部安装特定的驱动程序才能正常驱使该设备进行工作。通常我们称**虚拟机内部的驱动为前端驱动**，称**负责实现其功能模拟的程序(KVM平台下即为qemu程序)为后端程序*<strong>*，**半模拟技术也常常被叫做前后端技术</strong>。**采用半摸拟技术后，配合前端驱动，虚拟化设备完全可以采用全新的事件通知和数据传递机制进而大幅提升性能， 例如在virtio-blk磁盘中，采用io_event_fd进行前端到后端通知，采用中断注入方式实现后端到前端的通知，并通过IO环(vring)进行数据的共享</strong>。至此，主要说明了virtio-blk产生的背景及其价值。附上qemu所模拟的PC(基于intel i440fx主板架构)的组成结构图，以作为后续深入分析的基础。</p>\n<p>virtio-scsi和virtio-blk都是磁盘的半虚拟化驱动，virtio-scsi解决了virtio-blk的一些限制。</p>\n<p>virtio scsi hba取代virtio blk，这是一种简单的高性能准虚拟化存储设备。然而，<strong>virtio blk的设计固有的局限性如下</strong>：</p>\n<ul>\n<li>•virtio blk的范围有限，这使得新的命令实现变得复杂。每次开发一个新命令时，virtio blk驱动程序都必须在每个客户机中更新。</li>\n<li>•<strong>virtio blk将PCI功能和存储设备映射为1:1，限制了可扩展性</strong>。</li>\n<li>•<strong>virtio blk不是真正的SCSI设备。这会导致一些应用程序在从物理机移动到虚拟机时中断。</strong></li>\n</ul>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"中断","slug":"systemstructure/linux/iterruptrequest","date":"2020-05-05T12:28:43.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/iterruptrequest.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139455kernel_interface.png","content":"<h2 id=\"中断是什么\"><a href=\"#中断是什么\" class=\"headerlink\" title=\"中断是什么\"></a>中断是什么</h2><p>中断是操作系统、CPU、CPU与IO设备中的概念，为中断CPU执行。其中涉及的概念都有无限深的概念栈(其实是无限深)我们就从简单的系统层面讲一讲。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139455kernel_interface.png\" alt=\"See the source image\"></p>\n<h2 id=\"前置概念\"><a href=\"#前置概念\" class=\"headerlink\" title=\"前置概念\"></a>前置概念</h2><p>IRQ：interrupt request,中断请求</p>\n<p>ISR：interrupt service routine， 中断服务程序，中断后运行的服务，ISR运行结束才会结束中断</p>\n<p>PIC：programmable interrupt contolle,可编程中断控制器（中断控制芯片），与I/O设备直连，可以触发CPU的INTR(中断请求)引脚，发起中断请求</p>\n<p>APIC：advanced programmable interrupt contolle,高级编程中断控制器，有两部分，Local APIC 在CPU内部(每个核都有)，I/O APIC在主板芯片组内，I/O APIC和LAPIC通过总线连接</p>\n<h2 id=\"硬中断\"><a href=\"#硬中断\" class=\"headerlink\" title=\"硬中断\"></a>硬中断</h2><p>硬件设备通知CPU就绪中使用，分为：</p>\n<h3 id=\"可屏蔽中断\"><a href=\"#可屏蔽中断\" class=\"headerlink\" title=\"可屏蔽中断\"></a>可屏蔽中断</h3><p>外设或借口的中断、可以在CPU处理其他紧急操作时忽略或屏蔽</p>\n<h3 id=\"不可屏蔽中断\"><a href=\"#不可屏蔽中断\" class=\"headerlink\" title=\"不可屏蔽中断\"></a>不可屏蔽中断</h3><p>电源断电、内存错误等，不可通过软件屏蔽，必须响应中断</p>\n<h2 id=\"软中断\"><a href=\"#软中断\" class=\"headerlink\" title=\"软中断\"></a>软中断</h2><p>软件触发的中断，如定时器、网卡收发包</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>一般为程序调用CPU的指令错误时产生，console能看到 segmention fault、core dumped等</p>\n<p>错误：系统可纠正、纠正成功继续运行(如内存页从磁盘加载)</p>\n<p>陷阱：陷阱主要用在调试中。</p>\n<p>终止：终止是由系统表中的硬件错误或值不一致而导致的。终止不会报告造成异常的指令的所在位置。这是最严重的中断，终止将会调用系统的终止异常处理程序来结束造成异常的进程。</p>\n<h2 id=\"top命令解析\"><a href=\"#top命令解析\" class=\"headerlink\" title=\"top命令解析\"></a>top命令解析</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 10:40:48 up  1:04,  1 user,  load average: 2.39, 2.22, 2.07</span><br><span class=\"line\">任务: 400 total,   2 running, 397 sleeping,   0 stopped,   1 zombie</span><br><span class=\"line\">%Cpu(s):  5.2 us,  3.4 sy,  0.0 ni, 90.5 id,  0.1 wa,  0.0 hi,  0.8 si,  0.0 st</span><br><span class=\"line\">MiB Mem :  15430.3 total,   3579.7 free,   8020.7 used,   3829.9 buff/cache</span><br><span class=\"line\">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   6880.5 avail Mem </span><br><span class=\"line\">ID USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND  </span><br><span class=\"line\">4389 longtao   20   0 6273452 451044 148220 S  37.7   2.9  27:28.46 gnome-shell           </span><br></pre></td></tr></table></figure>\n\n<p>第一行分别为：系统时间、系统已运行时间(1h4min)、用户数、平均CPU负载情况(1分钟、5分钟、15分钟)</p>\n<p>第二行分别为：当前总任务(进程)数量、运行中的2个、休眠397个、stoped0个，zombie0个</p>\n<p>第三为cpu的状态使用情况</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>5.2 us</td>\n<td>用户空间占用CPU%5.2</td>\n</tr>\n<tr>\n<td>3.4 sy</td>\n<td>内核空间占用CPU%3.4</td>\n</tr>\n<tr>\n<td>0.0 ni</td>\n<td>更改过优先级的进程占用CPU%0</td>\n</tr>\n<tr>\n<td>90.5 id</td>\n<td>90.5%的CPU空闲</td>\n</tr>\n<tr>\n<td>0.1 wa</td>\n<td>IO等待占用CPU百分比</td>\n</tr>\n<tr>\n<td>0.8 si</td>\n<td>软中断占用CPU%0.8</td>\n</tr>\n<tr>\n<td>0.0 hi</td>\n<td>硬中断占用</td>\n</tr>\n<tr>\n<td>0.0 st</td>\n<td>steal time,对云主机来说被Hypervisor偷去的CPU所占比例</td>\n</tr>\n</tbody></table>\n<p>第四行为内存状态分别为：物理总内存total、used使用了的、free空闲的、缓存内存</p>\n<p>第五行为swap交换分区状态：total交换分区总量、空闲、使用了的、缓冲的</p>\n<p>第六行往下都是每个进程使用情况：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>进程号</td>\n</tr>\n<tr>\n<td>USER</td>\n<td>用户</td>\n</tr>\n<tr>\n<td>PR</td>\n<td>进程优先级</td>\n</tr>\n<tr>\n<td>NI</td>\n<td>nice值，正表示低优先值、负表示高</td>\n</tr>\n<tr>\n<td>VIRT</td>\n<td>进程使用虚拟内存总量，VIRT=SWAP+RES</td>\n</tr>\n<tr>\n<td>RES</td>\n<td>进程使用的、未释放的物理内存，RES=CODE+DATA</td>\n</tr>\n<tr>\n<td>SHR</td>\n<td>共享内存</td>\n</tr>\n<tr>\n<td>S</td>\n<td>进程状态，D不可中断的睡眠状态 R运行 S睡眠 T跟踪/停止 Z僵尸进程</td>\n</tr>\n<tr>\n<td>%CPU</td>\n<td>CPU占比(对单个CPU的)</td>\n</tr>\n<tr>\n<td>%MEM</td>\n<td>物理内存占比</td>\n</tr>\n<tr>\n<td>TIME+</td>\n<td>进程使用的CPU时间总计，单位为us</td>\n</tr>\n<tr>\n<td>COMMAND</td>\n<td>进程名称和命令</td>\n</tr>\n</tbody></table>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>数字1：查看每个cpu的情况</p>\n<p>数字2：查看每个numa的情况</p>\n<p>数字3：查看某个numa里每个CPU的情况</p>\n<p>字母P：CPU使用排序</p>\n<p>字母M：内存使用排序</p>\n<p>字母m：改变内存和交换区显示</p>\n<p>字母b：高亮运行太进程</p>\n<p>字母f：编排显示</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"计算机启动到操作系统运行","slug":"systemstructure/linux/bootofcomputer","date":"2020-04-25T12:13:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/bootofcomputer.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139306R-C.81d56db1bef63aa01cbba73b33caedf3?rik=3YtNM7LX%2fwHS5Q&riu=http%3a%2f%2fwww.linuxidc.com%2fupload%2f2016_06%2f160617100110611.png&ehk=0SHzV%2fqNHRE7jk8jqfwwge4teKMqurNw7sM4KipqkaA%3d&risl=&pid=ImgRaw&r=0","content":"<p>首先学一个东西，一定要有一个<strong>前置</strong>的知识，我们把它当做已知的，我不可能从原子组成分子开始讲原理。那学习计算机启动过程的前置知识是什么呢？我要求你已知以下几点：</p>\n<ol>\n<li>内存是存储数据的地方，给出一个地址信号，内存可以返回该地址所对应的数据。</li>\n<li>CPU 的工作方式就是不断从内存中取出指令，并执行。</li>\n<li>CPU 从内存的哪个地址取出指令，是由一个寄存器中的值决定的，这个值会不断进行 +1 操作，或者由某条跳转指令指定其值是多少。</li>\n</ol>\n<p>好了，只需要知道这三点<strong>前置</strong>知识，你就能专业地解释计算机的启动过程了。</p>\n<h2 id=\"一、为什么是-BIOS-主导？\"><a href=\"#一、为什么是-BIOS-主导？\" class=\"headerlink\" title=\"一、为什么是 BIOS 主导？\"></a>一、为什么是 BIOS 主导？</h2><p>都说开机后，BIOS 就开始运行自己的程序了，又硬件自检，又加载启动区的。我就不服了，为什么开机后是执行 BIOS 里的程序？为啥不是内存里的？为啥不是硬盘里的？</p>\n<p>好的，不要怀疑前置知识，CPU 的工作方式，就是不断从内存中取指令并执行，那为什么会说是执行 BIOS 里的程序呢？这就不得不说说<strong>内存映射</strong>了。</p>\n<h2 id=\"二、内存映射\"><a href=\"#二、内存映射\" class=\"headerlink\" title=\"二、内存映射\"></a>二、内存映射</h2><p><strong>CPU 地址总线的宽度决定了可访问的内存空间的大小</strong>。比如 16 位的 CPU 地址总线宽度为 20 位，地址范围是 1M。32 位的 CPU 地址总线宽度为 32 位，地址范围是 4G。你可以算算我们现在的 64 位机的地址范围。</p>\n<p>可是，可访问的内存空间这么大，并不等于说全都给内存使用，也就是说寻址的对象不只有内存，还有一些外设也要通过地址总线的方式去访问，那怎么去访问这些外设呢？就是在地址范围中划出一片片的区域，这块给显存使用，那块给硬盘控制器使用，等等 。</p>\n<p>这样说，其实就不符合我们的前置知识了，所以可以有一种不太正确的理解方式，那就是内存中的这块位置就是显存，那块位置就是硬盘控制器。我们在相应的位置上读取或者写入，就相当于在显存等外设的相应位置上读取或者写入，就好像这些外设的存储区域，被<strong>映射</strong>到了内存中的某一片区域一样。这样我们就不用管那些外设啦，关注点仍然是一个简简单单的内存。这就是所谓的<strong>内存映射</strong>。</p>\n<p>太好了，现在又用简单的前置知识就能解释得通了，我们继续往下推。</p>\n<h2 id=\"三、实模式下的内存分布\"><a href=\"#三、实模式下的内存分布\" class=\"headerlink\" title=\"三、实模式下的内存分布\"></a>三、实模式下的内存分布</h2><p>刚刚说到内存中划分出了一片一片区域给各种外设，那么问题自然就来了，哪块区域，分给了哪块外设了呢？如果是规定，那应该有一张表比较好吧。嗯没错，还真有，它就是实模式下的内存分布，笔者给它画了一张图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139328640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">在这里插入图片描述</p>\n<p>哎哟我真是个小天使，把比例都表现出来了，网上能再找出比我这个更直观的请给我留言。实模式之后再解释，现在简单理解就是计算机刚开机的时候只有 1M 的内存可用。</p>\n<p>我们看到，内存被各种外设瓜分了，即映射在了内存中。BIOS 更狠，不但其空间被映射到了内存 0xC0000 - 0xFFFFF 位置，其里面的程序还占用了开头的一些区域，比如把中断向量表写在了内存开始的位置，真所谓先到先得啊。</p>\n<h2 id=\"四、怎么就从-BIOS-里的程序开始执行了\"><a href=\"#四、怎么就从-BIOS-里的程序开始执行了\" class=\"headerlink\" title=\"四、怎么就从 BIOS 里的程序开始执行了\"></a>四、怎么就从 BIOS 里的程序开始执行了</h2><p>好了，现在我们知道 BIOS 里的信息被映射到了内存 0xC0000 - 0xFFFFF 位置，其中最为关键的系统 BIOS 被映射到了 0xF0000 - 0xFFFFF 位置。假如我现在说，CPU 开机就是执行了这块区域的代码，然后巴拉巴拉一顿操作就开机了，你肯定要喷我了，为什么就执行到这了呢，那咋不从头开始执行？</p>\n<p>这就自然有了一种猜想，我们要用到另一个前置知识了，就是 CPU 从内存的哪个位置取出执行并执行呢？<strong>是 PC 寄存器中的地址值</strong>。BIOS 程序的入口地址也就是开始地址是 0xFFFF0（人家就那么写的），也就是开机键一按下，一定有一个神奇的力量，将 pc 寄存器中的值变成 0xFFFF0，然后 CPU 就开始马不停蹄地跑了起来。没错，接下来这句话，可能就是你找了很久的答案，请做好准备：</p>\n<p><strong>在你开机的一瞬间，CPU 的 PC 寄存器被强制初始化为 0xFFFF0</strong>。如果再说具体些，CPU 将段基址寄存器 cs 初始化为 0xF000，将偏移地址寄存器 IP 初始化为 0xFFF0，根据实模式下的最终地址计算规则，将段基址左移 4 位，加上偏移地址，得到最终的物理地址也就是抽象出来的 PC 寄存器地址为 0xFFFF0。</p>\n<p>当我在学习这段知识时，看到这句话才让将我心里积压了很久的疑惑解开，多么简单粗暴的道理啊。写到这里我也是长舒了一口气，因为剩下的过程，就几乎只是流水账一样的正推了。</p>\n<p>至于怎么强制初始化的，我觉得就越过了前置知识的边界了，况且各个厂商的硬件实现也不一定相同，有很多办法，也很简单。讨论起来意义就不大了。</p>\n<h2 id=\"五、BIOS-里到底写了什么程序\"><a href=\"#五、BIOS-里到底写了什么程序\" class=\"headerlink\" title=\"五、BIOS 里到底写了什么程序\"></a>五、BIOS 里到底写了什么程序</h2><p>好了，我们现在知道了 BIOS 被映射到了内存的某个位置，并且开机一瞬间 CPU 强制将自己的 pc 寄存器初始化为 BIOS 程序的入口地址，从这里开始 CPU 马不停蹄地向前跑了起来。那接下来的问题似乎也非常自然地就问出来了，那就是 BIOS 程序里到底写了啥？</p>\n<p>把 BIOS 程序里的二进制信息全贴出来也不合适，我们分析一些主要的。我们首先还是来猜测，你看入口地址是 0xFFFF0，说明程序是从这执行的。实模式下内存的下边界就是 0xFFFFF，也就是只剩下 16 个字节的空间可以写代码了，这够干啥的呢？如果你有心的话应该能猜出，入口地址处可能是个跳转指令，跳到一个更大范围的空间去执行自己的任务。没错就是这样，0xFFFF0 处存储的机器指令，翻译成汇编语言是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp far f000:e05b</span><br></pre></td></tr></table></figure>\n\n<p>意思是跳转到物理地址 0xfe05b 处开始执行（回忆下前面说的实模式下的地址计算方式）。</p>\n<p>地址 0xfe05b 处开始，便是 BIOS 真正发挥作用的代码了，这块代码会检测一些外设信息，并初始化好硬件，建立中断向量表并填写中断例程。这里的部分不要展开，这只是一段写死的程序而已，而且对理解开机启动过程无帮助，我们看后面精彩的部分，也就是 BIOS 的最后一项工作：<strong>加载启动区</strong>。</p>\n<h2 id=\"六、0x7c00-是啥\"><a href=\"#六、0x7c00-是啥\" class=\"headerlink\" title=\"六、0x7c00 是啥\"></a>六、0x7c00 是啥</h2><p>该较真的地方就是要较真，我绝对不会让<strong>加载</strong>这种魔幻的词出现在这里，我们现在就来把它拆解成人话。</p>\n<p>其实这个词也并不魔幻，加载在计算机领域就是指，<strong>把某设备上（比如硬盘）的程序复制到内存中的过程</strong>。那加载启动区这个过程，翻译过来就是，<strong>BIOS 程序把启动区的内容复制到了内存中的某个区域</strong>。好了，问题又自然出来了，启动区是哪里？被复制到了内存的哪个位置？然后呢？我们一个个来回答。</p>\n<p>什么是启动区呢？即使你不知道，你也应该能够猜到，一定是符合某种特征的一块区域，于是人们把它就叫做启动区了，那要符合什么特征呢？先不急，不知道你有没有过设置 BIOS 启动顺序的经历，通常有 U 盘启动、硬盘启动、软盘启动、光盘启动等等，<strong>BIOS 会按照顺序，读取这些启动盘中位于 0 盘 0 道 1 扇区的内容</strong>。</p>\n<p>至于磁盘格式的划分，本篇就不做讲解了，总之对于内存，我们给出一个数字地址就能获取到该地址的数据，而对于磁盘，我们需要给出磁头、柱面、扇区这三个信息才能定位某个位置的数据，都是描述位置的一种方式而已。</p>\n<p>接着说， 这 0 盘 0 道 1 扇区的内容一共有 512 个字节，<strong>如果末尾的两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区</strong>。如果不是，那么按顺序继续向下个设备中寻找位于 0 盘 0 道 1 扇区的内容。如果最后发现都没找到符合条件的，那直接报出一个无启动区的错误。</p>\n<p>BIOS 找到了这个启动区之后干嘛呢？哦，前面说过了是加载，<strong>就是把这 512 个字节的内容，一个比特都不少的全部复制到内存的 0x7c00 这个位置</strong>。怎么复制的？当然是指令啦。哪些指令呢？这里我只能简单说指令集中是有 in 和 out 的，用来将外设中的数据复制到内存，或者将内存中的数据复制到外设，用这两个指令，以及外设给我们提供的读取方式，就能做到这一点啦。</p>\n<p>启动区内容此时已经被 BIOS 程序复制到了内存的 0x7c00 这个位置，然后呢？这个其实也不难猜测，启动区的内容就是我们自己写的代码了，复制到这里之后，就开始执行呗，之后我们的程序就接管了接下来的流程，BIOS 的使命也就结束啦。所以复制完之后，接下来应该是一个跳转指令吧！没错，正是这样，PC 寄存器的值变为 0x7c00，指令开始从这里执行。</p>\n<p>咦？不知道你有没有发现，我们似乎不知不觉又把之前的一句魔法语言翻译成人话了，开头我们说：</p>\n<blockquote>\n<p>BIOS 把控制权转交给排在第一位的存储设备。</p>\n</blockquote>\n<p>所以这句话是什么意思呢？<strong>就是 BIOS 把启动区的 512 字节复制到内存的 0x7c00 位置，并且用一条跳转指令将 pc 寄存器的值指向 0x7c00</strong>。你看，这不是也没多几个字嘛，就把这个问题说得明明白白，简简单单。</p>\n<p>哦，对了，现在似乎就剩下一个问题了，为什么非要是 0x7c00 呢？好问题，当然答案也很简单，那就是人家 BIOS 开发团队就是这样定的，之后也不好改了，不然不兼容。为什么不好改？我们看一个简单的启动区 512 字节的代码。（代码摘抄自《30 天自制操作系统》）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; hello-os</span><br><span class=\"line\">; TAB&#x3D;4</span><br><span class=\"line\"></span><br><span class=\"line\">  ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置</span><br><span class=\"line\"></span><br><span class=\"line\">;程序主体</span><br><span class=\"line\"></span><br><span class=\"line\">entry:</span><br><span class=\"line\">  MOV  AX,0   ;初始化寄存器</span><br><span class=\"line\">  MOV  SS,AX</span><br><span class=\"line\">  MOV  SP,0x7c00</span><br><span class=\"line\">  MOV  DS,AX   ;段寄存器初始化为 0</span><br><span class=\"line\">  MOV  ES,AX</span><br><span class=\"line\">  MOV  SI,msg</span><br><span class=\"line\">putloop:</span><br><span class=\"line\">  MOV  AL,[SI]</span><br><span class=\"line\">  ADD  SI,1</span><br><span class=\"line\">  CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符</span><br><span class=\"line\">  JE  fin</span><br><span class=\"line\">  MOV  AH,0x0e   ;指定文字</span><br><span class=\"line\">  MOV  BX,15   ;指定颜色</span><br><span class=\"line\">  INT  0x10   ;调用 BIOS 显示字符函数</span><br><span class=\"line\">  JMP  putloop</span><br><span class=\"line\">fin:</span><br><span class=\"line\">  HLT</span><br><span class=\"line\">  JMP  fin</span><br><span class=\"line\">msg:</span><br><span class=\"line\">  DB  0x0a,0x0a  ;换行、换行</span><br><span class=\"line\">  DB  &quot;hello-os&quot;</span><br><span class=\"line\">  DB  0x0a   ;换行</span><br><span class=\"line\">  DB  0    ;0 结尾</span><br><span class=\"line\"></span><br><span class=\"line\">  RESB 0x7dfe-$   ;填充0到512字节</span><br><span class=\"line\">  DB 0x55, 0xaa   ;可启动设备标识</span><br></pre></td></tr></table></figure>\n\n<p>我们看第一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ORG  0x7c00</span><br></pre></td></tr></table></figure>\n\n<p>这个数字就是刚刚说的启动区加载位置，这行汇编代码简单说就表示把下面的地址统统加上 0x7c00。正因为 BIOS 将启动区的代码加载到了这里，因此有了一个偏移量，所以所有写启动区代码的人就需要在开头写死一个这样的代码，不然全都串位了。</p>\n<p>然后正因为所有写操作系统的，启动区的第一行汇编代码都写死了这个数字，那 BIOS 开发者最初定的这个数字就不好改了，否则它得挨个联系各个操作系统的开发厂商，说唉我这个地址改一下哈，你们跟着改改。在公司推动另一个团队改个代码都得大费周折，想想看这样的推动得耗费多大人力。况且即使改了，之前的代码也都不兼容了，这不得被人们骂死啊。</p>\n<p>再看最后一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DB 0x55, 0xaa</span><br></pre></td></tr></table></figure>\n\n<p>这也验证了我们之前说的这 512 字节的最后两个字节得是 0x55 0xaa，BIOS 才会认为它是一个启动区，才会去加载它，仅此而已。</p>\n<p>回过头来说 0x7c00 这个值，它其实就是一个规定死的值，但还是会有人问，那必然有它的合理性吧。其实，我的解释也只能说是人家规定了这个值，后人们替他们解释这个合理性，并不是说当初人家就一定是这样想的，就好比我们做语文的阅读理解题一样。</p>\n<p>第一个 BIOS 开发团队是 IBM PC 5150 BIOS，当时被认为的第一个操作系统是 DOS 1.0 操作系统，BIOS 团队就假设是为它服务的。但操作系统还没出，BIOS 团队假设其操作系统需要的最小内存为 32 KB。BIOS 希望自己所加载的启动区代码尽量靠后，这样比较“安全”，不至于过早的被其他程序覆盖掉。可是如果仅仅留 512 字节又感觉太悬了，还有一些栈空间需要预留，那扩大到 1 KB 吧。这样 32 KB 的末尾是 0x8000，减去 1KB(0x400) ，刚好等于 0x7c00。哇塞，太精准了，这可以是一种解释方式。</p>\n<h2 id=\"七、启动区里的代码写了啥\"><a href=\"#七、启动区里的代码写了啥\" class=\"headerlink\" title=\"七、启动区里的代码写了啥\"></a>七、启动区里的代码写了啥</h2><p>其实写到这，我这篇文章就应该戛然而止了，因为最初的那个问题已经解决了，CPU 已经开始马不停蹄地从我们预期的位置跑起来了，万事开头难，剩下的内容，就是操作系统想怎么玩就怎么玩了。</p>\n<p>但我觉得还不够味，似乎还有些问题萦绕在你脑海里。比如说这个问题：</p>\n<blockquote>\n<p>启动区里的代码写了啥？就 512 字节就是全部操作系统内容了？</p>\n</blockquote>\n<p>这是一个好问题，512 个字节确实干不了啥，现在的操作系统怎么也得按 M 为单位算吧，512 个字节远远不够呢，那是怎么回事呢？</p>\n<p>其实我们可以按照之前的思路猜测，BIOS 用很少的代码就把 512 字节的启动区内容加载到了内存，并跳转过去开始执行。那按照这个套路，这 512 字节的启动区代码，是不是也可以把更多磁盘中存储的操作系统程序，加载到内存的某个位置，然后跳转过去呢？</p>\n<p>没错，就是这个套路。<strong>所以 BIOS 负责加载了启动区，而启动区又负责加载真正的操作系统内核</strong>，这配合默契吧？</p>\n<p>由于用于启动盘的磁盘是人家写操作系统的厂商制作的，俗称制作启动盘，所以他也肯定知道操作系统的核心代码存储在磁盘的哪个扇区，因此启动区就把这个扇区，以及之后的好多好多扇区（具体取决于操作系统有多大）都读到内存中，然后跳转到开始的程序开始的位置。跳转到哪里呢？这个就不像 0x7c00 这个数那么经典了，不同的操作系统肯定也不一样，也不用事先规定好，反正写操作系统的人给自己定一个就好了，别覆盖其他关键设备用到的区域就好。</p>\n<h2 id=\"八、操作系统内核写了啥\"><a href=\"#八、操作系统内核写了啥\" class=\"headerlink\" title=\"八、操作系统内核写了啥\"></a>八、操作系统内核写了啥</h2><p>好了现在经过好几轮跳跳跳，终于跳到内核代码啦，我们来一起回顾一下：</p>\n<ol>\n<li>按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址（一跳）</li>\n<li>该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）</li>\n<li>执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）</li>\n<li>启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139335949069-20190421160331677-268089991.png\" alt=\"img\"></p>\n<h1 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h1><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351393421635139306R-C.81d56db1bef63aa01cbba73b33caedf3?rik=3YtNM7LX/wHS5Q&riu=http://www.linuxidc.com/upload/2016_06/160617100110611.png&ehk=0SHzV/qNHRE7jk8jqfwwge4teKMqurNw7sM4KipqkaA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"linux kernel更换","slug":"systemstructure/linux/changekernel","date":"2020-04-15T12:02:01.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/changekernel.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139368linux-kernel.png","content":"<p>CentOS 是RHEL（Red Hat Enterprise Linux）源代码再编译的产物</p>\n<table>\n<thead>\n<tr>\n<th>发行版本</th>\n<th>发行时间</th>\n<th>内核版本</th>\n<th>发布时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2.1</td>\n<td>2004.05.14</td>\n<td>kernel-2.4.9</td>\n<td>2011.08</td>\n</tr>\n<tr>\n<td>3.1~3.9</td>\n<td>2004.03.19~2007.07.26</td>\n<td>kernel-2.4.21</td>\n<td>2003.01</td>\n</tr>\n<tr>\n<td>4.0~4.9</td>\n<td>2005.03.09~2011.03.02</td>\n<td>kernel-2.6.9</td>\n<td>2004.10</td>\n</tr>\n<tr>\n<td>5.0~5.11</td>\n<td>2007.04.12~2014.09.30</td>\n<td>kernel-2.6.18</td>\n<td>2006.09</td>\n</tr>\n<tr>\n<td>6.0~6.10</td>\n<td>2011.07.04~</td>\n<td>kernel-2.6.32</td>\n<td>2009.12</td>\n</tr>\n<tr>\n<td>7.0.1406</td>\n<td>2014.07.07</td>\n<td>kernel-3.10.0-123</td>\n<td>2013.07</td>\n</tr>\n<tr>\n<td>7.1.1503</td>\n<td>2015.03.31</td>\n<td>kernel-3.10.0-229</td>\n<td></td>\n</tr>\n<tr>\n<td>7.2.1511</td>\n<td>2015.12.15</td>\n<td>kernel-3.10.0-327</td>\n<td></td>\n</tr>\n<tr>\n<td>7.3.1611</td>\n<td>2016.12.12</td>\n<td>kernel-3.10.0-514</td>\n<td></td>\n</tr>\n<tr>\n<td>7.4.1708</td>\n<td>2017.09.13</td>\n<td>kernel-3.10.0-693</td>\n<td></td>\n</tr>\n<tr>\n<td>7.5.1804</td>\n<td>2018.05.10</td>\n<td>kernel-3.10.0-862</td>\n<td></td>\n</tr>\n<tr>\n<td>7.6.1810</td>\n<td>2018.12.04</td>\n<td>kernel-3.10.0-957</td>\n<td></td>\n</tr>\n<tr>\n<td>7.7.1908</td>\n<td>2019.09.18</td>\n<td>kernel-3.10.0-1062</td>\n<td></td>\n</tr>\n<tr>\n<td>8.0.1905</td>\n<td>2019-09-25</td>\n<td>kernel-4.18.0-80</td>\n<td>2018.08</td>\n</tr>\n</tbody></table>\n<p>ubuntu</p>\n<table>\n<thead>\n<tr>\n<th>发行版本</th>\n<th>发行时间</th>\n<th>内核版本</th>\n<th>发布时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>4.10</td>\n<td>2004.10.20</td>\n<td>2.6.8</td>\n<td>2004.08</td>\n</tr>\n<tr>\n<td>5.04</td>\n<td>2005.04.08</td>\n<td>2.6.10</td>\n<td>2004.12</td>\n</tr>\n<tr>\n<td>5.10</td>\n<td>2005.10.13</td>\n<td>2.6.12</td>\n<td>2005.01</td>\n</tr>\n<tr>\n<td>6.06</td>\n<td>2006.06.01(LTS)</td>\n<td>2.6.15</td>\n<td>2006.01</td>\n</tr>\n<tr>\n<td>6.10</td>\n<td>2006.10.06</td>\n<td>2.6.17</td>\n<td>2006.06</td>\n</tr>\n<tr>\n<td>7.04</td>\n<td>2007.04.19</td>\n<td>2.6.20</td>\n<td>2007.02</td>\n</tr>\n<tr>\n<td>7.10</td>\n<td>2007.10.18</td>\n<td>2.6.22</td>\n<td>2007.07</td>\n</tr>\n<tr>\n<td>8.04</td>\n<td>2008.04.24(LTS)</td>\n<td>2.6.24</td>\n<td>2008.01</td>\n</tr>\n<tr>\n<td>8.10</td>\n<td>2008.10.30</td>\n<td>2.6.27</td>\n<td>2008.10</td>\n</tr>\n<tr>\n<td>9.04</td>\n<td>2009.04.23</td>\n<td>2.6.28</td>\n<td>2009.01</td>\n</tr>\n<tr>\n<td>9.10</td>\n<td>2009.10.29</td>\n<td>2.6.31</td>\n<td>2009.09</td>\n</tr>\n<tr>\n<td>10.04</td>\n<td>2010.4.29</td>\n<td>2.6.32</td>\n<td>2009.12</td>\n</tr>\n<tr>\n<td>10.10</td>\n<td>2010.10.13</td>\n<td>2.6.35</td>\n<td>2010.08</td>\n</tr>\n<tr>\n<td>11.04</td>\n<td>2011.04.28</td>\n<td>2.6.38</td>\n<td>2011.03</td>\n</tr>\n<tr>\n<td>11.10</td>\n<td>2011.10.13</td>\n<td>3.0</td>\n<td>2011.08</td>\n</tr>\n<tr>\n<td>12.04</td>\n<td>2012.04.26(LTS)</td>\n<td>3.2+</td>\n<td>2012.01</td>\n</tr>\n<tr>\n<td>12.10</td>\n<td>2012.10.20</td>\n<td>3.5</td>\n<td>2012.08</td>\n</tr>\n<tr>\n<td>13.04</td>\n<td>2013.04.25</td>\n<td>3.8</td>\n<td>2013.02</td>\n</tr>\n<tr>\n<td>13.10</td>\n<td>2013.10.17</td>\n<td>3.11</td>\n<td>2013.09</td>\n</tr>\n<tr>\n<td>14.04</td>\n<td>2014.04.18 (LTS)</td>\n<td>3.13</td>\n<td>2014.01</td>\n</tr>\n<tr>\n<td>14.10</td>\n<td>2014.10.23</td>\n<td>3.16</td>\n<td>2014.08</td>\n</tr>\n<tr>\n<td>15.04</td>\n<td>2015.04</td>\n<td>3.19</td>\n<td>2015.03</td>\n</tr>\n<tr>\n<td>15.10</td>\n<td>2015.10</td>\n<td>4.2</td>\n<td>2015.08</td>\n</tr>\n<tr>\n<td>16.04</td>\n<td>2016.04（LTS）</td>\n<td>4.4</td>\n<td>2016.01</td>\n</tr>\n<tr>\n<td>16.10</td>\n<td>2016.10</td>\n<td>4.8</td>\n<td>2016.10</td>\n</tr>\n<tr>\n<td>17.04</td>\n<td>2017.04</td>\n<td>4.10</td>\n<td>2017.02</td>\n</tr>\n<tr>\n<td>17.10</td>\n<td>2017.10</td>\n<td>4.13</td>\n<td>2017.09</td>\n</tr>\n<tr>\n<td>18.04</td>\n<td>2018.04.26</td>\n<td>4.15</td>\n<td>2018.01</td>\n</tr>\n<tr>\n<td>18.10</td>\n<td>2018.10.18</td>\n<td>4.18</td>\n<td>2018.08</td>\n</tr>\n<tr>\n<td>19.04</td>\n<td>2019.04.18</td>\n<td>5.0</td>\n<td>2019.03</td>\n</tr>\n<tr>\n<td>19.10</td>\n<td>2019.10.17</td>\n<td>5.2</td>\n<td>2019.07</td>\n</tr>\n<tr>\n<td>20.04</td>\n<td>2020.04.23</td>\n<td>5.4</td>\n<td>2019.11</td>\n</tr>\n</tbody></table>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p>centos</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name grub.cfg #grub是引导操作系统的程序，它会根据自己的配置文件，去引导内核，当内核被加载到内存以后，内核会根据grub配置文件中的配置，找到根分区所使用的文件系统对应的驱动，通过根分区文件系统对应的驱动，挂载根分区，从而达到启动操作系统的目的。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-1-30 ~]# grub2-</span><br><span class=\"line\">grub2-bios-setup           grub2-macbless             grub2-mkrelpath            grub2-script-check</span><br><span class=\"line\">grub2-editenv              grub2-menulst2cfg          grub2-mkrescue             grub2-set-default</span><br><span class=\"line\">grub2-file                 grub2-mkconfig             grub2-mkstandalone         grub2-setpassword</span><br><span class=\"line\">grub2-fstest               grub2-mkfont               grub2-ofpathname           grub2-sparc64-setup</span><br><span class=\"line\">grub2-get-kernel-settings  grub2-mkimage              grub2-probe                grub2-syslinux2cfg</span><br><span class=\"line\">grub2-glue-efi             grub2-mklayout             grub2-reboot               </span><br><span class=\"line\">grub2-install              grub2-mknetdir             grub2-render-label         </span><br><span class=\"line\">grub2-kbdcomp              grub2-mkpasswd-pbkdf2      grub2-rpm-sort    </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> centos7 以上使用grub2 系列命令 centos7 以下是grub系列命令，用于grub设置</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -a  # 查看kernel版本</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h3><ol>\n<li><a href=\"https://blog.csdn.net/weixin_40161232/article/details/85251250\">https://blog.csdn.net/weixin_40161232/article/details/85251250</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_34194087/article/details/93497024\">https://blog.csdn.net/weixin_34194087/article/details/93497024</a></li>\n<li><a href=\"https://blog.csdn.net/zhaihaibo168/article/details/102673669\">https://blog.csdn.net/zhaihaibo168/article/details/102673669</a></li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"yum使用","slug":"systemstructure/linux/centos/yum","date":"2020-03-25T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/centos/yum.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139119R-C.e7858ea7dbba67337d3f500b54cbcf56?rik=GYzv0YkaAoFURQ&riu=http%3a%2f%2fwww.lixh.cn%2fwp-content%2fuploads%2f2016%2f08%2fyumserver.png&ehk=k4SGsgtCGKTxT0%2bakBQ4bKUDFIBTi7VwHWP8L%2fM3TI4%3d&risl=&pid=ImgRaw&r=0","content":"<p>[toc]</p>\n<h2 id=\"更改centos-yum-源\"><a href=\"#更改centos-yum-源\" class=\"headerlink\" title=\"更改centos yum 源\"></a>更改centos yum 源</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/yum.repos.d/CentOS-Base.rep</span><br></pre></td></tr></table></figure>\n\n<p>更改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[base]</span><br><span class=\"line\">name&#x3D;CentOS-$releasever - Base</span><br><span class=\"line\">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7.6.1810&#x2F;os&#x2F;x86_64&#x2F;</span><br><span class=\"line\">gpgcheck&#x3D;0</span><br><span class=\"line\"></span><br><span class=\"line\">[updates]</span><br><span class=\"line\">name&#x3D;CentOS-$releasever - Updates</span><br><span class=\"line\">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7.6.1810&#x2F;updates&#x2F;x86_64&#x2F;</span><br><span class=\"line\">gpgcheck&#x3D;0</span><br><span class=\"line\"></span><br><span class=\"line\">[extras]</span><br><span class=\"line\">name&#x3D;CentOS-$releasever - Extras</span><br><span class=\"line\">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7.6.1810&#x2F;extras&#x2F;x86_64&#x2F;</span><br><span class=\"line\">gpgcheck&#x3D;0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[serverid]</span><br><span class=\"line\">#其中serverid是用于区别各个不同的repository（仓库;贮藏室;博物馆;亲信），必须有一个独一无二的名称。 重复了 前面覆盖后面--还是反过来呢？？？用enabled 测试是后面覆盖前面</span><br><span class=\"line\"></span><br><span class=\"line\">name&#x3D;Some name for this server</span><br><span class=\"line\">#name，是对repository的描述，支持像$releasever $basearch这样的变量; name&#x3D;Fedora Core $releasever - $basearch - Released Updates</span><br><span class=\"line\"></span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">#baseurl是服务器设置中最重要的部分，只有设置正确，才能从上面获取软件。它的格式是：</span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;server1&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">url:&#x2F;&#x2F;server2&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">url:&#x2F;&#x2F;server3&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">#其中url支持的协议有 http:&#x2F;&#x2F; ftp:&#x2F;&#x2F; file:&#x2F;&#x2F;三种。baseurl后可以跟多个url，你可以自己改为速度比较快的镜像站，但baseurl只能有一个，也就是说不能像如下格式：</span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;server1&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;server2&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;server3&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">其中url指向的目录必须是这个repository header目录的上一级，它也支持$releasever $basearch这样的变量。</span><br><span class=\"line\"></span><br><span class=\"line\">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrors.fedoraproject.org&#x2F;mirrorlist?repo&#x3D;fedora-$releasever&amp;arch&#x3D;$basearch</span><br><span class=\"line\">#上面的这一行是指定一个镜像服务器的地址列表，通常是开启的，本例中加了注释符号禁用了，我们可以试试，将$releasever和$basearch替换成自己对应的版本和架构，例如10和i386，在浏览器中打开，我们就能看到一长串镜可用的镜像服务器地址列表。</span><br><span class=\"line\"></span><br><span class=\"line\">url之后可以加上多个选项，如gpgcheck、exclude、failovermethod等，比如：</span><br><span class=\"line\">gpgcheck&#x3D;1</span><br><span class=\"line\">exclude&#x3D;gaim</span><br><span class=\"line\">#其中gpgcheck，exclude的含义和[main]部分相同，但只对此服务器起作用，</span><br><span class=\"line\">failovermethod&#x3D;priority</span><br><span class=\"line\">#failovermethode 有两个选项roundrobin和priority，意思分别是有多个url可供选择时，yum选择的次序，roundrobin是随机选择，如果连接失 败则使用下一个，依次循环，priority则根据url的次序从第一个开始。如果不指明，默认是roundrobin。</span><br><span class=\"line\"></span><br><span class=\"line\">enabled&#x3D;[1 or 0]</span><br><span class=\"line\">#当某个软件仓库被配置成 enabled&#x3D;0 时，yum 在安装或升级软件包时不会将该仓库做为软件包提供源。使用这个选项，可以启用或禁用软件仓库。</span><br><span class=\"line\">#通过 yum 的 --enablerepo&#x3D;[repo_name] 和 --disablerepo&#x3D;[repo_name] 选项，或者通过 PackageKit 的&quot;添加&#x2F;删除软件&quot;工具，也能够方便地启用和禁用指定的软件仓库</span><br></pre></td></tr></table></figure>\n\n<p>由于通过源码安装的qemu没有办法通过系统工具进行卸载，也没有办法通过make uninstall方法卸载，所以只能通过删除文件的方式进行卸载。</p>\n<p>qemu可执行文件默认放在/usr/local/bin，库文件默认放在/usr/local/libexec，配置文件默认放在/usr/local/etc，共享文件默认放在/usr/local/etc/share。要卸载源码编译的qemu，需要到这四个目录中找出相关的文件然后删除掉。</p>\n<p>如果configure时没有通过–target-list=指定编译的目标机体系结构，则/usr/local/bin中的以qemu开头的文件需要删除，总共51个。</p>\n<p>/usr/local/libexec中只有一个文件：qemu-bridge-helper，直接删除即可。</p>\n<p>/usr/local/etc比较简单，只有一个qemu目录，其下有一个文件target-x86_64.conf，直接将qemu目录删除即可。</p>\n<p>同/usr/local/etc一样，qemu相关的共享文件都放在/usr/local/etc/share目录下的qemu子目录中，直接将该子目录删除即可。</p>\n<h2 id=\"设置本地yum源\"><a href=\"#设置本地yum源\" class=\"headerlink\" title=\"设置本地yum源\"></a>设置本地yum源</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建rpm包文件存放目录及复制相关文件</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> mkdir -pv /mnt/CentOS7_ISO</span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /run/media/robin/CentOS\\ 7\\ x86_64/</span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> cp -R * /mnt/CentOS7_ISO/</span></span><br><span class=\"line\"></span><br><span class=\"line\">修改yum源repo文件配置</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /etc/yum.repos.d/</span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> mkdir old</span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> mv *.repo old</span></span><br><span class=\"line\"></span><br><span class=\"line\">编辑repo配置文件</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim /etc/yum.repos.d/longtao.repo</span></span><br><span class=\"line\">[longtao]</span><br><span class=\"line\">name=longtao local repository</span><br><span class=\"line\">baseurl=file/root/qemu-kvm-ev</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">清空yum缓存目录</span><br><span class=\"line\">  [root@centos7-router yum.repos.d]# yum clean all</span><br><span class=\"line\">  Loaded plugins: fastestmirror, langpacks</span><br><span class=\"line\">  Cleaning repos: local-media</span><br><span class=\"line\">  Cleaning up everything</span><br><span class=\"line\">  Cleaning up list of fastest mirrors</span><br><span class=\"line\"></span><br><span class=\"line\">生成yum元数据</span><br><span class=\"line\">  [root@centos7-router yum.repos.d]# yum makecache</span><br><span class=\"line\">  Loaded plugins: fastestmirror, langpacks</span><br><span class=\"line\">  local-media                                                                        | 3.6 kB  00:00:00    </span><br><span class=\"line\">  (1/4): local-media/group_gz                                                      | 155 kB  00:00:00    </span><br><span class=\"line\">  (2/4): local-media/primary_db                                                    | 2.8 MB  00:00:00    </span><br><span class=\"line\">  (3/4): local-media/other_db                                                      | 1.2 MB  00:00:00    </span><br><span class=\"line\">  (4/4): local-media/filelists_db                                                  | 2.9 MB  00:00:00    </span><br><span class=\"line\">  Determining fastest mirrors</span><br><span class=\"line\">  Metadata Cache Created  ###提示元数据缓存创建成功</span><br><span class=\"line\"></span><br><span class=\"line\">查看本机yum repo 仓库</span><br><span class=\"line\">  [root@centos7-router ~]# yum repolist</span><br><span class=\"line\">  Loaded plugins: fastestmirror, langpacks</span><br><span class=\"line\">  Loading mirror speeds from cached hostfile</span><br><span class=\"line\">  repo id                                               repo name                    status</span><br><span class=\"line\">  local-media                                        CentOS-7 - Media                   3,723</span><br><span class=\"line\">  repolist: 3,723</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"临时源\"><a href=\"#临时源\" class=\"headerlink\" title=\"临时源\"></a>临时源</h2><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li><code>yum update</code>别运行，可能把内核和上面的软件都更新了</li>\n<li></li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"}]},{"title":"react antd","slug":"systemstructure/font/reactandantd","date":"2020-03-25T11:34:56.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/font/reactandantd.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139070react_hooks_web-min.png","content":"<ol>\n<li>antd  是<a href=\"https://www.html.cn/create-react-app/\">react </a>UI 组件库 </li>\n<li>使用 <code>npx create-react-app 项目名（项目名不能为大写字母）</code>yarn create  react-app 项目名`</li>\n<li><code>npm start</code>  <code>yarn start</code></li>\n<li><code>yarn test</code> 测试</li>\n<li>package-lock.json文件锁定所有模块的版本号，包括主模块和所有依赖子模块。 当你执行npm install的时候，node从package.json文件读取模块名称，从package-lock.json文件中获取版本号，(类似 go.mod 和 go.sum )</li>\n<li>Webpack 只处理 <code>src</code> 中的文件。 你需要<strong>将任何 JS 和 CSS 文件放在 <code>src</code> 中</strong>，否则 Webpack 将发现不了它们。webpack 是react的前端打包工具</li>\n</ol>\n<h4 id=\"ajax\"><a href=\"#ajax\" class=\"headerlink\" title=\"ajax\"></a>ajax</h4><ol>\n<li><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）</p>\n</li>\n<li><p>AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p>\n</li>\n<li><p>AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。</p>\n</li>\n<li><p>如需将请求发送到服务器，我们使用 <strong>XMLHttpRequest</strong> 对象的 <strong>open()</strong> 和 <strong>send()</strong> 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);</span><br><span class=\"line\">xmlhttp.send();</span><br></pre></td></tr></table></figure></li>\n<li><p>如需使用 async=false，请将 open() 方法中的第三个参数改为 false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);</span><br></pre></td></tr></table></figure>\n\n<p>我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。</p>\n<p>请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。</p>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"前端","path":"api/tags/前端.json"}]},{"title":"HAProxy负载均衡器","slug":"tools/loadbanlance","date":"2020-03-11T11:30:41.000Z","updated":"2024-06-30T10:35:56.312Z","comments":true,"path":"api/articles/tools/loadbanlance.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635176781server-large.png","content":"<h2 id=\"LB简介\"><a href=\"#LB简介\" class=\"headerlink\" title=\"LB简介\"></a>LB简介</h2><h2 id=\"HAProxy是什么\"><a href=\"#HAProxy是什么\" class=\"headerlink\" title=\"HAProxy是什么\"></a>HAProxy是什么</h2><p>HAProxy是一个免费的负载均衡软件，可以运行于大部分主流的Linux操作系统上。</p>\n<p>HAProxy提供了L4(TCP)和L7(HTTP)两种负载均衡能力，具备丰富的功能。HAProxy的社区非常活跃，版本更新快速（最新稳定版1.7.2于2017/01/13推出）。最关键的是，HAProxy具备媲美商用负载均衡器的性能和稳定性。</p>\n<p>因为HAProxy的上述优点，它当前不仅仅是免费负载均衡软件的首选，更几乎成为了唯一选择。（还有gobetween）</p>\n<h3 id=\"HAProxy的核心功能\"><a href=\"#HAProxy的核心功能\" class=\"headerlink\" title=\"HAProxy的核心功能\"></a>HAProxy的核心功能</h3><ul>\n<li>负载均衡：L4和L7两种模式，支持RR/静态RR/LC/IP Hash/URI Hash/URL_PARAM Hash/HTTP_HEADER Hash等丰富的负载均衡算法</li>\n<li>健康检查：支持TCP和HTTP两种健康检查模式</li>\n<li>会话保持：对于未实现会话共享的应用集群，可通过Insert Cookie/Rewrite Cookie/Prefix Cookie，以及上述的多种Hash方式实现会话保持</li>\n<li>SSL：HAProxy可以解析HTTPS协议，并能够将请求解密为HTTP后向后端传输</li>\n<li>HTTP请求重写与重定向</li>\n<li>监控与统计：HAProxy提供了基于Web的统计信息页面，展现健康状态和流量数据。基于此功能，使用者可以开发监控程序来监控HAProxy的状态</li>\n</ul>\n<p><strong>稳定性</strong></p>\n<p>作为建议以单进程模式运行的程序，HAProxy对稳定性的要求是十分严苛的。按照作者的说法，HAProxy在13年间从未出现过一个会导致其崩溃的BUG，HAProxy一旦成功启动，除非操作系统或硬件故障，否则就不会崩溃（我觉得可能多少还是有夸大的成分）。</p>\n<p>在上文中提到过，HAProxy的大部分工作都是在操作系统内核完成的，所以HAProxy的稳定性主要依赖于操作系统，作者建议使用2.6或3.x的Linux内核，对sysctls参数进行精细的优化，并且确保主机有足够的内存。这样HAProxy就能够持续满负载稳定运行数年之久。</p>\n<p>个人的建议：</p>\n<ul>\n<li>使用3.x内核的Linux操作系统运行HAProxy</li>\n<li>运行HAProxy的主机上不要部署其他的应用，确保HAProxy独占资源，同时避免其他应用引发操作系统或主机的故障</li>\n<li>至少为HAProxy配备一台备机，以应对主机硬件故障、断电等突发情况（搭建双活HAProxy的方法在后文中有描述）</li>\n<li>sysctl的建议配置（并不是万用配置，仍然需要针对具体情况进行更精细的调整，但可以作为首次使用HAProxy的初始配置使用）：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net.ipv4.tcp_tw_reuse = 1</span><br><span class=\"line\">net.ipv4.ip_local_port_range = 1024 65023</span><br><span class=\"line\">net.ipv4.tcp_max_syn_backlog = 10240</span><br><span class=\"line\">net.ipv4.tcp_max_tw_buckets = 400000</span><br><span class=\"line\">net.ipv4.tcp_max_orphans = 60000</span><br><span class=\"line\">net.ipv4.tcp_synack_retries = 3</span><br><span class=\"line\">net.core.somaxconn = 10000</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"工具","path":"api/tags/工具.json"}]}]}