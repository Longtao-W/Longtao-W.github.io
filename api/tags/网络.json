{"name":"网络","postlist":[{"title":"中间人攻击与HTTPS","slug":"systemstructure/network/maninthemiddleattackandhttps","date":"2021-04-15T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/maninthemiddleattackandhttps.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635168198HTTP-vs-HTTPS.png","content":"<p>[toc]</p>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>HTTP(hypertext transfer protocol )协议是一种七层协议，是万维网通信的基石，通常使用tcp协议(HTTP3使用quic(udp))，默认端口80</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>GET、HEAD：获取资源</p>\n<p>POST：上传资源</p>\n<p>PUT：修改资源</p>\n<p>DELETE：删除资源</p>\n<p>TRACE：回显请求</p>\n<p>OPTIONS：回复资源所有可用方法</p>\n<p>CONNECT：留给SSL加密使用</p>\n<h3 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h3><p>在函数式编程中，幂等函数是对任何值x具有f（f（x））= f（x）属性的函数，在编程领域，则意为同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的</p>\n<p>GET、HEAD、PUT、DELETE、OPTIONS、TRACE都是幂等的，而GET、HEAD、OPTIONS、TRACE一般来说没有副作用。</p>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><ul>\n<li>1xx消息：请求已被服务器接收，继续处理</li>\n<li>2xx成功：请求成功</li>\n<li>3xx重定向：重定向</li>\n<li>4xx请求错误：客户端错误</li>\n<li>5xx服务器错误：服务器错误</li>\n</ul>\n<h3 id=\"HTTP-keeep-alive\"><a href=\"#HTTP-keeep-alive\" class=\"headerlink\" title=\"HTTP keeep-alive\"></a>HTTP keeep-alive</h3><p>HTTP1.1加入</p>\n<p>优点：同时打开的TCP链接少了、降低延时</p>\n<p>缺点：请求后保持链接，可能会影响性能</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>HTTPS(hypertext transfer protocol secure)是使用HTTP通信，使用SSL/TLS加密数据包，默认端口443</p>\n<h3 id=\"传输过程\"><a href=\"#传输过程\" class=\"headerlink\" title=\"传输过程\"></a>传输过程</h3><p>证书验证阶段：</p>\n<ol>\n<li>浏览器发起HTTPS请求</li>\n<li>服务端返回HTTPS证书和SSL非对称加密公钥</li>\n<li>浏览器，验证HTTPS证书合法性，合法就生成随机数</li>\n</ol>\n<p>传输阶段：</p>\n<ol>\n<li>浏览器通过SSL公钥加密随机数，传输到服务端</li>\n<li>服务端通过SSL私钥解密，通过随机数构造对称加密(TLS)，通过TLS传输</li>\n</ol>\n<h4 id=\"如何验证证书合法性\"><a href=\"#如何验证证书合法性\" class=\"headerlink\" title=\"如何验证证书合法性\"></a>如何验证证书合法性</h4><p>证书包含：公钥、持有者信息、证书机构信息(CA)、数字签名和算法、有效期等</p>\n<p>证书签发：</p>\n<ol>\n<li>CA把各种信息打包通过计算得到hash值</li>\n<li>CA使用私钥对hash值加密生成证书签名</li>\n<li>将证书签名加到文件证书上，形成数字证书</li>\n</ol>\n<p>证书校验：</p>\n<ol>\n<li>浏览器通过同样hash算法得到hash值</li>\n<li>浏览器用公钥对CA数字签名解密与自己算的hash值比较，若相同就是可信的</li>\n</ol>\n<p>证书信任链：通过当前证书-中间证书-根证书逐级担保信任</p>\n<h2 id=\"中间人攻击\"><a href=\"#中间人攻击\" class=\"headerlink\" title=\"中间人攻击\"></a>中间人攻击</h2><p>A与C进行通信时，需要经过B进行传输，B获取了A和C的通话信息，B分别伪装成A和C通信，伪装成C和A通信</p>\n<h3 id=\"非对称加密场景\"><a href=\"#非对称加密场景\" class=\"headerlink\" title=\"非对称加密场景\"></a>非对称加密场景</h3><p>A发送公钥给C时，B作为中间人攻击，B也生成公私钥，B将自己的公钥发给C和C通信，B通过A发送的公钥和A通信</p>\n<h3 id=\"HTTPS中的中间人攻击\"><a href=\"#HTTPS中的中间人攻击\" class=\"headerlink\" title=\"HTTPS中的中间人攻击\"></a>HTTPS中的中间人攻击</h3><p>在缺少证书验证环节时，可以进行HTTPS中间人攻击，具体流程如下</p>\n<ol>\n<li>A与C进行通信时，本地请求劫持，B成为中间人</li>\n<li>B返回自己伪造的证书给A，B与C通信</li>\n<li>A不会验证证书，直接创建随机数，与B进行通信</li>\n<li>B与C按照正常流程进行通信</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"网卡驱动","slug":"systemstructure/network/nicdriver","date":"2020-07-19T12:30:22.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/nicdriver.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171258170855_4Tcf_3260790.png","content":"<p>驱动程序（Device Driver）全称为“设备驱动程序”，是一种可以使计算机中央处理器——CPU控制和使用设备的特殊程序，相当于硬件的接口，操作系统通过这个接口，控制硬件设备的工作。</p>\n<p>网卡设备与字符设备和块设备不同， 网络设备并不对应于/dev目录下的文件,不过会存放在/sys/class/net目录下</p>\n<p>Linux系统对网络设备驱动定义了4个层次， 这4个层次到下分为:</p>\n<p>网络协议接口层:</p>\n<p>实现统一的数据包收发的协议,该层主要负责调用dev_queue_xmit()函数发送数据， netif_rx()函数接收数据</p>\n<p>网络设备接口层:</p>\n<p>通过net_device结构体来描述一个具体的网络设备的信息,实现不同的硬件的统一</p>\n<p>设备驱动功能层：</p>\n<p>用来负责驱动网络设备硬件来完成各个功能, 它通过hard_start_xmit() 函数启动发送操作， 并通过网络设备上的中断触发接收操作,</p>\n<p>网络设备与媒介层：</p>\n<p>用来负责完成数据包发送和接收的物理实体, 设备驱动功能层的函数都在这物理上驱动的</p>\n<p><strong>层次结构如下图所示:</strong></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351712071182576-20171031190853498-1599050801.png\" alt=\"img\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171258170855_4Tcf_3260790.png\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"udp offload","slug":"systemstructure/network/offload","date":"2021-03-25T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/offload.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171342R-C.3fd39d32acf22e924676ae13410bc7f8?rik=CpqSRGJGylO%2fBw&riu=http%3a%2f%2fwiki.networksecuritytoolkit.org%2fimages%2fthumb%2fNo_segmentation_offloading.png%2f964px-No_segmentation_offloading.png&ehk=pAE0DfOX5Ii0DGj2zezPKbufNwQEX0uE62lUjaW09OA%3d&risl=&pid=ImgRaw&r=0","content":"<h2 id=\"tx-udp-tnl-segmentation\"><a href=\"#tx-udp-tnl-segmentation\" class=\"headerlink\" title=\"tx-udp_tnl-segmentation\"></a><strong>tx-udp_tnl-segmentation</strong></h2><p>Overlay网络，例如VxLAN，现在应用的越来越多。Overlay网络可以使得用户不受物理网络的限制，进而创建，配置并管理所需要的虚拟网络连接。同时Overlay可以让多个租户共用一个物理网络，提高网络的利用率。Overlay网络有很多种，但是最具有代表性的是VxLAN。VxLAN是一个MAC in UDP的设计，具体格式如下所示。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455587v2-f6d9dcd0ad97394b4c4585ee161245f0_1440w.jpg\" alt=\"img\"></p>\n<p>从VxLAN的格式可以看出，以VxLAN为代表的Overlay网络在性能上存在两个问题。一个是Overhead的增加，VxLAN在原始的Ethernet Frame上再包了一层Ethernet+IP+UDP+VXLAN，这样每个Ethernet Frame比原来要多传输50个字节。所以可以预见的是，Overlay网络的效率必然要低于Underlay网络。另一个问题比传50个字节更为严重，那就是需要处理这额外的50个字节。这50个字节包括了4个Header，每个Header都涉及到拷贝，计算，都需要消耗CPU。而我们现在迫切的问题在于CPU可以用来处理每个网络数据包的时间更少了。</p>\n<p>首先，VxLAN的这50个字节是没法避免的。其次，那就只能降低它的影响。这里仍然可以采用Jumbo Frames的思想，因为50个字节是固定的，那网络数据包越大，50字节带来的影响就相对越小。</p>\n<p>先来看一下虚拟机的网络连接图。虚拟机通过QEMU连接到位于宿主机的TAP设备，之后再通过虚机交换机转到VTEP（VxLAN Tunnel EndPoint），封装VxLAN格式，发给宿主机网卡。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455592v2-a4653d5451d3cf9737399d07be171d6e_1440w.jpg\" alt=\"img\"></p>\n<p>理想情况就是，一大段VxLAN数据直接传给网卡，由网卡去完成剩下的分片，分段，并对分成的小的网络包分别封装VxLAN，计算校验和等工作。这样VxLAN对虚机网络带来影响就可以降到最低。实际中，这是可能的，但是需要一系列的前提条件。</p>\n<p>首先，虚拟机要把大的网络包发到宿主机。因为虚拟机里面也运行了一个操作系统，也有自己的TCP/IP协议栈，所以虚拟机完全有能力自己就把大的网络包分成多个小的网络包。从前面介绍的内容看，只有TSO才能真正将一个大的网络包发到网卡。GSO在发到网卡的时候，已经在进入驱动的前一刻将大的网络包分成了若干个小的网络数据包。所以这里要求：虚机的网卡支持TSO（Virtio默认支持），并且打开TSO（默认打开），同时虚机发出的是TCP数据。</p>\n<p>之后，经过QEMU，虚拟交换机的转发，VTEP的封装，这个大的TCP数据被封装成了VxLAN格式。50个字节的VxLAN数据被加到了这个大的TCP数据上。接下来问题来了，这本来是个TCP数据，但是因为做了VxLAN的封装，现在看起来像是个UDP的数据。如果操作系统不做任何处理，按照前面的介绍，那就应该走GSO做IP Fragmentation，并在发送给网卡的前一刻分成多个小包。这样，如果网卡本来支持TSO现在就用不上了。并且更加严重的是，现在还没做TCP Segmentation。我们在上一篇花了很大的篇幅介绍其必要性的TCP Segmentation在这里也丢失了。</p>\n<p>对于现代的网卡，除了TSO，GSO等offload选项外，还多了一个选项tx-udp_tnl-segmentation。如果这个选项打开，操作系统自己会识别封装成VxLAN的UDP数据是一个tunnel数据，并且操作系统会直接把这一大段VxLAN数据丢给网卡去处理。在网卡里面，网卡会针对内层的TCP数据，完成TCP Segmentation。之后再为每个TCP Segment加上VxLAN封装（50字节），如下图右所示。这样，VxLAN封装对于虚拟机网络来说，影响降到了最低。</p>\n<p>从前面描述看，要达成上述的效果，需要宿主机网卡同时支持TSO和tx-udp_tnl-segmentation。如果这两者任意一个不支持或者都不支持。那么系统内核会调用GSO，将封装成VxLAN格式的大段TCP数据，在发给网卡驱动前完成TCP Segmentation，并且为每个TCP Segment加上VxLAN封装。如下图左所示。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455599v2-539c4c2923a10f9c331325ef604b1864_1440w.jpg\" alt=\"img\"></p>\n<p>如果关闭虚拟机内的TSO，或者虚拟机内发送的是UDP数据。那么在虚拟机的TCP/IP协议栈会调用GSO，发给虚拟机网卡驱动的前一刻，完成了分段、分片。虚拟机最终发到QEMU的网络数据包就是多个小的网络数据包。这个时候，无论宿主机怎么配置，都需要处理多个小的网络包，并对他们做VxLAN封装。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171342R-C.3fd39d32acf22e924676ae13410bc7f8?rik=CpqSRGJGylO/Bw&riu=http://wiki.networksecuritytoolkit.org/images/thumb/No_segmentation_offloading.png/964px-No_segmentation_offloading.png&ehk=pAE0DfOX5Ii0DGj2zezPKbufNwQEX0uE62lUjaW09OA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"SYN攻击","slug":"systemstructure/network/synattack","date":"2020-07-23T12:45:23.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/synattack.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171435tcp-three-way-handshake-and-syn-flood-attack.png","content":"<p>SYN：同步序列编号（***Synchronize Sequence Numbers***）。</p>\n<p>是TCP/IP建立连接时使用的握手信号。在客户机和<a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571\">服务器</a>之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以<a href=\"https://baike.baidu.com/item/ACK/3692629\">ACK</a>消息响应。这样在<a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E6%9C%BA/5168153\">客户机</a>和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递</p>\n<h3 id=\"TCP报文首部\"><a href=\"#TCP报文首部\" class=\"headerlink\" title=\"TCP报文首部\"></a>TCP报文首部</h3><p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>\n<ol>\n<li>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</li>\n<li>序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li>\n<li>确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li>\n<li>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li>\n<li>保留，占6位，保留今后使用，但目前应都位0；</li>\n<li>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li>\n<li>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</li>\n<li>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</li>\n<li>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</li>\n<li>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</li>\n<li>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li>\n<li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li>\n<li>检验和，占2字节，校验首部和数据这两部分；</li>\n<li>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</li>\n<li>选项，长度可变，定义一些其他的可选的参数。</li>\n</ol>\n<h3 id=\"TCP连接的建立（三次握手）\"><a href=\"#TCP连接的建立（三次握手）\" class=\"headerlink\" title=\"TCP连接的建立（三次握手）\"></a>TCP连接的建立（三次握手）</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171424format,png\" alt=\"三次握手\"></p>\n<ol>\n<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>\n<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>\n<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>\n<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>\n<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>\n</ol>\n<p><strong>必须三次握手的原因：</strong>双方必须确认对方正确知道对方的seq序号并以ack返回</p>\n<h3 id=\"TCP连接的释放（四次挥手）\"><a href=\"#TCP连接的释放（四次挥手）\" class=\"headerlink\" title=\"TCP连接的释放（四次挥手）\"></a>TCP连接的释放（四次挥手）</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png\" alt=\"四次挥手\"></p>\n<ol>\n<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>\n<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>\n<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>\n<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>\n<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>\n<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>\n</ol>\n<p><strong>point：</strong></p>\n<ol>\n<li>服务端和客户端都可以主动断开连接</li>\n<li>在收到FIN包，只是发送方这边不再发送数据了，但是接收方可能还有数据在发送给发送方，所以此时不能直接断开连接，也因此不能立马发送FIN包。</li>\n<li><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171435tcp-three-way-handshake-and-syn-flood-attack.png\" alt=\"See the source image\"></li>\n</ol>\n<p>author:longtao.wu</p>\n<p>blog:<a href=\"http://www.longtao.fun/\">www.longtao.fun</a></p>\n<p><strong>refrence：</strong></p>\n<ol>\n<li><a href=\"https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md\">https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md</a></li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"vlan和vxlan","slug":"systemstructure/network/vlanandvxlan","date":"2020-06-17T12:24:54.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/vlanandvxlan.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171476vlan-t.jpg","content":"<h1 id=\"vlan\"><a href=\"#vlan\" class=\"headerlink\" title=\"vlan\"></a>vlan</h1><p>VLAN(Virtual LAN)，翻译成中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。</p>\n<p>vlan被创建后，应将交换机端口分配给vlan，以此使得接入该端口的电脑属于该vlan，需要使用该vlan所属的网络IP。</p>\n<p> 广播风暴防范<br>限制网络上bai的广播，将网络划分为多个VLAN可减少参与广播风暴的设备数量。LAN分段可以防止广播风暴波及整个网络。VLAN可以提供建立防火墙的机制，防止交换网络的过量广播。使用VLAN，可以将某个交换端口或用户赋于某一个特定的VLAN组，该VLAN组可以在一个交换网中或跨接多个交换机，在一个VLAN中的广播不会送到VLAN之外。同样，相邻的端口不会收到其他VLAN产生的广 播。这样可以减少广播流量，释放带宽给用户应用，减少广播的产生。<br>2. 安全<br>　　增强局域网的安全性，含有敏感数据的用户组可与网络的其余部分隔离，从而降低泄露机密信息的可能性。不同VLAN内的报文在传输时是相互隔离的，即一个VLAN内的用户不能和其它VLAN内的用户直接通信，如果不同VLAN要进行通信，则需要通过路由器或三层交换机等三层设备。<br>　　　　　　　　3.成本降低<br>　　　　　　　　　　成本高昂的网络升级需求减少，现有带宽和上行链路的利用率更高，因此可节约成本。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"DOS与DDOS","slug":"systemstructure/security/dosandddos","date":"2020-08-15T15:34:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/security/dosandddos.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171524DDoS-Attack.jpg","content":"<p>　TCP报头中一共有六个标志位：URG/ACK/PSH/RST/SYN/FIN。<br>SYN<br>　　表示建立一个方向的连接。<br>ACK<br>　　收到数据或请求后发送响应时发送ACK报文。<br>RST<br>　　关闭异常连接<br>FIN<br>　　表示关闭连接 　<br>PSH<br>　　　发送端需要发送一段数据，这个数据需要接收端一收到就进行向上交付。而接收端在收到PSH标志位有效的数据时，迅速将数据交付给应用层。所以PSH又叫急迫比特。<br>　　　但是现在已经不需要将数据交付给应用层了，因为这些效果在TCP栈已经可以自行处理这些问题了。<br>URG<br>　　URG成为紧急指针，意为URG位有效的数据包，是一个紧急需要处理的数据包，需要接收端在接收到之后迅速处理。</p>\n<p>dos全称是denial of service，dos攻击是使目标计算机或网络无法提供正常服务(拒绝服务)</p>\n<p>产生dos攻击效果的方式有很多</p>\n<p>syn攻击</p>\n<p>半连接攻击，向服务器端连续发送大量只有SYN标志的TCP链接请求，服务器会吧这些半连接排到链接缓冲区(Backlog queue)中，缓冲区满，无法接受新的请求，其他合法用户的请求就会被拒绝</p>\n<p>rst攻击</p>\n<p>自己攻击自己</p>\n<p>消耗资源攻击(带宽、磁盘等)</p>\n<p>泛洪攻击(flood)发送大量报文syc、ack、rst、udp、icmp、dns、http/https等</p>\n<p>反射攻击，伪装成被攻击对象向其它机器发送请求，其他机器响应请求，发送大量报文给攻击目标，从而早成攻击目标的性能耗尽一般用udp报文，因为udp的响应报文比请求报文更大，能实现攻击流量放大的作用</p>\n<p>畸形报文攻击</p>\n<p>发送大量有缺陷或者特殊控制作用的报文，造成主机处理报文时系统崩溃</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"获取系统信息","slug":"systemstructure/security/linuxinfo","date":"2020-09-09T15:40:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/security/linuxinfo.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171571Linux-system-info-Tools.jpg","content":"<h3 id=\"版本信息\"><a href=\"#版本信息\" class=\"headerlink\" title=\"版本信息\"></a>版本信息</h3><h4 id=\"uname工具\"><a href=\"#uname工具\" class=\"headerlink\" title=\"uname工具\"></a>uname工具</h4><p>uname工具是对sys/utsname函数的一个封装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a或--all：显示全部的信息；</span><br><span class=\"line\">-m或--machine：显示电脑类型；</span><br><span class=\"line\">-n或-nodename：显示在网络上的主机名称；</span><br><span class=\"line\">-r或--release：显示操作系统的发行编号；</span><br><span class=\"line\">-s或--sysname：显示操作系统名称；</span><br><span class=\"line\">-v：显示操作系统的版本；</span><br><span class=\"line\">-p或--processor：输出处理器类型或&quot;unknown&quot;；</span><br><span class=\"line\">-i或--hardware-platform：输出硬件平台或&quot;unknown&quot;；</span><br><span class=\"line\">-o或--operating-system：输出操作系统名称；</span><br></pre></td></tr></table></figure>\n\n<p>简单实例如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;sys/utsname.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">utsname</span> <span class=\"title\">uts</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Put information about the system in NAME.  */</span></span><br><span class=\"line\">    uname(&amp;uts);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name=%s\\n&quot;</span>,uts.sysname);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;version=%s\\n&quot;</span>,uts.version);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;release=%s\\n&quot;</span>,uts.release);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nodename=%s\\n&quot;</span>,uts.nodename);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;machine=%s\\n&quot;</span>,uts.machine);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**out：</span></span><br><span class=\"line\"><span class=\"comment\">    name=Linux</span></span><br><span class=\"line\"><span class=\"comment\">\tversion=#29~20.04.1-Ubuntu SMP Mon Aug 01 20:58:17 UTC 2021</span></span><br><span class=\"line\"><span class=\"comment\">\trelease=5.11.0-27-generic</span></span><br><span class=\"line\"><span class=\"comment\">\tnodename=longtaoXiaoXinPro13-2020</span></span><br><span class=\"line\"><span class=\"comment\">\tmachine=x86_64 </span></span><br><span class=\"line\"><span class=\"comment\">\t**/</span></span><br></pre></td></tr></table></figure>\n\n<p>utsname结构体如下,如果定义了_GNU_SOURCE还可以再打印个domainname</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">utsname</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Name of the implementation of the operating system.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> sysname[_UTSNAME_SYSNAME_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Name of this node on the network.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> nodename[_UTSNAME_NODENAME_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Current release level of this implementation.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> release[_UTSNAME_RELEASE_LENGTH];</span><br><span class=\"line\">    <span class=\"comment\">/* Current version level of this release.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> version[_UTSNAME_VERSION_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Name of the hardware type the system is running on.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> machine[_UTSNAME_MACHINE_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> _UTSNAME_DOMAIN_LENGTH - 0</span></span><br><span class=\"line\">    <span class=\"comment\">/* Name of the domain of this node on the network.  */</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">ifdef</span> __USE_GNU</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> domainname[_UTSNAME_DOMAIN_LENGTH];</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> __domainname[_UTSNAME_DOMAIN_LENGTH];</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"通过文件查看\"><a href=\"#通过文件查看\" class=\"headerlink\" title=\"通过文件查看\"></a>通过文件查看</h4><h5 id=\"内核信息\"><a href=\"#内核信息\" class=\"headerlink\" title=\"内核信息\"></a>内核信息</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;proc&#x2F;version</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"发行信息\"><a href=\"#发行信息\" class=\"headerlink\" title=\"发行信息\"></a>发行信息</h5><p>简要</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;etc&#x2F;issue</span><br></pre></td></tr></table></figure>\n\n<p>完整</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;etc&#x2F;*-release</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"CPU信息\"><a href=\"#CPU信息\" class=\"headerlink\" title=\"CPU信息\"></a>CPU信息</h5><p>lscpu命令或</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure>\n\n<p>除此之外还可以获取一些其他信息</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ ls /proc|grep info</span><br><span class=\"line\">buddyinfo </span><br><span class=\"line\">cpuinfo</span><br><span class=\"line\">meminfo</span><br><span class=\"line\">pagetypeinfo</span><br><span class=\"line\">slabinfo</span><br><span class=\"line\">vmallocinfo</span><br><span class=\"line\">zoneinfo</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"内存信息\"><a href=\"#内存信息\" class=\"headerlink\" title=\"内存信息\"></a>内存信息</h5><p>lsmem命令或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;proc&#x2F;memeinfo</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"其他信息\"><a href=\"#其他信息\" class=\"headerlink\" title=\"其他信息\"></a>其他信息</h5><p>buddyindo物理内存debug信息，lunux使用buddy算法解决物理内存的碎片问题</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ cat /proc/buddyinfo </span><br><span class=\"line\">Node 0, zone      DMA      1      0      0      1      2      1      1      0      1      2      2 </span><br><span class=\"line\">Node 0, zone    DMA32   2261   1007    541    301    455    234     60     24     12      4    321 </span><br><span class=\"line\">Node 0, zone   Normal   1120    593    346    660    116     36     32      6      5      4      1</span><br></pre></td></tr></table></figure>\n\n<p>zoneinfo显示内存空间的统计信息，对分析虚拟内存行为很有用</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"网络查询、嗅探","slug":"systemstructure/security/netoperate","date":"2020-09-26T15:00:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/security/netoperate.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171718Computer-Networking-Featured.jpg","content":"<p>[toc]</p>\n<h4 id=\"查自己的公网ip\"><a href=\"#查自己的公网ip\" class=\"headerlink\" title=\"查自己的公网ip\"></a>查自己的公网ip</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ curl http://members.3322.org/dyndns/getip</span><br><span class=\"line\">150.118.52.133</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 或者</span></span><br><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ curl ip.</span><br><span class=\"line\">150.118.52.133</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询域名的ip地址\"><a href=\"#查询域名的ip地址\" class=\"headerlink\" title=\"查询域名的ip地址\"></a>查询域名的ip地址</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ nslookup www.baidu.com</span><br><span class=\"line\">Server:\t\t127.0.0.53 #dns服务器</span><br><span class=\"line\">Address:\t127.0.0.53#53</span><br><span class=\"line\"></span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">www.baidu.com\tcanonical name = www.a.shifen.com.# 域名实际对应的主机名记录</span><br><span class=\"line\">Name:\twww.a.shifen.com </span><br><span class=\"line\">Address: 150.101.49.12 #域名负载均衡</span><br><span class=\"line\">Name:\twww.a.shifen.com</span><br><span class=\"line\">Address: 150.101.49.11</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询目标ip对应的mac地址\"><a href=\"#查询目标ip对应的mac地址\" class=\"headerlink\" title=\"查询目标ip对应的mac地址\"></a>查询目标ip对应的mac地址</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 用ping获取arp缓存再查找</span></span><br><span class=\"line\">[root@localhost ~]# ping 127.0.1.21 -c 1 &gt;&gt; /dev/null;arp -a 127.0.1.21|awk -F &quot; &quot; &#x27;&#123;print $4&#125;&#x27;</span><br><span class=\"line\">14:02:ec:32:cc:24</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改网卡mac地址\"><a href=\"#修改网卡mac地址\" class=\"headerlink\" title=\"修改网卡mac地址\"></a>修改网卡mac地址</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig eth0 hw ether B3:00:00:00:00:A2#临时修改</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"嗅探目标ip的信息\"><a href=\"#嗅探目标ip的信息\" class=\"headerlink\" title=\"嗅探目标ip的信息\"></a>嗅探目标ip的信息</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 嗅探目标ip端口开发情况</span></span><br><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ sudo nmap -PS 180.101.49.12</span><br><span class=\"line\">Starting Nmap 7.80 ( https://nmap.org ) at 2021-08-20 15:08 CST</span><br><span class=\"line\">Nmap scan report for 180.101.49.12</span><br><span class=\"line\">Host is up (0.0079s latency).</span><br><span class=\"line\">Not shown: 998 filtered ports</span><br><span class=\"line\">PORT    STATE SERVICE</span><br><span class=\"line\">80/tcp  open  http</span><br><span class=\"line\">443/tcp open  https</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 嗅探目标ip系统信息</span></span><br><span class=\"line\">sudo nmap -O 180.101.49.12</span><br><span class=\"line\">tarting Nmap 7.80 ( https://nmap.org ) at 2021-08-20 14:59 CST</span><br><span class=\"line\">Nmap scan report for 180.101.49.12</span><br><span class=\"line\">Host is up (0.0084s latency).</span><br><span class=\"line\">Not shown: 998 filtered ports</span><br><span class=\"line\">PORT    STATE SERVICE</span><br><span class=\"line\">80/tcp  open  http</span><br><span class=\"line\">443/tcp open  https</span><br><span class=\"line\">Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port</span><br><span class=\"line\">Aggressive OS guesses: Linux 2.6.18 - 2.6.22 (92%), D-Link DWL-624+ or DWL-2000AP, or TRENDnet TEW-432BRP WAP (90%), OneAccess 1641 router (90%), 3Com SuperStack 3 Switch 3870 (88%), HP ProCurve 2524 switch or 9100c Digital Sender printer (86%), Blue Coat PacketShaper appliance (86%), Satel ETHM-2 intruder alarm (86%), Apple TV 5.2.1 or 5.3 (86%), AVtech Room Alert 26W environmental monitor (85%)</span><br><span class=\"line\">No exact OS matches for host (test conditions non-ideal).</span><br><span class=\"line\"></span><br><span class=\"line\">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class=\"line\">Nmap done: 1 IP address (1 host up) scanned in 9.61 seconds</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 扫描整个网段所有ip</span></span><br><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ nmap  172.20.65.0/24</span><br><span class=\"line\">Starting Nmap 7.80 ( https://nmap.org ) at 2021-08-20 15:12 CST</span><br><span class=\"line\">Nmap scan report for 172.20.65.50</span><br><span class=\"line\">Host is up (0.00048s latency).</span><br><span class=\"line\">Not shown: 998 closed ports</span><br><span class=\"line\">PORT   STATE SERVICE</span><br><span class=\"line\">22/tcp open  ssh</span><br><span class=\"line\">80/tcp open  http</span><br><span class=\"line\"></span><br><span class=\"line\">Nmap scan report for 172.20.65.62</span><br><span class=\"line\">Host is up (0.00022s latency).</span><br><span class=\"line\">Not shown: 996 closed ports</span><br><span class=\"line\">PORT     STATE SERVICE</span><br><span class=\"line\">22/tcp   open  ssh</span><br><span class=\"line\">80/tcp   open  http</span><br><span class=\"line\">8080/tcp open  http-proxy</span><br><span class=\"line\">8888/tcp open  sun-answerbook</span><br><span class=\"line\"></span><br><span class=\"line\">Nmap scan report for 172.20.65.77</span><br><span class=\"line\">Host is up (0.00023s latency).</span><br><span class=\"line\">Not shown: 998 closed ports</span><br><span class=\"line\">PORT   STATE SERVICE</span><br><span class=\"line\">22/tcp open  ssh</span><br><span class=\"line\">80/tcp open  http</span><br><span class=\"line\"></span><br><span class=\"line\">Nmap scan report for 172.20.65.84</span><br><span class=\"line\">Host is up (0.00046s latency).</span><br><span class=\"line\">Not shown: 997 closed ports</span><br><span class=\"line\">PORT    STATE SERVICE</span><br><span class=\"line\">22/tcp  open  ssh</span><br><span class=\"line\">80/tcp  open  http</span><br><span class=\"line\">999/tcp open  garcon</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"模拟发包\"><a href=\"#模拟发包\" class=\"headerlink\" title=\"模拟发包\"></a>模拟发包</h4><p>使用hping3模拟发包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c --count count 发送数据包的次数</span><br><span class=\"line\">-i --interval 包发送间隔时间（单位是毫秒）缺省时间是1秒</span><br><span class=\"line\">-n -nmeric 数字输出，象征性输出主机地址。</span><br><span class=\"line\">-I --interface 网络接口名如eth0。</span><br><span class=\"line\">-v --verbose 显示很多信息，</span><br><span class=\"line\">-D --debug 进入debug模式</span><br><span class=\"line\">-z --bind 快捷键的使用。</span><br><span class=\"line\">-Z --unbind 消除快捷键。</span><br><span class=\"line\">-O --rawip RAWIP模式，在此模式下HPING会发送带数据的IP头。</span><br><span class=\"line\">-1 --icmp ICMP模式，此模式下HPING会发送IGMP应答报，你可以用--ICMPTYPE --ICMPCODE选项发送其他类型/模式的ICMP报文。</span><br><span class=\"line\">-2 --udp UDP 模式，缺省下，HPING会发送UDP报文到主机的0端口，你可以用--baseport --destport --keep选项指定其模式。</span><br><span class=\"line\">-9 --listen signatuer hping的listen模式，用此模式，HPING会接收指定的数据。</span><br><span class=\"line\">-a --spoof hostname 伪造IP攻击，防火墙就不会记录你的真实IP了，当然回应的包你也接收不到了。</span><br><span class=\"line\">-t --ttl time to live 可以指定发出包的TTL值。</span><br><span class=\"line\">-H --ipproto 在RAW IP模式里选择IP协议。</span><br><span class=\"line\">-w --WINID UNIX ,WINDIWS的id回应不同的，这选项可以让你的ID回应和WINDOWS一样。</span><br><span class=\"line\">-r --rel 更改ID的，可以让ID曾递减输出，详见HPING-HOWTO。</span><br><span class=\"line\">-F --FRAG 更改包的FRAG，这可以测试对方对于包碎片的处理能力，缺省的“virtual mtu”是16字节。</span><br><span class=\"line\">-x --morefrag 此功能可以发送碎片使主机忙于恢复碎片而造成主机的拒绝服务。</span><br><span class=\"line\">-y -dontfrag 发送不可恢复的IP碎片，这可以让你了解更多的MTU PATH DISCOVERY。</span><br><span class=\"line\">-G --fragoff fragment offset value set the fragment offset</span><br><span class=\"line\">-m --mtu mtu value 用此项后ID数值变得很大，50000没指定此项时3000-20000左右。</span><br><span class=\"line\">-G --rroute 记录路由，可以看到详悉的数据等等，最多可以经过9个路由，即使主机屏蔽了ICMP报文</span><br><span class=\"line\">-C --ICMPTYPE type 指定ICMP类型，缺省是ICMP echo REQUEST</span><br><span class=\"line\">-K --ICMPCODE CODE 指定ICMP代号，缺省0</span><br><span class=\"line\">--icmp-ipver 把IP版本也插入IP头</span><br><span class=\"line\">--icmp-iphlen 设置IP头的长度，缺省为5（32字节）</span><br><span class=\"line\">--icmp-iplen 设置IP包长度</span><br><span class=\"line\">-s --baseport source port hping 用源端口猜测回应的包</span><br><span class=\"line\">-p --deskport [+][+]desk port 设置目标端口，缺省为0，一个加号设置为:每发送一个请求包到达后，端口加1，两个加号为：每发一个包，端口数加1</span><br><span class=\"line\">-w --win 发windows包，64BYTE</span><br><span class=\"line\">-O --tcpoff 设置tcp偏移</span><br><span class=\"line\">-m --tcpseq 设置TCP序列数</span><br><span class=\"line\">-l --tcpck 设置TCP ack</span><br><span class=\"line\">-Q --seqnum 搜集序列号</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"硬盘IO性能估算(IOPS,吞吐量，延时)","slug":"systemstructure/storage/diskperformanceestimation","date":"2021-04-29T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/storage/diskperformanceestimation.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171774R-C.b15aac80564d038ed359e47a066f891d?rik=VW2MMdB7BnKcXw&riu=http%3a%2f%2fsfwallpaper.com%2fimages%2fhdd-wallpaper-12.jpg&ehk=FjTRXCjxUHy0umSxoAK5tGP5r11SxPO17XwKdagy56I%3d&risl=&pid=ImgRaw&r=0","content":"<h1 id=\"硬盘IO性能估算-IOPS-吞吐量，延时\"><a href=\"#硬盘IO性能估算-IOPS-吞吐量，延时\" class=\"headerlink\" title=\"硬盘IO性能估算(IOPS,吞吐量，延时)\"></a>硬盘IO性能估算(IOPS,吞吐量，延时)</h1><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p><strong>磁盘种类</strong></p>\n<p>硬盘有<strong>固态硬盘</strong>(SSD 盘，新式硬盘)、<strong>机械硬盘</strong>(HDD 传统硬盘)、<strong>混合硬盘</strong>(HHD 一块基于传统机械硬盘诞生出来的新硬盘)。SSD采用闪存颗粒来储存，HDD采用磁性碟片来储存，混合硬盘(HHD: Hybrid Hard Disk)是把磁性硬盘和闪存集成到一起的一种硬盘。</p>\n<p><strong>容量</strong></p>\n<p>硬盘的容量以兆字节(MB/MiB)、千兆字节(GB/GiB)或百万兆字节(TB/TiB)为单位，而常见的换算式为：1TB=1024GB,1GB=1024MB而1MB=1024KB。但硬盘厂商通常运用的是GB，也就是1G=1000MB，而Win系统，就依旧以“GB”字样来表示“GiB”单位(1024换算的)，因此我们在BIOS中或在格式化硬盘时看到的容量会比厂家的标称值要小。</p>\n<p><strong>转速</strong>（Rotational Speed 或Spindle speed）</p>\n<p>RPM是Revolutions Per minute的缩写，是转/每分钟。RPM值越大，内部传输率就越快，访问时间就越短，硬盘的整体性能也就越好。</p>\n<p><strong>寻道时间</strong> Tseek是指将读写磁头移动至正确的磁道上所需要的时间。寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms。</p>\n<p><strong>旋转延迟</strong> Trotation是指盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间。旋转延迟取决于磁盘转速，通常使用磁盘旋转一周所需时间的1/2表示。</p>\n<p><strong>数据传输时间</strong> Ttransfer是指完成传输所请求的数据所需要的时间，它取决于数据传输率，其值等于数据大小除以数据传输率。目前IDE/ATA能达到133MB/s，SATA II可达到300MB/s的接口数据传输率，数据传输时间通常远小于前两部分消耗时间。简单计算时可忽略。</p>\n<p><strong>IOPS</strong></p>\n<p>每秒处理的IO次数</p>\n<p><strong>RPM</strong></p>\n<p>转速</p>\n<h3 id=\"性能估算\"><a href=\"#性能估算\" class=\"headerlink\" title=\"性能估算\"></a>性能估算</h3><p><strong>寻道时间估算</strong></p>\n<p>磁头移动到对应磁道上的耗时。</p>\n<p> SATA 7200RPM，平均寻道时间是9ms。</p>\n<p> SAS 10000RPM，平均寻道时间是6ms。 </p>\n<p>SAS 15000RPM，平均寻道时间是4ms。</p>\n<p>具体查看磁盘供应商提供数据。</p>\n<p><strong>旋转延时估算</strong></p>\n<p>平均为磁盘旋转一周所需时间的一半<br>$$<br>旋转延时=60*1000/RPM/2<br>$$<br><strong>传输时间</strong></p>\n<p> 平均数据大小除以接口传输率，耗时很小粗略计算可以忽略。 SATA，300<del>600MB/s。 SAS，3Gbit/s。 FC，2</del>4Gbit/s。 NVME，32Gbit/s。</p>\n<p><strong>吞吐量估算</strong><br>$$<br>I/O 吞吐量(一秒内)＝ IOPS* 平均 I/O SIZE<br>$$<br><strong>IOPS估算</strong><br>$$<br>IOPS = 1000 ms/ (寻道时间 + 旋转延迟)\\<br>物理磁盘总的IOPS = 物理磁盘的IOPS × 磁盘数目\\<br>可用的IOPS = （物理磁盘总的IOPS × 写百分比 ÷ RAID写惩罚） + （物理磁盘总的IOPS × 读百分比）<br>$$<br>其中</p>\n<p><strong>RAID-0：</strong>直接的条带，数据每次写入对应物理磁盘上的一次写入，写惩罚值是1。</p>\n<p><strong>RAID-1和10</strong>：RAID-1 和RAID-10的写惩罚很简单理解，因为数据的镜像存在的，所以一次写入会有两次，写惩罚值是2。</p>\n<p><strong>RAID-5：</strong>RAID-5由于要计算校验位的机制存在，需要读数据、读校验位、写数据、写校验位四个步骤，所以RAID-5的写惩罚值是4。</p>\n<p><strong>RAID-6：</strong>RAID-6由于有两个校验位的存在，与RAID-5相比，需要读取两次校验位和写入两次校验位，所以RAID-6的写惩罚值是6。</p>\n<p><strong>iops估算raid盘数</strong></p>\n<ol>\n<li><p>如果单盘不能满足性能需求，需要通过Raid实现，计算所需硬盘数公式如下。 Raid1、10，Drive IOPS = Read IOPS + 2<em>Write IOPS Raid3、5，Drive IOPS = Read IOPS + 4</em>Write IOPS Raid6，Drive IOPS = Read IOPS + 6*Write IOPS；</p>\n</li>\n<li><p>设需要IOPS 5000，读写比例2:1，则RAID10后IOPS需求为。 RAID10，(2/3) * 5000 + 2 * (1/3) * 5000 = 6666 IOPS；</p>\n</li>\n<li><p>已知SAS 15000RPM机械硬盘IOPS165。 5000IOPS所需硬盘个数, 6666 / 165 = 40。</p>\n</li>\n</ol>\n<p><strong>SSD硬盘IO估算</strong></p>\n<p>固态硬盘没有寻道时间和旋转时间。IO耗时是通过地址查找数据耗时，根据芯片颗粒SLC、MLC，中控芯片、队列深度32~64、接口SATA、PCIE的不同，一般负载非太高时是相对固定值（控制在60%利用率）。 IOPS = 1000 / IO耗时。因为SSD比较固定，比如Intel 320 SSD对8K avgrq-sz耗时0.1ms，1000/0.1ms=10000 IOPS。具体参考后续文章。</p>\n<p><strong>常见存储设备参考性能</strong></p>\n<p>5400 RPM SATA，60 IOPS </p>\n<p>7200 RPM SATA，70 IOPS </p>\n<p>10000 RPM SAS，110 IOPS </p>\n<p>15000 RPM SAS，150 IOPS，Sequential RW 180MB/s、Radom RW 15MB/s。 </p>\n<p>10000 RPM FC，125 IOPS </p>\n<p>15000 RPM FC，150 IOPS</p>\n<p> SSD SATA，3000~40000 IOPS，R 400MB/s、W 250MB/s。 </p>\n<p>SSD PCIE，20000~40000 IOPS，R 500MB/s、W 300MB/s。 </p>\n<p>内存，1000000+ IOPS，30~60 GB/s。</p>\n<h3 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h3><p>对于随机负载，当遇到余下情况时，我们那通常认为存在 I/O 性能问题：</p>\n<ol>\n<li><p>平均读时间大于 15ms</p>\n</li>\n<li><p>在具有写 cache 的条件下，平均写时间大于 2.5ms</p>\n</li>\n</ol>\n<p>对于顺序负载，当遇到余下情况时，我们那通常认为存在 I/O 性能问题：</p>\n<ol start=\"3\">\n<li><p>在一个磁盘上有两个连续的 I/O 流</p>\n</li>\n<li><p>吞吐量不足（即远远小于磁盘 I/O 带宽）</p>\n</li>\n</ol>\n<p>对于一块磁盘来讲，随着 IOPS 数量的增加，I/O service 也会增加，并且会有一个饱和点，即 IOPS 达到某个点以后，IOPS 再增加将会引起 I/O service time 的显著增加。</p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p><strong>判断是ssd还是hdd</strong></p>\n<ol>\n<li>```shell<br>cat /sys/block/*/queue/rotational<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. &#96;&#96;&#96;shell</span><br><span class=\"line\">   lsblk -d -o name,rota</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>0为ssd，1为hdd</p>\n<p><strong>查看磁盘转速</strong></p>\n<ol>\n<li><pre><code>sginfo -g /dev/*\n</code></pre>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"幂等","slug":"systemstructure/web/idempotent","date":"2020-10-23T15:28:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/web/idempotent.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171881678d01b11450c9eb195769dab8e691c6.png","content":"<p>[toc]</p>\n<h2 id=\"幂等去重\"><a href=\"#幂等去重\" class=\"headerlink\" title=\"幂等去重\"></a>幂等去重</h2><p>最近计算节点网络异常时经常出现请求未响应问题，之前的做法是在接收到任务之后与原先存在的任务做比较,进而判断是否为同一个请求的重试，</p>\n<p>主流的MQ实现在 <code>autocommit=true</code> 时天然实现了幂等</p>\n<p>但考虑业务处理可能出错的情况我们一般会将autocommit设置成false，在业务处理成功后再提交，这时就需要使用上述幂等方案了</p>\n<p>在接收到消息时写入请求Token以实现去重判断（Token可为Topic+Offset）提交后删除Token，整体上可以做到对业务透明</p>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><ol>\n<li>没有副作用</li>\n</ol>\n<h3 id=\"什么是幂等性\"><a href=\"#什么是幂等性\" class=\"headerlink\" title=\"什么是幂等性\"></a>什么是幂等性</h3><ol>\n<li>数学表述， 多次调用仍为自身，</li>\n<li>不产生副作用</li>\n<li>带上uuid识别是否是相同的请求，避免重复请求</li>\n<li>ACID 2.0 解释，与分布式中的ACID辨析</li>\n<li>stateless 无状态 何时使用，对内维护状态，对外接口无状态+异步。</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]}]}