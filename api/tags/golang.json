{"name":"golang","postlist":[{"title":"go的内置包","slug":"language/golang/built-inpackage","date":"2019-07-19T14:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/built-inpackage.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635134047ground-squirrel-5831591__340.jpg","content":"<h2 id=\"库与包\"><a href=\"#库与包\" class=\"headerlink\" title=\"库与包\"></a>库与包</h2><h4 id=\"archive\"><a href=\"#archive\" class=\"headerlink\" title=\"archive\"></a>archive</h4><h5 id=\"tar包：负责打包、解包-注意tar不负责压缩和解压\"><a href=\"#tar包：负责打包、解包-注意tar不负责压缩和解压\" class=\"headerlink\" title=\"tar包：负责打包、解包,注意tar不负责压缩和解压\"></a>tar包：负责打包、解包,注意tar不负责压缩和解压</h5><p>打包实现原理</p>\n<p>先创建一个文件x.tar，然后向x.tar写入tar头部信息。打开要被tar的文件，向x.tar写入头部信息，然后向x.tar写入文件信息。重复第二步直到所有文件都被写入到x.tar中，关闭x.tar，整个过程就这样完成了</p>\n<p>解包实现原理</p>\n<p>先打开tar文件，然后从这个tar头部中循环读取存储在这个归档文件内的文件头信息，从这个文件头里读取文件名，以这个文件名创建文件，然后向这个文件里写入数据</p>\n<h5 id=\"zip包：打包、解包，并进行压缩\"><a href=\"#zip包：打包、解包，并进行压缩\" class=\"headerlink\" title=\"zip包：打包、解包，并进行压缩\"></a>zip包：打包、解包，并进行压缩</h5><p>压缩实现原理</p>\n<p>工具类：bufio、bytes、string、path、strconv、io/ioutils等，没有领域知识，比较简单</p>\n<p>系统包：os、net、sync、fmt</p>\n<h2 id=\"linux-说明\"><a href=\"#linux-说明\" class=\"headerlink\" title=\"linux 说明\"></a>linux 说明</h2><h4 id=\"linux文件头信息-标志\"><a href=\"#linux文件头信息-标志\" class=\"headerlink\" title=\"linux文件头信息(标志)\"></a>linux文件头信息(标志)</h4><p>使用file命令可以查看文件类型</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# file test ./test/1</span><br><span class=\"line\">test:     directory</span><br><span class=\"line\">./test/1: ASCII text</span><br></pre></td></tr></table></figure>\n\n\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"golang","path":"api/tags/golang.json"}]},{"title":"go逃逸分析","slug":"language/golang/escapeanalysis","date":"2021-05-08T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/escapeanalysis.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635134114header.jpg","content":"<p>[toc]</p>\n<h2 id=\"go逃逸分析\"><a href=\"#go逃逸分析\" class=\"headerlink\" title=\"go逃逸分析\"></a>go逃逸分析</h2><h3 id=\"什么是逃逸\"><a href=\"#什么是逃逸\" class=\"headerlink\" title=\"什么是逃逸\"></a>什么是逃逸</h3><p>内存从栈逃逸到堆中，会增大GC的压力</p>\n<h3 id=\"为什么要做逃逸分析\"><a href=\"#为什么要做逃逸分析\" class=\"headerlink\" title=\"为什么要做逃逸分析\"></a>为什么要做逃逸分析</h3><p>申请到栈内存性能好，不会引起GC，函数返回直接释放</p>\n<p>申请到堆内存会导致gc，引起性能问题</p>\n<p>如何分配：</p>\n<ol>\n<li>如果函数外部没有引用，则优先放到栈中；</li>\n<li>如果函数外部存在引用，则必定放到堆中；</li>\n</ol>\n<p>常见的三种逃逸</p>\n<h3 id=\"指针逃逸\"><a href=\"#指针逃逸\" class=\"headerlink\" title=\"指针逃逸\"></a>指针逃逸</h3><p>函数返回局部变量的指针导致指针逃逸</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pointerEscapeFunc</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v <span class=\"keyword\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;v</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pointerEscapeFunc()<span class=\"comment\">//v会被分配到堆上</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">host$</span><span class=\"bash\"> go build -gcflags <span class=\"string\">&#x27;-m -l&#x27;</span> tem.go <span class=\"comment\">#-m打印信息，-l忽略inline信息</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> command-line-arguments</span></span><br><span class=\"line\">./tem.go:3:6: moved to heap: v #可见v被分配到了堆上</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栈空间不足\"><a href=\"#栈空间不足\" class=\"headerlink\" title=\"栈空间不足\"></a>栈空间不足</h3><p>go的goroutine初始栈大小为2KB，go可以增大栈大小，但不可超过系统栈限制(使用<code>ulimit -s</code>查看)，超过一定大小的变量将会逃逸到堆上，不同go版本大小限制不同</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stackSpaceExhausted</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    v := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>,<span class=\"number\">0</span>,<span class=\"number\">10000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    stackSpaceExhausted()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">host$</span><span class=\"bash\"> go build -gcflags <span class=\"string\">&#x27;-m -l&#x27;</span> tem.go</span> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> command-line-arguments</span></span><br><span class=\"line\">./tem.go:3:11: make([]int, 0, 10000) escapes to heap # 可见逃逸到了堆上，go1.15</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"闭包引用\"><a href=\"#闭包引用\" class=\"headerlink\" title=\"闭包引用\"></a>闭包引用</h3><p>函数类型也分两种，一种是函数字面量类型（未命名类型,func literal），另一种是函数命名类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">outer</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a <span class=\"keyword\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>&#123;</span><br><span class=\"line\">        a++</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    inner := outer()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(inner())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">host$</span><span class=\"bash\"> go build -gcflags <span class=\"string\">&#x27;-m -l&#x27;</span> tem.go</span> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> command-line-arguments</span></span><br><span class=\"line\">./tem.go:3:6: moved to heap: a</span><br><span class=\"line\">./tem.go:4:9: func literal escapes to heap</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p>对象大小不确定或作为不确定大小的参数时发生逃逸</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a <span class=\"keyword\">int</span></span><br><span class=\"line\">    fmt.Println(a)<span class=\"comment\">//fmt.Println的入参是...interface&#123;&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">host$</span><span class=\"bash\"> go build -gcflags <span class=\"string\">&#x27;-m -l&#x27;</span> tem.go</span> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> command-line-arguments</span></span><br><span class=\"line\">./tem.go:7:13: main ... argument does not escape</span><br><span class=\"line\">./tem.go:7:13: a escapes to heap</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"逃逸分析使用\"><a href=\"#逃逸分析使用\" class=\"headerlink\" title=\"逃逸分析使用\"></a>逃逸分析使用</h3><p>传值会拷贝对象，增加对象拷贝开销(听君一席话，胜似一席话)，只读切内存小的结构体使用可以提高性能</p>\n<p>传指针会导致内存逃逸到堆中，增加垃圾回收(GC)负担,对象需要频繁创建删除时，GC开销会特别大，影响性能，但在需要修改对象值、内存占用大的结构体中，传指针性能更好</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"golang","path":"api/tags/golang.json"}]},{"title":"golang实现rsa加解密","slug":"language/golang/implementrsa","date":"2021-07-23T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/implementrsa.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138256OIP-C.UcxtcvLrH_YFbKaHBdoF5wHaFG?w=250&h=180&c=7&r=0&o=5&dpr=2.5&pid=1.7","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ol>\n<li><p>数字签名</p>\n</li>\n<li><p>加解密</p>\n</li>\n<li><p>对称</p>\n</li>\n<li><p>非对称</p>\n</li>\n<li><p>RSA算法</p>\n</li>\n</ol>\n<p>大整数的因数分解，是一件非常困难的事情（对目前的计算机算力和数学方法来说）。我们可以以此为数据加解密</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//publicKey, privateKey := generateKey(999773, 999959)</span></span><br><span class=\"line\">\tpublicKey, privateKey := generateKey(<span class=\"number\">7001</span>, <span class=\"number\">7079</span>)</span><br><span class=\"line\">\ttxt := <span class=\"string\">&quot;password&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;publicKey&quot;</span>,publicKey)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;privateKey&quot;</span>, privateKey)</span><br><span class=\"line\">\tencode := rsaEnCode(publicKey, txt)</span><br><span class=\"line\">\tfmt.Println(encode)</span><br><span class=\"line\">\tdecode := rsaDeCode(privateKey, encode)</span><br><span class=\"line\">\tfmt.Println(decode)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//gcd 最大公约数greatest common divisor,辗转相除法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcd</span><span class=\"params\">(x, y <span class=\"keyword\">uint64</span>)</span> <span class=\"title\">uint64</span></span> &#123;</span><br><span class=\"line\">\ttmp := x % y</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> tmp &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> gcd(y, tmp)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//lcm 最小公倍数least common multiple，公式法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lcm</span><span class=\"params\">(x, y <span class=\"keyword\">uint64</span>)</span> <span class=\"title\">uint64</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x * y / gcd(x, y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//generateKey 生成密钥</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateKey</span><span class=\"params\">(a, b <span class=\"keyword\">uint64</span>)</span> <span class=\"params\">([2]<span class=\"keyword\">uint64</span>, [2]<span class=\"keyword\">uint64</span>)</span></span> &#123;</span><br><span class=\"line\">\tpublicKey := [<span class=\"number\">2</span>]<span class=\"keyword\">uint64</span>&#123;&#125;</span><br><span class=\"line\">\tprivateKey := [<span class=\"number\">2</span>]<span class=\"keyword\">uint64</span>&#123;&#125;</span><br><span class=\"line\">\tn := a * b</span><br><span class=\"line\">\tpublicKey[<span class=\"number\">0</span>] = n</span><br><span class=\"line\">\tprivateKey[<span class=\"number\">0</span>] = n</span><br><span class=\"line\"></span><br><span class=\"line\">\tl := lcm(a<span class=\"number\">-1</span>, b<span class=\"number\">-1</span>)</span><br><span class=\"line\">\te, err := getE(l)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\td, err := getD(e, l)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublicKey[<span class=\"number\">1</span>] = e</span><br><span class=\"line\">\tprivateKey[<span class=\"number\">1</span>] = d</span><br><span class=\"line\">\tfmt.Println(e)</span><br><span class=\"line\">\tfmt.Println(d)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> publicKey, privateKey</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取公钥参数e</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getE</span><span class=\"params\">(l <span class=\"keyword\">uint64</span>)</span> <span class=\"params\">(<span class=\"keyword\">uint64</span>, error)</span></span> &#123;</span><br><span class=\"line\">\te := l - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, errors.New(<span class=\"string\">&quot;no e founded&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> gcd(e, l) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> e, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\te--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取私钥参数d</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getD</span><span class=\"params\">(e, l <span class=\"keyword\">uint64</span>)</span> <span class=\"params\">(<span class=\"keyword\">uint64</span>, error)</span></span> &#123;</span><br><span class=\"line\">\td := l - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> d &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, errors.New(<span class=\"string\">&quot;no d founded&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e*d%l == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> e, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\td--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无符号64位整形求幂</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(a, b <span class=\"keyword\">uint64</span>)</span> <span class=\"title\">uint64</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tout := a</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tout *= a</span><br><span class=\"line\">\t\tb--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//rsa加密</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rsaEnCode</span><span class=\"params\">(publicKey [2]<span class=\"keyword\">uint64</span>, string2 <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tpp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>,<span class=\"number\">0</span>,<span class=\"built_in\">len</span>(string2))</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _,v :=<span class=\"keyword\">range</span> string2 &#123;</span><br><span class=\"line\">\t\tuint64String := <span class=\"keyword\">uint64</span>(v)</span><br><span class=\"line\">\t\tencodeUint := pow(uint64String, publicKey[<span class=\"number\">1</span>]) % publicKey[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tencodeString := strconv.FormatUint(encodeUint, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\tpp = <span class=\"built_in\">append</span>(pp, encodeString)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;rsaEncode&quot;</span>,fmt.Sprintf(strings.Join(pp,<span class=\"string\">&quot;,&quot;</span>)))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(strings.Join(pp,<span class=\"string\">&quot;,&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//rsa解密</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rsaDeCode</span><span class=\"params\">(publicKey [2]<span class=\"keyword\">uint64</span>, string2 <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\ttxtSlice := strings.Split(string2,<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;txt&quot;</span>,txtSlice,reflect.TypeOf(txtSlice))</span><br><span class=\"line\">\tpp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>,<span class=\"number\">0</span>,<span class=\"built_in\">len</span>(txtSlice))</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _,v :=<span class=\"keyword\">range</span> txtSlice &#123;</span><br><span class=\"line\">\t\tuint64String,_ := strconv.ParseUint(v,<span class=\"number\">10</span>,<span class=\"number\">64</span>)</span><br><span class=\"line\">\t\tencodeUint := pow(uint64String, publicKey[<span class=\"number\">1</span>]) % publicKey[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tencodeString := <span class=\"keyword\">string</span>(encodeUint)</span><br><span class=\"line\">\t\tfmt.Println(encodeUint,encodeString)</span><br><span class=\"line\">\t\tpp = <span class=\"built_in\">append</span>(pp, encodeString)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;rsaDecode&quot;</span>,pp,fmt.Sprintf(strings.Join(pp,<span class=\"string\">&quot;&quot;</span>)))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(strings.Join(pp,<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"PKCS1与PKCS8\"><a href=\"#PKCS1与PKCS8\" class=\"headerlink\" title=\"PKCS1与PKCS8\"></a>PKCS1与PKCS8</h2><p><strong>PKCS1：</strong>全名《Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications》最新版本2.2  <em>(rfc8017, 有兴趣的同学可以读一下)</em> ，从名称上可以看出它是针对RSA算法的一个规范。里面包含了RSA加密、解密、签名验签等所有的内容，当然也包含了私钥的格式。PKCS1的1.1版本是1991年发布的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN RSA PRIVATE KEY-----</span><br><span class=\"line\">...</span><br><span class=\"line\">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>\n\n\n\n<p> <strong>PKCS8：</strong>全名《Public-Key Cryptography Standards (PKCS) #8: Private-Key Information Syntax Specification》最新版本1.2，从名称上可以看出它是一个专门用来存储私钥的文件格式规范。PKCS1的1.2版本是2008年发布的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN PRIVATE KEY-----</span><br><span class=\"line\">...</span><br><span class=\"line\">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"将私钥PEM格式的文件转换为DER格式\"><a href=\"#将私钥PEM格式的文件转换为DER格式\" class=\"headerlink\" title=\"将私钥PEM格式的文件转换为DER格式\"></a>将私钥PEM格式的文件转换为DER格式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash# openssl rsa -in pkcs1.pem -out pkcs1.der -outform DER</span><br><span class=\"line\">bash# openssl pkcs8 -topk8 -inform PEM -in pkcs1.pem -outform DER -nocrypt -out pkcs8.der</span><br><span class=\"line\">bash# ls </span><br><span class=\"line\">pkcs1.der pkcs1.pem pkcs8.der pkcs8.pem</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对比两个der格式内容\"><a href=\"#对比两个der格式内容\" class=\"headerlink\" title=\"对比两个der格式内容\"></a>对比两个der格式内容</h3><p>使用hexdump查看内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat pkcs1.der | hexdump</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"PEM-和DER区别\"><a href=\"#PEM-和DER区别\" class=\"headerlink\" title=\"PEM 和DER区别\"></a>PEM 和DER区别</h4><p>PEM与DER有什么区别呢？其实PEM就是对DER的内容做了base64的编码并做了一下格式化的输出而已。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"密码学","path":"api/tags/密码学.json"},{"name":"golang","path":"api/tags/golang.json"},{"name":"算法","path":"api/tags/算法.json"}]},{"title":"Cobra Tutorial","slug":"language/golang/lib/cobra","date":"2021-10-31T12:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/lib/cobra.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211104/163600258520200309153711.png","content":"<h2 id=\"cobra\"><a href=\"#cobra\" class=\"headerlink\" title=\"cobra\"></a>cobra</h2><p>cobra 是go的cli框架，包含cli库和生成基于cobra cli应用的命令行工具</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>子命令，如<code>app server</code>、<code>app sub</code>等</li>\n<li>完整兼容POSIX的flag，包括长命名和短命名</li>\n<li>子命令的嵌套（子命令）</li>\n<li>全局、本地、级联三种flag</li>\n<li>好用的工具命令，如<code>cobra init appname</code>初始化cli程序,<code>cobra add cmdname</code>为cli程序增加子命令</li>\n<li>智能提示</li>\n<li>生成命令help，以及为每个flag、cmd生成<code>-h</code>，<code>--help</code>帮助</li>\n<li>生成自动补全功能</li>\n<li>生成man帮助文档</li>\n<li>命令别名</li>\n<li>自定义帮助、用法</li>\n<li>为达到saas的12-factor 可选择viper</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><code>go get -u github.com/spf13/cobra/cobra</code>会自动安装最新版本库和命令行工具，国内下不下来可以手动下载放到对应的文件夹中，然后就可以在你的code里应用它<code>import &quot;github.com/spf13/cobra&quot;</code></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>cobra主要管理commands、args、flags，commands代表一个命令或动作，一般用动词命名，args代表输入的参数，一般用名词命名，flags是对commands的修饰，一般用形容词命名；好的cli应用应该学习成本低，用户容易理解 cli的含义，git的例子能很好的说明这一点: <code>git clone URL --bare</code> ，clone是commands是动词，URL是args是你的输入，bare是flag是形容词</p>\n<h3 id=\"commands\"><a href=\"#commands\" class=\"headerlink\" title=\"commands\"></a>commands</h3><p>commands是cli应用的核心，每次交互都包含在一个command中，command可以拥有可选的子命令（sub commands）</p>\n<h3 id=\"flags\"><a href=\"#flags\" class=\"headerlink\" title=\"flags\"></a>flags</h3><p>flag 是修饰command的一种方式，cobra支持完全兼容的POSIX flag以及go的 flag包，一个flag可以被定义成仅对当前命令生效或对当前及子孙命令生效（对于写代码时增加flag来说），flag功能由<a href=\"https://github.com/ogier/pflag\">pflag library</a>提供</p>\n<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><p>虽然你可以自定义你自己的应用工程结构，但推荐你使用以下cobra-cli应用的典型结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">▾ appName&#x2F;</span><br><span class=\"line\">  ▾ cmd&#x2F;</span><br><span class=\"line\">      add.go</span><br><span class=\"line\">      your.go</span><br><span class=\"line\">      commands.go</span><br><span class=\"line\">      here.go</span><br><span class=\"line\">    main.go</span><br></pre></td></tr></table></figure>\n<p>在cobra应用中，main.go通常只提供初始化cobra的功能，like that</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;&#123;pathToYourApp&#125;/cmd&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  cmd.Execute()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用cobra生成工具\"><a href=\"#使用cobra生成工具\" class=\"headerlink\" title=\"使用cobra生成工具\"></a>使用cobra生成工具</h2><p>cobra提供了帮你生成模板的cli工具，有如下命令:</p>\n<h3 id=\"初始化应用init\"><a href=\"#初始化应用init\" class=\"headerlink\" title=\"初始化应用init\"></a>初始化应用init</h3><p><code>cobra init [name] [flags]</code>,name是你cobra应用的名字，<code>--pkg-name</code>pkg 的名字 flag可以选择<code>-a</code> 作者名，<code>-l</code>添加license,默认Apache2.0，<code>--viper</code>添加viper等功能，具体如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--pkg-name string   fully qualified pkg name</span><br><span class=\"line\">-a, --author string    author name for copyright attribution (default &quot;YOUR NAME&quot;)</span><br><span class=\"line\">    --config string    config file (default is $HOME&#x2F;.cobra.yaml)</span><br><span class=\"line\">-l, --license string   name of license for the project</span><br><span class=\"line\">    --viper            use Viper for configuration (default true)</span><br></pre></td></tr></table></figure>\n\n<p>初始化应用后一般<code>go mod init</code>初始化应用，golang基础，在此不赘述</p>\n<h3 id=\"添加commands\"><a href=\"#添加commands\" class=\"headerlink\" title=\"添加commands\"></a>添加commands</h3><p><code>cobra add [name] -p &#39;parentComand&#39;</code> <code>-p</code>可以为特定命令添加子命令，缺省为根命令</p>\n<h2 id=\"使用Cobra库\"><a href=\"#使用Cobra库\" class=\"headerlink\" title=\"使用Cobra库\"></a>使用Cobra库</h2><p>手动创建需要新建一个rootCmd文件,然后添加若干command</p>\n<h3 id=\"创建rootCmd\"><a href=\"#创建rootCmd\" class=\"headerlink\" title=\"创建rootCmd\"></a>创建rootCmd</h3><p>cobra不需要创建一个特定的实例，可以直接使用<code>&amp;cobra.Commaand</code>，如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class=\"line\">  Use:   <span class=\"string\">&quot;hugo&quot;</span>, <span class=\"comment\">//command,代表命令</span></span><br><span class=\"line\">  Short: <span class=\"string\">&quot;Hugo is a very fast static site generator&quot;</span>, <span class=\"comment\">//对command的简短介绍</span></span><br><span class=\"line\">  Long: <span class=\"string\">`A Fast and Flexible Static Site Generator built with </span></span><br><span class=\"line\"><span class=\"string\">                love by spf13 and friends in Go.</span></span><br><span class=\"line\"><span class=\"string\">                Complete documentation is available at http://hugo.spf13.com`</span>, <span class=\"comment\">//对command的详细介绍</span></span><br><span class=\"line\">  Run: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 命令实际要做的事情</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Execute</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//启动</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := rootCmd.Execute(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">    os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以在init中定义flatgs以及处理配置，示例如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">  homedir <span class=\"string\">&quot;github.com/mitchellh/go-homedir&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/spf13/cobra&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/spf13/viper&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  cobra.OnInitialize(initConfig) <span class=\"comment\">//初始化配置</span></span><br><span class=\"line\">  rootCmd.PersistentFlags().StringVar(&amp;cfgFile, <span class=\"string\">&quot;config&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;config file (default is $HOME/.cobra.yaml)&quot;</span>)<span class=\"comment\">//配置</span></span><br><span class=\"line\">  rootCmd.PersistentFlags().StringVarP(&amp;projectBase, <span class=\"string\">&quot;projectbase&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;base project directory eg. github.com/spf13/&quot;</span>)</span><br><span class=\"line\">  rootCmd.PersistentFlags().StringP(<span class=\"string\">&quot;author&quot;</span>, <span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;YOUR NAME&quot;</span>, <span class=\"string\">&quot;Author name for copyright attribution&quot;</span>)</span><br><span class=\"line\">  rootCmd.PersistentFlags().StringVarP(&amp;userLicense, <span class=\"string\">&quot;license&quot;</span>, <span class=\"string\">&quot;l&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;Name of license for the project (can provide `licensetext` in config)&quot;</span>)</span><br><span class=\"line\">  rootCmd.PersistentFlags().Bool(<span class=\"string\">&quot;viper&quot;</span>, <span class=\"literal\">true</span>, <span class=\"string\">&quot;Use Viper for configuration&quot;</span>)</span><br><span class=\"line\">  viper.BindPFlag(<span class=\"string\">&quot;author&quot;</span>, rootCmd.PersistentFlags().Lookup(<span class=\"string\">&quot;author&quot;</span>))<span class=\"comment\">//绑定viper的标致到cobra</span></span><br><span class=\"line\">  viper.BindPFlag(<span class=\"string\">&quot;projectbase&quot;</span>, rootCmd.PersistentFlags().Lookup(<span class=\"string\">&quot;projectbase&quot;</span>))</span><br><span class=\"line\">  viper.BindPFlag(<span class=\"string\">&quot;useViper&quot;</span>, rootCmd.PersistentFlags().Lookup(<span class=\"string\">&quot;viper&quot;</span>))</span><br><span class=\"line\">  viper.SetDefault(<span class=\"string\">&quot;author&quot;</span>, <span class=\"string\">&quot;NAME HERE &lt;EMAIL ADDRESS&gt;&quot;</span>)</span><br><span class=\"line\">  viper.SetDefault(<span class=\"string\">&quot;license&quot;</span>, <span class=\"string\">&quot;apache&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">initConfig</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// viper读取配置文件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> cfgFile != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从flag读取文件</span></span><br><span class=\"line\">    viper.SetConfigFile(cfgFile)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取主目录</span></span><br><span class=\"line\">    home, err := homedir.Dir()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      fmt.Println(err)</span><br><span class=\"line\">      os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 查找文件.cobra</span></span><br><span class=\"line\">    viper.AddConfigPath(home)</span><br><span class=\"line\">    viper.SetConfigName(<span class=\"string\">&quot;.cobra&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := viper.ReadInConfig(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Can&#x27;t read config:&quot;</span>, err)</span><br><span class=\"line\">    os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加命令\"><a href=\"#添加命令\" class=\"headerlink\" title=\"添加命令\"></a>添加命令</h3><p>添加的命令可以创建在cmd目录下单独的go文件，比如创建一个version命令：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cmd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/spf13/cobra&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  rootCmd.AddCommand(versionCmd)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> versionCmd = &amp;cobra.Command&#123;</span><br><span class=\"line\">  Use:   <span class=\"string\">&quot;version&quot;</span>,</span><br><span class=\"line\">  Short: <span class=\"string\">&quot;Print the version number of Hugo&quot;</span>,</span><br><span class=\"line\">  Long:  <span class=\"string\">`All software has versions. This is Hugo&#x27;s`</span>,</span><br><span class=\"line\">  Run: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hugo Static Site Generator v0.9 -- HEAD&quot;</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用flag\"><a href=\"#使用flag\" class=\"headerlink\" title=\"使用flag\"></a>使用flag</h3><p>我们有两种</p>\n<h2 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><ol>\n<li><code>go mod init yourpackage</code> 创建你自己的模块</li>\n<li><code>go get -u github.com/spf13/cobra/cobra</code> 加载依赖</li>\n</ol>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ol>\n<li><code>cobra init ./ -a longtao -l GPL --viper</code> 初始化包(在当前目录初始化cobra，作者是longtao,许可是gpl，并使用viper配置)</li>\n<li><code>go build  -o ./ .</code> 编译测试一下是否正常使用</li>\n</ol>\n","raw":null,"categories":[{"name":"CS","path":"api/categories/CS.json"}],"tags":[{"name":"tool","path":"api/tags/tool.json"},{"name":"golang","path":"api/tags/golang.json"},{"name":"cli","path":"api/tags/cli.json"}]},{"title":"viper Tutorial","slug":"language/golang/lib/viper","date":"2021-10-31T12:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/lib/viper.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211104/163600258520200309153711.png","content":"<h2 id=\"cobra\"><a href=\"#cobra\" class=\"headerlink\" title=\"cobra\"></a>cobra</h2><p>cobra 是go的cli框架，包含cli库和生成基于cobra cli应用的命令行工具</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>子命令，如<code>app server</code>、<code>app sub</code>等</li>\n<li>完整兼容POSIX的flag，包括长命名和短命名</li>\n<li>子命令的嵌套（子命令）</li>\n<li>全局、本地、级联三种flag</li>\n<li>好用的工具命令，如<code>cobra init appname</code>初始化cli程序,<code>cobra add cmdname</code>为cli程序增加子命令</li>\n<li>智能提示</li>\n<li>生成命令help，以及为每个flag、cmd生成<code>-h</code>，<code>--help</code>帮助</li>\n<li>生成自动补全功能</li>\n<li>生成man帮助文档</li>\n<li>命令别名</li>\n<li>自定义帮助、用法</li>\n<li>为达到saas的12-factor 可选择viper</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><code>go get -u github.com/spf13/cobra/cobra</code>会自动安装最新版本库和命令行工具，国内下不下来可以手动下载放到对应的文件夹中，然后就可以在你的code里应用它<code>import &quot;github.com/spf13/cobra&quot;</code></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>cobra主要管理commands、args、flags，commands代表一个命令或动作，一般用动词命名，args代表输入的参数，一般用名词命名，flags是对commands的修饰，一般用形容词命名；好的cli应用应该学习成本低，用户容易理解 cli的含义，git的例子能很好的说明这一点: <code>git clone URL --bare</code> ，clone是commands是动词，URL是args是你的输入，bare是flag是形容词</p>\n<h3 id=\"commands\"><a href=\"#commands\" class=\"headerlink\" title=\"commands\"></a>commands</h3><p>commands是cli应用的核心，每次交互都包含在一个command中，command可以拥有可选的子命令（sub commands）</p>\n<h3 id=\"flags\"><a href=\"#flags\" class=\"headerlink\" title=\"flags\"></a>flags</h3><p>flag 是修饰command的一种方式，cobra支持完全兼容的POSIX flag以及go的 flag包，一个flag可以被定义成仅对当前命令生效或对当前及子孙命令生效（对于写代码时增加flag来说），flag功能由<a href=\"https://github.com/ogier/pflag\">pflag library</a>提供</p>\n<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><p>虽然你可以自定义你自己的应用工程结构，但推荐你使用以下cobra-cli应用的典型结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">▾ appName&#x2F;</span><br><span class=\"line\">  ▾ cmd&#x2F;</span><br><span class=\"line\">      add.go</span><br><span class=\"line\">      your.go</span><br><span class=\"line\">      commands.go</span><br><span class=\"line\">      here.go</span><br><span class=\"line\">    main.go</span><br></pre></td></tr></table></figure>\n<p>在cobra应用中，main.go通常只提供初始化cobra的功能，like that</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;&#123;pathToYourApp&#125;/cmd&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  cmd.Execute()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用cobra生成工具\"><a href=\"#使用cobra生成工具\" class=\"headerlink\" title=\"使用cobra生成工具\"></a>使用cobra生成工具</h2><p>cobra提供了帮你生成模板的cli工具，有如下命令:</p>\n<h3 id=\"初始化应用init\"><a href=\"#初始化应用init\" class=\"headerlink\" title=\"初始化应用init\"></a>初始化应用init</h3><p><code>cobra init [name] [flags]</code>,name是你cobra应用的名字，<code>--pkg-name</code>pkg 的名字 flag可以选择<code>-a</code> 作者名，<code>-l</code>添加license,默认Apache2.0，<code>--viper</code>添加viper等功能，具体如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--pkg-name string   fully qualified pkg name</span><br><span class=\"line\">-a, --author string    author name for copyright attribution (default &quot;YOUR NAME&quot;)</span><br><span class=\"line\">    --config string    config file (default is $HOME&#x2F;.cobra.yaml)</span><br><span class=\"line\">-l, --license string   name of license for the project</span><br><span class=\"line\">    --viper            use Viper for configuration (default true)</span><br></pre></td></tr></table></figure>\n\n<p>初始化应用后一般<code>go mod init</code>初始化应用，golang基础，在此不赘述</p>\n<h3 id=\"添加commands\"><a href=\"#添加commands\" class=\"headerlink\" title=\"添加commands\"></a>添加commands</h3><p><code>cobra add [name] -p &#39;parentComand&#39;</code> <code>-p</code>可以为特定命令添加子命令，缺省为根命令</p>\n<h2 id=\"使用Cobra库\"><a href=\"#使用Cobra库\" class=\"headerlink\" title=\"使用Cobra库\"></a>使用Cobra库</h2><p>手动创建需要新建一个rootCmd文件,然后添加若干command</p>\n<h3 id=\"创建rootCmd\"><a href=\"#创建rootCmd\" class=\"headerlink\" title=\"创建rootCmd\"></a>创建rootCmd</h3><p>cobra不需要创建一个特定的实例，可以直接使用<code>&amp;cobra.Commaand</code>，如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class=\"line\">  Use:   <span class=\"string\">&quot;hugo&quot;</span>, <span class=\"comment\">//command,代表命令</span></span><br><span class=\"line\">  Short: <span class=\"string\">&quot;Hugo is a very fast static site generator&quot;</span>, <span class=\"comment\">//对command的简短介绍</span></span><br><span class=\"line\">  Long: <span class=\"string\">`A Fast and Flexible Static Site Generator built with </span></span><br><span class=\"line\"><span class=\"string\">                love by spf13 and friends in Go.</span></span><br><span class=\"line\"><span class=\"string\">                Complete documentation is available at http://hugo.spf13.com`</span>, <span class=\"comment\">//对command的详细介绍</span></span><br><span class=\"line\">  Run: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 命令实际要做的事情</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Execute</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//启动</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := rootCmd.Execute(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">    os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以在init中定义flatgs以及处理配置，示例如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">  homedir <span class=\"string\">&quot;github.com/mitchellh/go-homedir&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/spf13/cobra&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/spf13/viper&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  cobra.OnInitialize(initConfig) <span class=\"comment\">//初始化配置</span></span><br><span class=\"line\">  rootCmd.PersistentFlags().StringVar(&amp;cfgFile, <span class=\"string\">&quot;config&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;config file (default is $HOME/.cobra.yaml)&quot;</span>)<span class=\"comment\">//配置</span></span><br><span class=\"line\">  rootCmd.PersistentFlags().StringVarP(&amp;projectBase, <span class=\"string\">&quot;projectbase&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;base project directory eg. github.com/spf13/&quot;</span>)</span><br><span class=\"line\">  rootCmd.PersistentFlags().StringP(<span class=\"string\">&quot;author&quot;</span>, <span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;YOUR NAME&quot;</span>, <span class=\"string\">&quot;Author name for copyright attribution&quot;</span>)</span><br><span class=\"line\">  rootCmd.PersistentFlags().StringVarP(&amp;userLicense, <span class=\"string\">&quot;license&quot;</span>, <span class=\"string\">&quot;l&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;Name of license for the project (can provide `licensetext` in config)&quot;</span>)</span><br><span class=\"line\">  rootCmd.PersistentFlags().Bool(<span class=\"string\">&quot;viper&quot;</span>, <span class=\"literal\">true</span>, <span class=\"string\">&quot;Use Viper for configuration&quot;</span>)</span><br><span class=\"line\">  viper.BindPFlag(<span class=\"string\">&quot;author&quot;</span>, rootCmd.PersistentFlags().Lookup(<span class=\"string\">&quot;author&quot;</span>))<span class=\"comment\">//绑定viper的标致到cobra</span></span><br><span class=\"line\">  viper.BindPFlag(<span class=\"string\">&quot;projectbase&quot;</span>, rootCmd.PersistentFlags().Lookup(<span class=\"string\">&quot;projectbase&quot;</span>))</span><br><span class=\"line\">  viper.BindPFlag(<span class=\"string\">&quot;useViper&quot;</span>, rootCmd.PersistentFlags().Lookup(<span class=\"string\">&quot;viper&quot;</span>))</span><br><span class=\"line\">  viper.SetDefault(<span class=\"string\">&quot;author&quot;</span>, <span class=\"string\">&quot;NAME HERE &lt;EMAIL ADDRESS&gt;&quot;</span>)</span><br><span class=\"line\">  viper.SetDefault(<span class=\"string\">&quot;license&quot;</span>, <span class=\"string\">&quot;apache&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">initConfig</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// viper读取配置文件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> cfgFile != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从flag读取文件</span></span><br><span class=\"line\">    viper.SetConfigFile(cfgFile)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取主目录</span></span><br><span class=\"line\">    home, err := homedir.Dir()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      fmt.Println(err)</span><br><span class=\"line\">      os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 查找文件.cobra</span></span><br><span class=\"line\">    viper.AddConfigPath(home)</span><br><span class=\"line\">    viper.SetConfigName(<span class=\"string\">&quot;.cobra&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := viper.ReadInConfig(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Can&#x27;t read config:&quot;</span>, err)</span><br><span class=\"line\">    os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加命令\"><a href=\"#添加命令\" class=\"headerlink\" title=\"添加命令\"></a>添加命令</h3><p>添加的命令可以创建在cmd目录下单独的go文件，比如创建一个version命令：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cmd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/spf13/cobra&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  rootCmd.AddCommand(versionCmd)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> versionCmd = &amp;cobra.Command&#123;</span><br><span class=\"line\">  Use:   <span class=\"string\">&quot;version&quot;</span>,</span><br><span class=\"line\">  Short: <span class=\"string\">&quot;Print the version number of Hugo&quot;</span>,</span><br><span class=\"line\">  Long:  <span class=\"string\">`All software has versions. This is Hugo&#x27;s`</span>,</span><br><span class=\"line\">  Run: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hugo Static Site Generator v0.9 -- HEAD&quot;</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用flag\"><a href=\"#使用flag\" class=\"headerlink\" title=\"使用flag\"></a>使用flag</h3><p>我们有两种</p>\n","raw":null,"categories":[{"name":"CS","path":"api/categories/CS.json"}],"tags":[{"name":"tool","path":"api/tags/tool.json"},{"name":"golang","path":"api/tags/golang.json"},{"name":"cli","path":"api/tags/cli.json"}]},{"title":"golang的bufio包","slug":"language/golang/bufiopackage","date":"2019-09-09T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/bufiopackage.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635134014gopher-48499__340.png","content":"<p>原理</p>\n<p>bufio通过缓冲提高效率</p>\n<p>把文件读取进缓冲(内存)避免每次读取触发系统io</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">participant 程序 as A</span><br><span class=\"line\">participant 缓冲区buf as B</span><br><span class=\"line\">participant 文件 as C</span><br><span class=\"line\">B--A:写入内容小于buf</span><br><span class=\"line\">B--A:</span><br><span class=\"line\">C--B:buf没空间，写入文件，清空buf</span><br><span class=\"line\">C--A:写入内容大于buf</span><br></pre></td></tr></table></figure>\n\n\n\n<p>把文件写入缓冲，多次写入后，最后一次性写入文件·</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序--缓冲区buf:写入内容小于buf</span><br><span class=\"line\">程序--缓冲区buf:</span><br><span class=\"line\">缓冲区buf--文件:buf没空间，写入文件，清空buf</span><br><span class=\"line\">程序--文件:写入内容大于buf</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br><span class=\"line\">619</span><br><span class=\"line\">620</span><br><span class=\"line\">621</span><br><span class=\"line\">622</span><br><span class=\"line\">623</span><br><span class=\"line\">624</span><br><span class=\"line\">625</span><br><span class=\"line\">626</span><br><span class=\"line\">627</span><br><span class=\"line\">628</span><br><span class=\"line\">629</span><br><span class=\"line\">630</span><br><span class=\"line\">631</span><br><span class=\"line\">632</span><br><span class=\"line\">633</span><br><span class=\"line\">634</span><br><span class=\"line\">635</span><br><span class=\"line\">636</span><br><span class=\"line\">637</span><br><span class=\"line\">638</span><br><span class=\"line\">639</span><br><span class=\"line\">640</span><br><span class=\"line\">641</span><br><span class=\"line\">642</span><br><span class=\"line\">643</span><br><span class=\"line\">644</span><br><span class=\"line\">645</span><br><span class=\"line\">646</span><br><span class=\"line\">647</span><br><span class=\"line\">648</span><br><span class=\"line\">649</span><br><span class=\"line\">650</span><br><span class=\"line\">651</span><br><span class=\"line\">652</span><br><span class=\"line\">653</span><br><span class=\"line\">654</span><br><span class=\"line\">655</span><br><span class=\"line\">656</span><br><span class=\"line\">657</span><br><span class=\"line\">658</span><br><span class=\"line\">659</span><br><span class=\"line\">660</span><br><span class=\"line\">661</span><br><span class=\"line\">662</span><br><span class=\"line\">663</span><br><span class=\"line\">664</span><br><span class=\"line\">665</span><br><span class=\"line\">666</span><br><span class=\"line\">667</span><br><span class=\"line\">668</span><br><span class=\"line\">669</span><br><span class=\"line\">670</span><br><span class=\"line\">671</span><br><span class=\"line\">672</span><br><span class=\"line\">673</span><br><span class=\"line\">674</span><br><span class=\"line\">675</span><br><span class=\"line\">676</span><br><span class=\"line\">677</span><br><span class=\"line\">678</span><br><span class=\"line\">679</span><br><span class=\"line\">680</span><br><span class=\"line\">681</span><br><span class=\"line\">682</span><br><span class=\"line\">683</span><br><span class=\"line\">684</span><br><span class=\"line\">685</span><br><span class=\"line\">686</span><br><span class=\"line\">687</span><br><span class=\"line\">688</span><br><span class=\"line\">689</span><br><span class=\"line\">690</span><br><span class=\"line\">691</span><br><span class=\"line\">692</span><br><span class=\"line\">693</span><br><span class=\"line\">694</span><br><span class=\"line\">695</span><br><span class=\"line\">696</span><br><span class=\"line\">697</span><br><span class=\"line\">698</span><br><span class=\"line\">699</span><br><span class=\"line\">700</span><br><span class=\"line\">701</span><br><span class=\"line\">702</span><br><span class=\"line\">703</span><br><span class=\"line\">704</span><br><span class=\"line\">705</span><br><span class=\"line\">706</span><br><span class=\"line\">707</span><br><span class=\"line\">708</span><br><span class=\"line\">709</span><br><span class=\"line\">710</span><br><span class=\"line\">711</span><br><span class=\"line\">712</span><br><span class=\"line\">713</span><br><span class=\"line\">714</span><br><span class=\"line\">715</span><br><span class=\"line\">716</span><br><span class=\"line\">717</span><br><span class=\"line\">718</span><br><span class=\"line\">719</span><br><span class=\"line\">720</span><br><span class=\"line\">721</span><br><span class=\"line\">722</span><br><span class=\"line\">723</span><br><span class=\"line\">724</span><br><span class=\"line\">725</span><br><span class=\"line\">726</span><br><span class=\"line\">727</span><br><span class=\"line\">728</span><br><span class=\"line\">729</span><br><span class=\"line\">730</span><br><span class=\"line\">731</span><br><span class=\"line\">732</span><br><span class=\"line\">733</span><br><span class=\"line\">734</span><br><span class=\"line\">735</span><br><span class=\"line\">736</span><br><span class=\"line\">737</span><br><span class=\"line\">738</span><br><span class=\"line\">739</span><br><span class=\"line\">740</span><br><span class=\"line\">741</span><br><span class=\"line\">742</span><br><span class=\"line\">743</span><br><span class=\"line\">744</span><br><span class=\"line\">745</span><br><span class=\"line\">746</span><br><span class=\"line\">747</span><br><span class=\"line\">748</span><br><span class=\"line\">749</span><br><span class=\"line\">750</span><br><span class=\"line\">751</span><br><span class=\"line\">752</span><br><span class=\"line\">753</span><br><span class=\"line\">754</span><br><span class=\"line\">755</span><br><span class=\"line\">756</span><br><span class=\"line\">757</span><br><span class=\"line\">758</span><br><span class=\"line\">759</span><br><span class=\"line\">760</span><br><span class=\"line\">761</span><br><span class=\"line\">762</span><br><span class=\"line\">763</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">// Use of this source code is governed by a BSD-style</span></span><br><span class=\"line\"><span class=\"comment\">// license that can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer</span></span><br><span class=\"line\"><span class=\"comment\">// object, creating another object (Reader or Writer) that also implements</span></span><br><span class=\"line\"><span class=\"comment\">// the interface but provides buffering and some help for textual I/O.</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> bufio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;unicode/utf8&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tdefaultBufSize = <span class=\"number\">4096</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tErrInvalidUnreadByte = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadByte&quot;</span>)</span><br><span class=\"line\">\tErrInvalidUnreadRune = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadRune&quot;</span>)</span><br><span class=\"line\">\tErrBufferFull        = errors.New(<span class=\"string\">&quot;bufio: buffer full&quot;</span>)</span><br><span class=\"line\">\tErrNegativeCount     = errors.New(<span class=\"string\">&quot;bufio: negative count&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered input.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reader implements buffering for an io.Reader object.对io.Reader的封装</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbuf          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\trd           io.Reader <span class=\"comment\">// reader provided by the client</span></span><br><span class=\"line\">\tr, w         <span class=\"keyword\">int</span>       <span class=\"comment\">// buf read and write positions</span></span><br><span class=\"line\">\terr          error</span><br><span class=\"line\">\tlastByte     <span class=\"keyword\">int</span> <span class=\"comment\">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class=\"line\">\tlastRuneSize <span class=\"keyword\">int</span> <span class=\"comment\">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minReadBufferSize = <span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxConsecutiveEmptyReads = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReaderSize</span><span class=\"params\">(rd io.Reader, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Reader?</span></span><br><span class=\"line\">\tb, ok := rd.(*Reader)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt; minReadBufferSize &#123;</span><br><span class=\"line\">\t\tsize = minReadBufferSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr := <span class=\"built_in\">new</span>(Reader)</span><br><span class=\"line\">\tr.reset(<span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size), rd)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReader</span><span class=\"params\">(rd io.Reader)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any buffered data, resets all state, and switches</span></span><br><span class=\"line\"><span class=\"comment\">// the buffered reader to read from r.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Reset</span><span class=\"params\">(r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\tb.reset(b.buf, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">reset</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>, r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\t*b = Reader&#123;</span><br><span class=\"line\">\t\tbuf:          buf,</span><br><span class=\"line\">\t\trd:           r,</span><br><span class=\"line\">\t\tlastByte:     <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\tlastRuneSize: <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeRead = errors.New(<span class=\"string\">&quot;bufio: reader returned negative count from Read&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fill reads a new chunk into the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">fill</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Slide existing data to beginning.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(b.buf, b.buf[b.r:b.w])</span><br><span class=\"line\">\t\tb.w -= b.r</span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to fill full buffer&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Read new data: try a limited number of times.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := maxConsecutiveEmptyReads; i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tn, err := b.rd.Read(b.buf[b.w:])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tb.err = err</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.err = io.ErrNoProgress</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">readErr</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\terr := b.err</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Peek returns the next n bytes without advancing the reader. The bytes stop</span></span><br><span class=\"line\"><span class=\"comment\">// being valid at the next read call. If Peek returns fewer than n bytes, it</span></span><br><span class=\"line\"><span class=\"comment\">// also returns an error explaining why the read is short. The error is</span></span><br><span class=\"line\"><span class=\"comment\">// ErrBufferFull if n is larger than b&#x27;s buffer size.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Calling Peek prevents a UnreadByte or UnreadRune call from succeeding</span></span><br><span class=\"line\"><span class=\"comment\">// until the next read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Peek</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &gt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.buf[b.r:b.w], ErrBufferFull</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 0 &lt;= n &lt;= len(b.buf)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> avail := b.w - b.r; avail &lt; n &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// not enough data in buffer</span></span><br><span class=\"line\">\t\tn = avail</span><br><span class=\"line\">\t\terr = b.readErr()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b.buf[b.r : b.r+n], err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Discard skips the next n bytes, returning the number of bytes discarded.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If Discard skips fewer than n bytes, it also returns an error.</span></span><br><span class=\"line\"><span class=\"comment\">// If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without</span></span><br><span class=\"line\"><span class=\"comment\">// reading from the underlying io.Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Discard</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(discarded <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tremain := n</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tskip := b.Buffered()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tb.fill()</span><br><span class=\"line\">\t\t\tskip = b.Buffered()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip &gt; remain &#123;</span><br><span class=\"line\">\t\t\tskip = remain</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.r += skip</span><br><span class=\"line\">\t\tremain -= skip</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> remain == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n - remain, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read reads data into p.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes read into p.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes are taken from at most one Read on the underlying Reader,</span></span><br><span class=\"line\"><span class=\"comment\">// hence n may be less than len(p).</span></span><br><span class=\"line\"><span class=\"comment\">// To read exactly len(p) bytes, use io.ReadFull(b, p).</span></span><br><span class=\"line\"><span class=\"comment\">// At EOF, the count will be zero and err will be io.EOF.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Read</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn = <span class=\"built_in\">len</span>(p)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(p) &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large read, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Read directly into p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.rd.Read(p)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tb.lastByte = <span class=\"keyword\">int</span>(p[n<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// One read.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Do not use b.fill, which will loop.</span></span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tn, b.err = b.rd.Read(b.buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// copy as much as we can</span></span><br><span class=\"line\">\tn = <span class=\"built_in\">copy</span>(p, b.buf[b.r:b.w])</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadByte reads and returns a single byte.</span></span><br><span class=\"line\"><span class=\"comment\">// If no byte is available, returns an error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadByte</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := b.buf[b.r]</span><br><span class=\"line\">\tb.r++</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(c)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte unreads the last byte. Only the most recently read byte can be unread.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte returns an error if the most recent method called on the</span></span><br><span class=\"line\"><span class=\"comment\">// Reader was not a read operation. Notably, Peek is not considered a</span></span><br><span class=\"line\"><span class=\"comment\">// read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadByte</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastByte &lt; <span class=\"number\">0</span> || b.r == <span class=\"number\">0</span> &amp;&amp; b.w &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadByte</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// b.r &gt; 0 || b.w == 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.r--</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r == 0 &amp;&amp; b.w == 0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.r] = <span class=\"keyword\">byte</span>(b.lastByte)</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadRune reads a single UTF-8 encoded Unicode character and returns the</span></span><br><span class=\"line\"><span class=\"comment\">// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte</span></span><br><span class=\"line\"><span class=\"comment\">// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadRune</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">rune</span>, size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r+utf8.UTFMax &gt; b.w &amp;&amp; !utf8.FullRune(b.buf[b.r:b.w]) &amp;&amp; b.err == <span class=\"literal\">nil</span> &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr, size = <span class=\"keyword\">rune</span>(b.buf[b.r]), <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &gt;= utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\tr, size = utf8.DecodeRune(b.buf[b.r:b.w])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += size</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r, size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadRune unreads the last rune. If the most recent method called on</span></span><br><span class=\"line\"><span class=\"comment\">// the Reader was not a ReadRune, UnreadRune returns an error. (In this</span></span><br><span class=\"line\"><span class=\"comment\">// regard it is stricter than UnreadByte, which will unread the last byte</span></span><br><span class=\"line\"><span class=\"comment\">// from any read operation.)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadRune</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastRuneSize &lt; <span class=\"number\">0</span> || b.r &lt; b.lastRuneSize &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadRune</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r -= b.lastRuneSize</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that can be read from the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.w - b.r &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice pointing at the bytes in the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes stop being valid at the next read.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadSlice encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns all the data in the buffer and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.</span></span><br><span class=\"line\"><span class=\"comment\">// Because the data returned from ReadSlice will be overwritten</span></span><br><span class=\"line\"><span class=\"comment\">// by the next I/O operation, most clients should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes or ReadString instead.</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice returns err != nil if and only if line does not end in delim.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadSlice</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\ts := <span class=\"number\">0</span> <span class=\"comment\">// search start index</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Search buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ti += s</span><br><span class=\"line\">\t\t\tline = b.buf[b.r : b.r+i+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tb.r += i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Pending error?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = b.buf[b.r:b.w]</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\terr = b.readErr()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Buffer full?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\tline = b.buf</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts = b.w - b.r <span class=\"comment\">// do not rescan area we scanned before</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Handle last byte, if any.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i := <span class=\"built_in\">len</span>(line) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.lastByte = <span class=\"keyword\">int</span>(line[i])</span><br><span class=\"line\">\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadLine is a low-level line-reading primitive. Most callers should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes(&#x27;\\n&#x27;) or ReadString(&#x27;\\n&#x27;) instead or use a Scanner.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine tries to return a single line, not including the end-of-line bytes.</span></span><br><span class=\"line\"><span class=\"comment\">// If the line was too long for the buffer then isPrefix is set and the</span></span><br><span class=\"line\"><span class=\"comment\">// beginning of the line is returned. The rest of the line will be returned</span></span><br><span class=\"line\"><span class=\"comment\">// from future calls. isPrefix will be false when returning the last fragment</span></span><br><span class=\"line\"><span class=\"comment\">// of the line. The returned buffer is only valid until the next call to</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine. ReadLine either returns a non-nil line or it returns an error,</span></span><br><span class=\"line\"><span class=\"comment\">// never both.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// The text returned from ReadLine does not include the line end (&quot;\\r\\n&quot; or &quot;\\n&quot;).</span></span><br><span class=\"line\"><span class=\"comment\">// No indication or error is given if the input ends without a final line end.</span></span><br><span class=\"line\"><span class=\"comment\">// Calling UnreadByte after ReadLine will always unread the last byte read</span></span><br><span class=\"line\"><span class=\"comment\">// (possibly a character belonging to the line end) even if that byte is not</span></span><br><span class=\"line\"><span class=\"comment\">// part of the line returned by ReadLine.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadLine</span><span class=\"params\">()</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, isPrefix <span class=\"keyword\">bool</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tline, err = b.ReadSlice(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == ErrBufferFull &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Handle the case where &quot;\\r\\n&quot; straddles the buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">0</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Put the &#x27;\\r&#x27; back on buf and drop it from line.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Let the next call to ReadLine check for &quot;\\r\\n&quot;.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> b.r == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// should be unreachable</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to rewind past start of buffer&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tb.r--</span><br><span class=\"line\">\t\t\tline = line[:<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> line, <span class=\"literal\">true</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\n&#x27;</span> &#123;</span><br><span class=\"line\">\t\tdrop := <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">1</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-2</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\tdrop = <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tline = line[:<span class=\"built_in\">len</span>(line)-drop]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadBytes encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadBytes</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Use ReadSlice to look for array,</span></span><br><span class=\"line\">\t<span class=\"comment\">// accumulating full buffers.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> frag []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> full [][]<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e error</span><br><span class=\"line\">\t\tfrag, e = b.ReadSlice(delim)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">// got final fragment</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e != ErrBufferFull &#123; <span class=\"comment\">// unexpected error</span></span><br><span class=\"line\">\t\t\terr = e</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Make a copy of the buffer.</span></span><br><span class=\"line\">\t\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(frag))</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(buf, frag)</span><br><span class=\"line\">\t\tfull = <span class=\"built_in\">append</span>(full, buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Allocate new buffer to hold the full pieces and the fragment.</span></span><br><span class=\"line\">\tn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">len</span>(full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn += <span class=\"built_in\">len</span>(frag)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Copy full pieces and fragment in.</span></span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\tn = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">copy</span>(buf[n:], full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(buf[n:], frag)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> buf, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadString reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a string containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadString encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadString returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadString</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tbytes, err := b.ReadBytes(delim)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(bytes), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteTo implements io.WriterTo.</span></span><br><span class=\"line\"><span class=\"comment\">// This may make multiple calls to the Read method of the underlying Reader.</span></span><br><span class=\"line\"><span class=\"comment\">// If the underlying reader supports the WriteTo method,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying WriteTo without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">WriteTo</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn, err = b.writeBuf(w)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r, ok := b.rd.(io.WriterTo); ok &#123;</span><br><span class=\"line\">\t\tm, err := r.WriteTo(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> w, ok := w.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\tm, err := w.ReadFrom(b.rd)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r &lt; b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r &lt; b.w =&gt; buffer is not empty</span></span><br><span class=\"line\">\t\tm, err := b.writeBuf(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err == io.EOF &#123;</span><br><span class=\"line\">\t\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeWrite = errors.New(<span class=\"string\">&quot;bufio: writer returned negative count from Write&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// writeBuf writes the Reader&#x27;s buffer to the writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">writeBuf</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(<span class=\"keyword\">int64</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tn, err := w.Write(b.buf[b.r:b.w])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(errNegativeWrite)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int64</span>(n), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Writer implements buffering for an io.Writer object.</span></span><br><span class=\"line\"><span class=\"comment\">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class=\"line\"><span class=\"comment\">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class=\"line\"><span class=\"comment\">// After all data has been written, the client should call the</span></span><br><span class=\"line\"><span class=\"comment\">// Flush method to guarantee all data has been forwarded to</span></span><br><span class=\"line\"><span class=\"comment\">// the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\terr error</span><br><span class=\"line\">\tbuf []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\tn   <span class=\"keyword\">int</span></span><br><span class=\"line\">\twr  io.Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriterSize returns a new Writer whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Writer is already a Writer with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriterSize</span><span class=\"params\">(w io.Writer, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Writer?</span></span><br><span class=\"line\">\tb, ok := w.(*Writer)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tsize = defaultBufSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Writer&#123;</span><br><span class=\"line\">\t\tbuf: <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size),</span><br><span class=\"line\">\t\twr:  w,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriter returns a new Writer whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriter</span><span class=\"params\">(w io.Writer)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewWriterSize(w, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any unflushed buffered data, clears any error, and</span></span><br><span class=\"line\"><span class=\"comment\">// resets b to write its output to w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Reset</span><span class=\"params\">(w io.Writer)</span></span> &#123;</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\tb.wr = w</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Flush writes any buffered data to the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Flush</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn, err := b.wr.Write(b.buf[<span class=\"number\">0</span>:b.n])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; b.n &amp;&amp; err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = io.ErrShortWrite</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &amp;&amp; n &lt; b.n &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">copy</span>(b.buf[<span class=\"number\">0</span>:b.n-n], b.buf[n:b.n])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n -= n</span><br><span class=\"line\">\t\tb.err = err</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Available returns how many bytes are unused in the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Available</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) - b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that have been written into the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Write writes the contents of p into the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If nn &lt; len(p), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Write</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(nn <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(p) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> n <span class=\"keyword\">int</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large write, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Write directly from p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.wr.Write(p)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tn = <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\t\t\tb.n += n</span><br><span class=\"line\">\t\t\tb.Flush()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\tp = p[n:]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteByte writes a single byte.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteByte</span><span class=\"params\">(c <span class=\"keyword\">byte</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Available() &lt;= <span class=\"number\">0</span> &amp;&amp; b.Flush() != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.n] = c</span><br><span class=\"line\">\tb.n++</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteRune writes a single Unicode code point, returning</span></span><br><span class=\"line\"><span class=\"comment\">// the number of bytes written and any error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteRune</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"params\">(size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &lt; utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\terr = b.WriteByte(<span class=\"keyword\">byte</span>(r))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := b.Available()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Flush(); b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tn = b.Available()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Can only happen if buffer is silly small.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> b.WriteString(<span class=\"keyword\">string</span>(r))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsize = utf8.EncodeRune(b.buf[b.n:], r)</span><br><span class=\"line\">\tb.n += size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteString writes a string.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If the count is less than len(s), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteString</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tnn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(s) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\t\tb.n += n</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\ts = s[n:]</span><br><span class=\"line\">\t\tb.Flush()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadFrom implements io.ReaderFrom. If the underlying writer</span></span><br><span class=\"line\"><span class=\"comment\">// supports the ReadFrom method, and b has no buffered data yet,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying ReadFrom without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">ReadFrom</span><span class=\"params\">(r io.Reader)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> w, ok := b.wr.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> w.ReadFrom(r)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err1 := b.Flush(); err1 != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> n, err1</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnr := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> nr &lt; maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\tm, err = r.Read(b.buf[b.n:])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> m != <span class=\"number\">0</span> || err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnr++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nr == maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, io.ErrNoProgress</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n += m</span><br><span class=\"line\">\t\tn += <span class=\"keyword\">int64</span>(m)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If we filled the buffer exactly, flush preemptively.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\terr = b.Flush()</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered input and output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadWriter stores pointers to a Reader and a Writer.</span></span><br><span class=\"line\"><span class=\"comment\">// It implements io.ReadWriter.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*Reader</span><br><span class=\"line\">\t*Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReadWriter allocates a new ReadWriter that dispatches to r and w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReadWriter</span><span class=\"params\">(r *Reader, w *Writer)</span> *<span class=\"title\">ReadWriter</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ReadWriter&#123;r, w&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"golang","path":"api/tags/golang.json"}]}]}