{"name":"linux","postlist":[{"title":"linux的boot目录","slug":"systemstructure/linux/boot","date":"2021-09-25T12:13:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/boot.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351392001-642-png_6_0_0_0_0_0_0_1258.74_1781.819-1259-0-755-1259.jpg","content":"<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351392001-642-png_6_0_0_0_0_0_0_1258.74_1781.819-1259-0-755-1259.jpg\" alt=\"See the source image\"></p>\n<p>1.查看当前运行的linux内核编译参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">两个方法，proc要求在内核编译时增减相应的选项才会生成，很多系统没有/proc/config.gz，第二种方法，一般</span></span><br><span class=\"line\">zcat /proc/config.gz</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">或</span></span><br><span class=\"line\">cat /boot/config-$(uname -r)</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"计算机启动到操作系统运行","slug":"systemstructure/linux/bootofcomputer","date":"2020-04-25T12:13:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/bootofcomputer.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139306R-C.81d56db1bef63aa01cbba73b33caedf3?rik=3YtNM7LX%2fwHS5Q&riu=http%3a%2f%2fwww.linuxidc.com%2fupload%2f2016_06%2f160617100110611.png&ehk=0SHzV%2fqNHRE7jk8jqfwwge4teKMqurNw7sM4KipqkaA%3d&risl=&pid=ImgRaw&r=0","content":"<p>首先学一个东西，一定要有一个<strong>前置</strong>的知识，我们把它当做已知的，我不可能从原子组成分子开始讲原理。那学习计算机启动过程的前置知识是什么呢？我要求你已知以下几点：</p>\n<ol>\n<li>内存是存储数据的地方，给出一个地址信号，内存可以返回该地址所对应的数据。</li>\n<li>CPU 的工作方式就是不断从内存中取出指令，并执行。</li>\n<li>CPU 从内存的哪个地址取出指令，是由一个寄存器中的值决定的，这个值会不断进行 +1 操作，或者由某条跳转指令指定其值是多少。</li>\n</ol>\n<p>好了，只需要知道这三点<strong>前置</strong>知识，你就能专业地解释计算机的启动过程了。</p>\n<h2 id=\"一、为什么是-BIOS-主导？\"><a href=\"#一、为什么是-BIOS-主导？\" class=\"headerlink\" title=\"一、为什么是 BIOS 主导？\"></a>一、为什么是 BIOS 主导？</h2><p>都说开机后，BIOS 就开始运行自己的程序了，又硬件自检，又加载启动区的。我就不服了，为什么开机后是执行 BIOS 里的程序？为啥不是内存里的？为啥不是硬盘里的？</p>\n<p>好的，不要怀疑前置知识，CPU 的工作方式，就是不断从内存中取指令并执行，那为什么会说是执行 BIOS 里的程序呢？这就不得不说说<strong>内存映射</strong>了。</p>\n<h2 id=\"二、内存映射\"><a href=\"#二、内存映射\" class=\"headerlink\" title=\"二、内存映射\"></a>二、内存映射</h2><p><strong>CPU 地址总线的宽度决定了可访问的内存空间的大小</strong>。比如 16 位的 CPU 地址总线宽度为 20 位，地址范围是 1M。32 位的 CPU 地址总线宽度为 32 位，地址范围是 4G。你可以算算我们现在的 64 位机的地址范围。</p>\n<p>可是，可访问的内存空间这么大，并不等于说全都给内存使用，也就是说寻址的对象不只有内存，还有一些外设也要通过地址总线的方式去访问，那怎么去访问这些外设呢？就是在地址范围中划出一片片的区域，这块给显存使用，那块给硬盘控制器使用，等等 。</p>\n<p>这样说，其实就不符合我们的前置知识了，所以可以有一种不太正确的理解方式，那就是内存中的这块位置就是显存，那块位置就是硬盘控制器。我们在相应的位置上读取或者写入，就相当于在显存等外设的相应位置上读取或者写入，就好像这些外设的存储区域，被<strong>映射</strong>到了内存中的某一片区域一样。这样我们就不用管那些外设啦，关注点仍然是一个简简单单的内存。这就是所谓的<strong>内存映射</strong>。</p>\n<p>太好了，现在又用简单的前置知识就能解释得通了，我们继续往下推。</p>\n<h2 id=\"三、实模式下的内存分布\"><a href=\"#三、实模式下的内存分布\" class=\"headerlink\" title=\"三、实模式下的内存分布\"></a>三、实模式下的内存分布</h2><p>刚刚说到内存中划分出了一片一片区域给各种外设，那么问题自然就来了，哪块区域，分给了哪块外设了呢？如果是规定，那应该有一张表比较好吧。嗯没错，还真有，它就是实模式下的内存分布，笔者给它画了一张图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139328640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">在这里插入图片描述</p>\n<p>哎哟我真是个小天使，把比例都表现出来了，网上能再找出比我这个更直观的请给我留言。实模式之后再解释，现在简单理解就是计算机刚开机的时候只有 1M 的内存可用。</p>\n<p>我们看到，内存被各种外设瓜分了，即映射在了内存中。BIOS 更狠，不但其空间被映射到了内存 0xC0000 - 0xFFFFF 位置，其里面的程序还占用了开头的一些区域，比如把中断向量表写在了内存开始的位置，真所谓先到先得啊。</p>\n<h2 id=\"四、怎么就从-BIOS-里的程序开始执行了\"><a href=\"#四、怎么就从-BIOS-里的程序开始执行了\" class=\"headerlink\" title=\"四、怎么就从 BIOS 里的程序开始执行了\"></a>四、怎么就从 BIOS 里的程序开始执行了</h2><p>好了，现在我们知道 BIOS 里的信息被映射到了内存 0xC0000 - 0xFFFFF 位置，其中最为关键的系统 BIOS 被映射到了 0xF0000 - 0xFFFFF 位置。假如我现在说，CPU 开机就是执行了这块区域的代码，然后巴拉巴拉一顿操作就开机了，你肯定要喷我了，为什么就执行到这了呢，那咋不从头开始执行？</p>\n<p>这就自然有了一种猜想，我们要用到另一个前置知识了，就是 CPU 从内存的哪个位置取出执行并执行呢？<strong>是 PC 寄存器中的地址值</strong>。BIOS 程序的入口地址也就是开始地址是 0xFFFF0（人家就那么写的），也就是开机键一按下，一定有一个神奇的力量，将 pc 寄存器中的值变成 0xFFFF0，然后 CPU 就开始马不停蹄地跑了起来。没错，接下来这句话，可能就是你找了很久的答案，请做好准备：</p>\n<p><strong>在你开机的一瞬间，CPU 的 PC 寄存器被强制初始化为 0xFFFF0</strong>。如果再说具体些，CPU 将段基址寄存器 cs 初始化为 0xF000，将偏移地址寄存器 IP 初始化为 0xFFF0，根据实模式下的最终地址计算规则，将段基址左移 4 位，加上偏移地址，得到最终的物理地址也就是抽象出来的 PC 寄存器地址为 0xFFFF0。</p>\n<p>当我在学习这段知识时，看到这句话才让将我心里积压了很久的疑惑解开，多么简单粗暴的道理啊。写到这里我也是长舒了一口气，因为剩下的过程，就几乎只是流水账一样的正推了。</p>\n<p>至于怎么强制初始化的，我觉得就越过了前置知识的边界了，况且各个厂商的硬件实现也不一定相同，有很多办法，也很简单。讨论起来意义就不大了。</p>\n<h2 id=\"五、BIOS-里到底写了什么程序\"><a href=\"#五、BIOS-里到底写了什么程序\" class=\"headerlink\" title=\"五、BIOS 里到底写了什么程序\"></a>五、BIOS 里到底写了什么程序</h2><p>好了，我们现在知道了 BIOS 被映射到了内存的某个位置，并且开机一瞬间 CPU 强制将自己的 pc 寄存器初始化为 BIOS 程序的入口地址，从这里开始 CPU 马不停蹄地向前跑了起来。那接下来的问题似乎也非常自然地就问出来了，那就是 BIOS 程序里到底写了啥？</p>\n<p>把 BIOS 程序里的二进制信息全贴出来也不合适，我们分析一些主要的。我们首先还是来猜测，你看入口地址是 0xFFFF0，说明程序是从这执行的。实模式下内存的下边界就是 0xFFFFF，也就是只剩下 16 个字节的空间可以写代码了，这够干啥的呢？如果你有心的话应该能猜出，入口地址处可能是个跳转指令，跳到一个更大范围的空间去执行自己的任务。没错就是这样，0xFFFF0 处存储的机器指令，翻译成汇编语言是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp far f000:e05b</span><br></pre></td></tr></table></figure>\n\n<p>意思是跳转到物理地址 0xfe05b 处开始执行（回忆下前面说的实模式下的地址计算方式）。</p>\n<p>地址 0xfe05b 处开始，便是 BIOS 真正发挥作用的代码了，这块代码会检测一些外设信息，并初始化好硬件，建立中断向量表并填写中断例程。这里的部分不要展开，这只是一段写死的程序而已，而且对理解开机启动过程无帮助，我们看后面精彩的部分，也就是 BIOS 的最后一项工作：<strong>加载启动区</strong>。</p>\n<h2 id=\"六、0x7c00-是啥\"><a href=\"#六、0x7c00-是啥\" class=\"headerlink\" title=\"六、0x7c00 是啥\"></a>六、0x7c00 是啥</h2><p>该较真的地方就是要较真，我绝对不会让<strong>加载</strong>这种魔幻的词出现在这里，我们现在就来把它拆解成人话。</p>\n<p>其实这个词也并不魔幻，加载在计算机领域就是指，<strong>把某设备上（比如硬盘）的程序复制到内存中的过程</strong>。那加载启动区这个过程，翻译过来就是，<strong>BIOS 程序把启动区的内容复制到了内存中的某个区域</strong>。好了，问题又自然出来了，启动区是哪里？被复制到了内存的哪个位置？然后呢？我们一个个来回答。</p>\n<p>什么是启动区呢？即使你不知道，你也应该能够猜到，一定是符合某种特征的一块区域，于是人们把它就叫做启动区了，那要符合什么特征呢？先不急，不知道你有没有过设置 BIOS 启动顺序的经历，通常有 U 盘启动、硬盘启动、软盘启动、光盘启动等等，<strong>BIOS 会按照顺序，读取这些启动盘中位于 0 盘 0 道 1 扇区的内容</strong>。</p>\n<p>至于磁盘格式的划分，本篇就不做讲解了，总之对于内存，我们给出一个数字地址就能获取到该地址的数据，而对于磁盘，我们需要给出磁头、柱面、扇区这三个信息才能定位某个位置的数据，都是描述位置的一种方式而已。</p>\n<p>接着说， 这 0 盘 0 道 1 扇区的内容一共有 512 个字节，<strong>如果末尾的两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区</strong>。如果不是，那么按顺序继续向下个设备中寻找位于 0 盘 0 道 1 扇区的内容。如果最后发现都没找到符合条件的，那直接报出一个无启动区的错误。</p>\n<p>BIOS 找到了这个启动区之后干嘛呢？哦，前面说过了是加载，<strong>就是把这 512 个字节的内容，一个比特都不少的全部复制到内存的 0x7c00 这个位置</strong>。怎么复制的？当然是指令啦。哪些指令呢？这里我只能简单说指令集中是有 in 和 out 的，用来将外设中的数据复制到内存，或者将内存中的数据复制到外设，用这两个指令，以及外设给我们提供的读取方式，就能做到这一点啦。</p>\n<p>启动区内容此时已经被 BIOS 程序复制到了内存的 0x7c00 这个位置，然后呢？这个其实也不难猜测，启动区的内容就是我们自己写的代码了，复制到这里之后，就开始执行呗，之后我们的程序就接管了接下来的流程，BIOS 的使命也就结束啦。所以复制完之后，接下来应该是一个跳转指令吧！没错，正是这样，PC 寄存器的值变为 0x7c00，指令开始从这里执行。</p>\n<p>咦？不知道你有没有发现，我们似乎不知不觉又把之前的一句魔法语言翻译成人话了，开头我们说：</p>\n<blockquote>\n<p>BIOS 把控制权转交给排在第一位的存储设备。</p>\n</blockquote>\n<p>所以这句话是什么意思呢？<strong>就是 BIOS 把启动区的 512 字节复制到内存的 0x7c00 位置，并且用一条跳转指令将 pc 寄存器的值指向 0x7c00</strong>。你看，这不是也没多几个字嘛，就把这个问题说得明明白白，简简单单。</p>\n<p>哦，对了，现在似乎就剩下一个问题了，为什么非要是 0x7c00 呢？好问题，当然答案也很简单，那就是人家 BIOS 开发团队就是这样定的，之后也不好改了，不然不兼容。为什么不好改？我们看一个简单的启动区 512 字节的代码。（代码摘抄自《30 天自制操作系统》）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; hello-os</span><br><span class=\"line\">; TAB&#x3D;4</span><br><span class=\"line\"></span><br><span class=\"line\">  ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置</span><br><span class=\"line\"></span><br><span class=\"line\">;程序主体</span><br><span class=\"line\"></span><br><span class=\"line\">entry:</span><br><span class=\"line\">  MOV  AX,0   ;初始化寄存器</span><br><span class=\"line\">  MOV  SS,AX</span><br><span class=\"line\">  MOV  SP,0x7c00</span><br><span class=\"line\">  MOV  DS,AX   ;段寄存器初始化为 0</span><br><span class=\"line\">  MOV  ES,AX</span><br><span class=\"line\">  MOV  SI,msg</span><br><span class=\"line\">putloop:</span><br><span class=\"line\">  MOV  AL,[SI]</span><br><span class=\"line\">  ADD  SI,1</span><br><span class=\"line\">  CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符</span><br><span class=\"line\">  JE  fin</span><br><span class=\"line\">  MOV  AH,0x0e   ;指定文字</span><br><span class=\"line\">  MOV  BX,15   ;指定颜色</span><br><span class=\"line\">  INT  0x10   ;调用 BIOS 显示字符函数</span><br><span class=\"line\">  JMP  putloop</span><br><span class=\"line\">fin:</span><br><span class=\"line\">  HLT</span><br><span class=\"line\">  JMP  fin</span><br><span class=\"line\">msg:</span><br><span class=\"line\">  DB  0x0a,0x0a  ;换行、换行</span><br><span class=\"line\">  DB  &quot;hello-os&quot;</span><br><span class=\"line\">  DB  0x0a   ;换行</span><br><span class=\"line\">  DB  0    ;0 结尾</span><br><span class=\"line\"></span><br><span class=\"line\">  RESB 0x7dfe-$   ;填充0到512字节</span><br><span class=\"line\">  DB 0x55, 0xaa   ;可启动设备标识</span><br></pre></td></tr></table></figure>\n\n<p>我们看第一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ORG  0x7c00</span><br></pre></td></tr></table></figure>\n\n<p>这个数字就是刚刚说的启动区加载位置，这行汇编代码简单说就表示把下面的地址统统加上 0x7c00。正因为 BIOS 将启动区的代码加载到了这里，因此有了一个偏移量，所以所有写启动区代码的人就需要在开头写死一个这样的代码，不然全都串位了。</p>\n<p>然后正因为所有写操作系统的，启动区的第一行汇编代码都写死了这个数字，那 BIOS 开发者最初定的这个数字就不好改了，否则它得挨个联系各个操作系统的开发厂商，说唉我这个地址改一下哈，你们跟着改改。在公司推动另一个团队改个代码都得大费周折，想想看这样的推动得耗费多大人力。况且即使改了，之前的代码也都不兼容了，这不得被人们骂死啊。</p>\n<p>再看最后一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DB 0x55, 0xaa</span><br></pre></td></tr></table></figure>\n\n<p>这也验证了我们之前说的这 512 字节的最后两个字节得是 0x55 0xaa，BIOS 才会认为它是一个启动区，才会去加载它，仅此而已。</p>\n<p>回过头来说 0x7c00 这个值，它其实就是一个规定死的值，但还是会有人问，那必然有它的合理性吧。其实，我的解释也只能说是人家规定了这个值，后人们替他们解释这个合理性，并不是说当初人家就一定是这样想的，就好比我们做语文的阅读理解题一样。</p>\n<p>第一个 BIOS 开发团队是 IBM PC 5150 BIOS，当时被认为的第一个操作系统是 DOS 1.0 操作系统，BIOS 团队就假设是为它服务的。但操作系统还没出，BIOS 团队假设其操作系统需要的最小内存为 32 KB。BIOS 希望自己所加载的启动区代码尽量靠后，这样比较“安全”，不至于过早的被其他程序覆盖掉。可是如果仅仅留 512 字节又感觉太悬了，还有一些栈空间需要预留，那扩大到 1 KB 吧。这样 32 KB 的末尾是 0x8000，减去 1KB(0x400) ，刚好等于 0x7c00。哇塞，太精准了，这可以是一种解释方式。</p>\n<h2 id=\"七、启动区里的代码写了啥\"><a href=\"#七、启动区里的代码写了啥\" class=\"headerlink\" title=\"七、启动区里的代码写了啥\"></a>七、启动区里的代码写了啥</h2><p>其实写到这，我这篇文章就应该戛然而止了，因为最初的那个问题已经解决了，CPU 已经开始马不停蹄地从我们预期的位置跑起来了，万事开头难，剩下的内容，就是操作系统想怎么玩就怎么玩了。</p>\n<p>但我觉得还不够味，似乎还有些问题萦绕在你脑海里。比如说这个问题：</p>\n<blockquote>\n<p>启动区里的代码写了啥？就 512 字节就是全部操作系统内容了？</p>\n</blockquote>\n<p>这是一个好问题，512 个字节确实干不了啥，现在的操作系统怎么也得按 M 为单位算吧，512 个字节远远不够呢，那是怎么回事呢？</p>\n<p>其实我们可以按照之前的思路猜测，BIOS 用很少的代码就把 512 字节的启动区内容加载到了内存，并跳转过去开始执行。那按照这个套路，这 512 字节的启动区代码，是不是也可以把更多磁盘中存储的操作系统程序，加载到内存的某个位置，然后跳转过去呢？</p>\n<p>没错，就是这个套路。<strong>所以 BIOS 负责加载了启动区，而启动区又负责加载真正的操作系统内核</strong>，这配合默契吧？</p>\n<p>由于用于启动盘的磁盘是人家写操作系统的厂商制作的，俗称制作启动盘，所以他也肯定知道操作系统的核心代码存储在磁盘的哪个扇区，因此启动区就把这个扇区，以及之后的好多好多扇区（具体取决于操作系统有多大）都读到内存中，然后跳转到开始的程序开始的位置。跳转到哪里呢？这个就不像 0x7c00 这个数那么经典了，不同的操作系统肯定也不一样，也不用事先规定好，反正写操作系统的人给自己定一个就好了，别覆盖其他关键设备用到的区域就好。</p>\n<h2 id=\"八、操作系统内核写了啥\"><a href=\"#八、操作系统内核写了啥\" class=\"headerlink\" title=\"八、操作系统内核写了啥\"></a>八、操作系统内核写了啥</h2><p>好了现在经过好几轮跳跳跳，终于跳到内核代码啦，我们来一起回顾一下：</p>\n<ol>\n<li>按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址（一跳）</li>\n<li>该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）</li>\n<li>执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）</li>\n<li>启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139335949069-20190421160331677-268089991.png\" alt=\"img\"></p>\n<h1 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h1><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351393421635139306R-C.81d56db1bef63aa01cbba73b33caedf3?rik=3YtNM7LX/wHS5Q&riu=http://www.linuxidc.com/upload/2016_06/160617100110611.png&ehk=0SHzV/qNHRE7jk8jqfwwge4teKMqurNw7sM4KipqkaA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"linux kernel更换","slug":"systemstructure/linux/changekernel","date":"2020-04-15T12:02:01.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/changekernel.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139368linux-kernel.png","content":"<p>CentOS 是RHEL（Red Hat Enterprise Linux）源代码再编译的产物</p>\n<table>\n<thead>\n<tr>\n<th>发行版本</th>\n<th>发行时间</th>\n<th>内核版本</th>\n<th>发布时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2.1</td>\n<td>2004.05.14</td>\n<td>kernel-2.4.9</td>\n<td>2011.08</td>\n</tr>\n<tr>\n<td>3.1~3.9</td>\n<td>2004.03.19~2007.07.26</td>\n<td>kernel-2.4.21</td>\n<td>2003.01</td>\n</tr>\n<tr>\n<td>4.0~4.9</td>\n<td>2005.03.09~2011.03.02</td>\n<td>kernel-2.6.9</td>\n<td>2004.10</td>\n</tr>\n<tr>\n<td>5.0~5.11</td>\n<td>2007.04.12~2014.09.30</td>\n<td>kernel-2.6.18</td>\n<td>2006.09</td>\n</tr>\n<tr>\n<td>6.0~6.10</td>\n<td>2011.07.04~</td>\n<td>kernel-2.6.32</td>\n<td>2009.12</td>\n</tr>\n<tr>\n<td>7.0.1406</td>\n<td>2014.07.07</td>\n<td>kernel-3.10.0-123</td>\n<td>2013.07</td>\n</tr>\n<tr>\n<td>7.1.1503</td>\n<td>2015.03.31</td>\n<td>kernel-3.10.0-229</td>\n<td></td>\n</tr>\n<tr>\n<td>7.2.1511</td>\n<td>2015.12.15</td>\n<td>kernel-3.10.0-327</td>\n<td></td>\n</tr>\n<tr>\n<td>7.3.1611</td>\n<td>2016.12.12</td>\n<td>kernel-3.10.0-514</td>\n<td></td>\n</tr>\n<tr>\n<td>7.4.1708</td>\n<td>2017.09.13</td>\n<td>kernel-3.10.0-693</td>\n<td></td>\n</tr>\n<tr>\n<td>7.5.1804</td>\n<td>2018.05.10</td>\n<td>kernel-3.10.0-862</td>\n<td></td>\n</tr>\n<tr>\n<td>7.6.1810</td>\n<td>2018.12.04</td>\n<td>kernel-3.10.0-957</td>\n<td></td>\n</tr>\n<tr>\n<td>7.7.1908</td>\n<td>2019.09.18</td>\n<td>kernel-3.10.0-1062</td>\n<td></td>\n</tr>\n<tr>\n<td>8.0.1905</td>\n<td>2019-09-25</td>\n<td>kernel-4.18.0-80</td>\n<td>2018.08</td>\n</tr>\n</tbody></table>\n<p>ubuntu</p>\n<table>\n<thead>\n<tr>\n<th>发行版本</th>\n<th>发行时间</th>\n<th>内核版本</th>\n<th>发布时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>4.10</td>\n<td>2004.10.20</td>\n<td>2.6.8</td>\n<td>2004.08</td>\n</tr>\n<tr>\n<td>5.04</td>\n<td>2005.04.08</td>\n<td>2.6.10</td>\n<td>2004.12</td>\n</tr>\n<tr>\n<td>5.10</td>\n<td>2005.10.13</td>\n<td>2.6.12</td>\n<td>2005.01</td>\n</tr>\n<tr>\n<td>6.06</td>\n<td>2006.06.01(LTS)</td>\n<td>2.6.15</td>\n<td>2006.01</td>\n</tr>\n<tr>\n<td>6.10</td>\n<td>2006.10.06</td>\n<td>2.6.17</td>\n<td>2006.06</td>\n</tr>\n<tr>\n<td>7.04</td>\n<td>2007.04.19</td>\n<td>2.6.20</td>\n<td>2007.02</td>\n</tr>\n<tr>\n<td>7.10</td>\n<td>2007.10.18</td>\n<td>2.6.22</td>\n<td>2007.07</td>\n</tr>\n<tr>\n<td>8.04</td>\n<td>2008.04.24(LTS)</td>\n<td>2.6.24</td>\n<td>2008.01</td>\n</tr>\n<tr>\n<td>8.10</td>\n<td>2008.10.30</td>\n<td>2.6.27</td>\n<td>2008.10</td>\n</tr>\n<tr>\n<td>9.04</td>\n<td>2009.04.23</td>\n<td>2.6.28</td>\n<td>2009.01</td>\n</tr>\n<tr>\n<td>9.10</td>\n<td>2009.10.29</td>\n<td>2.6.31</td>\n<td>2009.09</td>\n</tr>\n<tr>\n<td>10.04</td>\n<td>2010.4.29</td>\n<td>2.6.32</td>\n<td>2009.12</td>\n</tr>\n<tr>\n<td>10.10</td>\n<td>2010.10.13</td>\n<td>2.6.35</td>\n<td>2010.08</td>\n</tr>\n<tr>\n<td>11.04</td>\n<td>2011.04.28</td>\n<td>2.6.38</td>\n<td>2011.03</td>\n</tr>\n<tr>\n<td>11.10</td>\n<td>2011.10.13</td>\n<td>3.0</td>\n<td>2011.08</td>\n</tr>\n<tr>\n<td>12.04</td>\n<td>2012.04.26(LTS)</td>\n<td>3.2+</td>\n<td>2012.01</td>\n</tr>\n<tr>\n<td>12.10</td>\n<td>2012.10.20</td>\n<td>3.5</td>\n<td>2012.08</td>\n</tr>\n<tr>\n<td>13.04</td>\n<td>2013.04.25</td>\n<td>3.8</td>\n<td>2013.02</td>\n</tr>\n<tr>\n<td>13.10</td>\n<td>2013.10.17</td>\n<td>3.11</td>\n<td>2013.09</td>\n</tr>\n<tr>\n<td>14.04</td>\n<td>2014.04.18 (LTS)</td>\n<td>3.13</td>\n<td>2014.01</td>\n</tr>\n<tr>\n<td>14.10</td>\n<td>2014.10.23</td>\n<td>3.16</td>\n<td>2014.08</td>\n</tr>\n<tr>\n<td>15.04</td>\n<td>2015.04</td>\n<td>3.19</td>\n<td>2015.03</td>\n</tr>\n<tr>\n<td>15.10</td>\n<td>2015.10</td>\n<td>4.2</td>\n<td>2015.08</td>\n</tr>\n<tr>\n<td>16.04</td>\n<td>2016.04（LTS）</td>\n<td>4.4</td>\n<td>2016.01</td>\n</tr>\n<tr>\n<td>16.10</td>\n<td>2016.10</td>\n<td>4.8</td>\n<td>2016.10</td>\n</tr>\n<tr>\n<td>17.04</td>\n<td>2017.04</td>\n<td>4.10</td>\n<td>2017.02</td>\n</tr>\n<tr>\n<td>17.10</td>\n<td>2017.10</td>\n<td>4.13</td>\n<td>2017.09</td>\n</tr>\n<tr>\n<td>18.04</td>\n<td>2018.04.26</td>\n<td>4.15</td>\n<td>2018.01</td>\n</tr>\n<tr>\n<td>18.10</td>\n<td>2018.10.18</td>\n<td>4.18</td>\n<td>2018.08</td>\n</tr>\n<tr>\n<td>19.04</td>\n<td>2019.04.18</td>\n<td>5.0</td>\n<td>2019.03</td>\n</tr>\n<tr>\n<td>19.10</td>\n<td>2019.10.17</td>\n<td>5.2</td>\n<td>2019.07</td>\n</tr>\n<tr>\n<td>20.04</td>\n<td>2020.04.23</td>\n<td>5.4</td>\n<td>2019.11</td>\n</tr>\n</tbody></table>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p>centos</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name grub.cfg #grub是引导操作系统的程序，它会根据自己的配置文件，去引导内核，当内核被加载到内存以后，内核会根据grub配置文件中的配置，找到根分区所使用的文件系统对应的驱动，通过根分区文件系统对应的驱动，挂载根分区，从而达到启动操作系统的目的。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-1-30 ~]# grub2-</span><br><span class=\"line\">grub2-bios-setup           grub2-macbless             grub2-mkrelpath            grub2-script-check</span><br><span class=\"line\">grub2-editenv              grub2-menulst2cfg          grub2-mkrescue             grub2-set-default</span><br><span class=\"line\">grub2-file                 grub2-mkconfig             grub2-mkstandalone         grub2-setpassword</span><br><span class=\"line\">grub2-fstest               grub2-mkfont               grub2-ofpathname           grub2-sparc64-setup</span><br><span class=\"line\">grub2-get-kernel-settings  grub2-mkimage              grub2-probe                grub2-syslinux2cfg</span><br><span class=\"line\">grub2-glue-efi             grub2-mklayout             grub2-reboot               </span><br><span class=\"line\">grub2-install              grub2-mknetdir             grub2-render-label         </span><br><span class=\"line\">grub2-kbdcomp              grub2-mkpasswd-pbkdf2      grub2-rpm-sort    </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> centos7 以上使用grub2 系列命令 centos7 以下是grub系列命令，用于grub设置</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -a  # 查看kernel版本</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h3><ol>\n<li><a href=\"https://blog.csdn.net/weixin_40161232/article/details/85251250\">https://blog.csdn.net/weixin_40161232/article/details/85251250</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_34194087/article/details/93497024\">https://blog.csdn.net/weixin_34194087/article/details/93497024</a></li>\n<li><a href=\"https://blog.csdn.net/zhaihaibo168/article/details/102673669\">https://blog.csdn.net/zhaihaibo168/article/details/102673669</a></li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"grub介绍及使用","slug":"systemstructure/linux/grub","date":"2022-01-01T12:13:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/grub.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20220221/grub.png","content":"<h2 id=\"多重操作系统引导管理器\"><a href=\"#多重操作系统引导管理器\" class=\"headerlink\" title=\"多重操作系统引导管理器\"></a>多重操作系统引导管理器</h2><h3 id=\"什么是多重引导\"><a href=\"#什么是多重引导\" class=\"headerlink\" title=\"什么是多重引导\"></a>什么是多重引导</h3><p>多重引导指一台计算机上安装多个操作系统,同时可以选择启动哪一个,例如常见的双系统也被叫做双引导</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>grub是GNU项目的启动引导程序，可以用于选择操作系统分区中的不同内核也可以向内核传递启动参数</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ol>\n<li><p>修改/etc/default/grub中的参数</p>\n</li>\n<li><p>1.当为legacyBIOS时</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class=\"line\"><span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>2.当为UEFIBIOS时</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grub2-mkconfig -o /boot/efi/EFI/操作系统名称/grub.cfg </span><br></pre></td></tr></table></figure></li>\n<li><p>重启机器</p>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"中断","slug":"systemstructure/linux/iterruptrequest","date":"2020-05-05T12:28:43.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/iterruptrequest.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139455kernel_interface.png","content":"<h2 id=\"中断是什么\"><a href=\"#中断是什么\" class=\"headerlink\" title=\"中断是什么\"></a>中断是什么</h2><p>中断是操作系统、CPU、CPU与IO设备中的概念，为中断CPU执行。其中涉及的概念都有无限深的概念栈(其实是无限深)我们就从简单的系统层面讲一讲。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139455kernel_interface.png\" alt=\"See the source image\"></p>\n<h2 id=\"前置概念\"><a href=\"#前置概念\" class=\"headerlink\" title=\"前置概念\"></a>前置概念</h2><p>IRQ：interrupt request,中断请求</p>\n<p>ISR：interrupt service routine， 中断服务程序，中断后运行的服务，ISR运行结束才会结束中断</p>\n<p>PIC：programmable interrupt contolle,可编程中断控制器（中断控制芯片），与I/O设备直连，可以触发CPU的INTR(中断请求)引脚，发起中断请求</p>\n<p>APIC：advanced programmable interrupt contolle,高级编程中断控制器，有两部分，Local APIC 在CPU内部(每个核都有)，I/O APIC在主板芯片组内，I/O APIC和LAPIC通过总线连接</p>\n<h2 id=\"硬中断\"><a href=\"#硬中断\" class=\"headerlink\" title=\"硬中断\"></a>硬中断</h2><p>硬件设备通知CPU就绪中使用，分为：</p>\n<h3 id=\"可屏蔽中断\"><a href=\"#可屏蔽中断\" class=\"headerlink\" title=\"可屏蔽中断\"></a>可屏蔽中断</h3><p>外设或借口的中断、可以在CPU处理其他紧急操作时忽略或屏蔽</p>\n<h3 id=\"不可屏蔽中断\"><a href=\"#不可屏蔽中断\" class=\"headerlink\" title=\"不可屏蔽中断\"></a>不可屏蔽中断</h3><p>电源断电、内存错误等，不可通过软件屏蔽，必须响应中断</p>\n<h2 id=\"软中断\"><a href=\"#软中断\" class=\"headerlink\" title=\"软中断\"></a>软中断</h2><p>软件触发的中断，如定时器、网卡收发包</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>一般为程序调用CPU的指令错误时产生，console能看到 segmention fault、core dumped等</p>\n<p>错误：系统可纠正、纠正成功继续运行(如内存页从磁盘加载)</p>\n<p>陷阱：陷阱主要用在调试中。</p>\n<p>终止：终止是由系统表中的硬件错误或值不一致而导致的。终止不会报告造成异常的指令的所在位置。这是最严重的中断，终止将会调用系统的终止异常处理程序来结束造成异常的进程。</p>\n<h2 id=\"top命令解析\"><a href=\"#top命令解析\" class=\"headerlink\" title=\"top命令解析\"></a>top命令解析</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 10:40:48 up  1:04,  1 user,  load average: 2.39, 2.22, 2.07</span><br><span class=\"line\">任务: 400 total,   2 running, 397 sleeping,   0 stopped,   1 zombie</span><br><span class=\"line\">%Cpu(s):  5.2 us,  3.4 sy,  0.0 ni, 90.5 id,  0.1 wa,  0.0 hi,  0.8 si,  0.0 st</span><br><span class=\"line\">MiB Mem :  15430.3 total,   3579.7 free,   8020.7 used,   3829.9 buff/cache</span><br><span class=\"line\">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   6880.5 avail Mem </span><br><span class=\"line\">ID USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND  </span><br><span class=\"line\">4389 longtao   20   0 6273452 451044 148220 S  37.7   2.9  27:28.46 gnome-shell           </span><br></pre></td></tr></table></figure>\n\n<p>第一行分别为：系统时间、系统已运行时间(1h4min)、用户数、平均CPU负载情况(1分钟、5分钟、15分钟)</p>\n<p>第二行分别为：当前总任务(进程)数量、运行中的2个、休眠397个、stoped0个，zombie0个</p>\n<p>第三为cpu的状态使用情况</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>5.2 us</td>\n<td>用户空间占用CPU%5.2</td>\n</tr>\n<tr>\n<td>3.4 sy</td>\n<td>内核空间占用CPU%3.4</td>\n</tr>\n<tr>\n<td>0.0 ni</td>\n<td>更改过优先级的进程占用CPU%0</td>\n</tr>\n<tr>\n<td>90.5 id</td>\n<td>90.5%的CPU空闲</td>\n</tr>\n<tr>\n<td>0.1 wa</td>\n<td>IO等待占用CPU百分比</td>\n</tr>\n<tr>\n<td>0.8 si</td>\n<td>软中断占用CPU%0.8</td>\n</tr>\n<tr>\n<td>0.0 hi</td>\n<td>硬中断占用</td>\n</tr>\n<tr>\n<td>0.0 st</td>\n<td>steal time,对云主机来说被Hypervisor偷去的CPU所占比例</td>\n</tr>\n</tbody></table>\n<p>第四行为内存状态分别为：物理总内存total、used使用了的、free空闲的、缓存内存</p>\n<p>第五行为swap交换分区状态：total交换分区总量、空闲、使用了的、缓冲的</p>\n<p>第六行往下都是每个进程使用情况：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>进程号</td>\n</tr>\n<tr>\n<td>USER</td>\n<td>用户</td>\n</tr>\n<tr>\n<td>PR</td>\n<td>进程优先级</td>\n</tr>\n<tr>\n<td>NI</td>\n<td>nice值，正表示低优先值、负表示高</td>\n</tr>\n<tr>\n<td>VIRT</td>\n<td>进程使用虚拟内存总量，VIRT=SWAP+RES</td>\n</tr>\n<tr>\n<td>RES</td>\n<td>进程使用的、未释放的物理内存，RES=CODE+DATA</td>\n</tr>\n<tr>\n<td>SHR</td>\n<td>共享内存</td>\n</tr>\n<tr>\n<td>S</td>\n<td>进程状态，D不可中断的睡眠状态 R运行 S睡眠 T跟踪/停止 Z僵尸进程</td>\n</tr>\n<tr>\n<td>%CPU</td>\n<td>CPU占比(对单个CPU的)</td>\n</tr>\n<tr>\n<td>%MEM</td>\n<td>物理内存占比</td>\n</tr>\n<tr>\n<td>TIME+</td>\n<td>进程使用的CPU时间总计，单位为us</td>\n</tr>\n<tr>\n<td>COMMAND</td>\n<td>进程名称和命令</td>\n</tr>\n</tbody></table>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>数字1：查看每个cpu的情况</p>\n<p>数字2：查看每个numa的情况</p>\n<p>数字3：查看某个numa里每个CPU的情况</p>\n<p>字母P：CPU使用排序</p>\n<p>字母M：内存使用排序</p>\n<p>字母m：改变内存和交换区显示</p>\n<p>字母b：高亮运行太进程</p>\n<p>字母f：编排显示</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"Linux瓶颈分析","slug":"systemstructure/linux/linuxperformanceanalysis","date":"2021-05-05T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/linuxperformanceanalysis.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139608R-C.d63f9367c74e1dca73ffbcae473118fa?rik=c734OLrGXr8BPg&riu=http%3a%2f%2fwww.brendangregg.com%2fPerf%2flinux_observability_tools.png&ehk=nHWnEkal2z%2bT0vbSwBOdhejyU03bFpVvmJxFTX6A9tA%3d&risl=&pid=ImgRaw&r=0","content":"<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p>性能优化一项最重要的步骤就是寻找到系统的瓶颈</p>\n<h5 id=\"粗略分析\"><a href=\"#粗略分析\" class=\"headerlink\" title=\"粗略分析\"></a>粗略分析</h5><p>系统响应慢，一般的瓶颈在IO、CPU、内存还有应用。</p>\n<p>使用top查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@172-20-59-60 apt_ui]# top</span><br><span class=\"line\">top - 15:59:31 up 6 days,  1:10,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">Tasks: 144 total,   1 running, 142 sleeping,   0 stopped,   1 zombie</span><br><span class=\"line\"><span class=\"meta\">%</span><span class=\"bash\">Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class=\"line\">KiB Mem :  8009636 total,  5126364 free,  2307032 used,   576240 buff/cache</span><br><span class=\"line\">KiB Swap:        0 total,        0 free,        0 used.  5396772 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\"> 9307 root      20   0  620968  28320   6064 S   0.0  0.4   3:39.37 python3</span><br><span class=\"line\">  861 root      20   0  567404  16752   5992 S   0.0  0.2   0:57.56 tuned</span><br><span class=\"line\">  651 root      20   0   21684   1324    988 S   0.0  0.0   0:47.08 irqbalance</span><br><span class=\"line\">  662 avahi     20   0   55952   2392   1920 S   0.0  0.0   0:35.02 avahi-daemon</span><br><span class=\"line\">  809 root      20   0  113440  12796    308 S   0.0  0.2   0:24.29 dhclient</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li> 输入M，进程列表按内存使用大小降序排序，便于我们观察最大内存使用者使用有问题</li>\n<li> 输入P，进程列表按CPU使用大小降序排序，便于我们观察最耗CPU资源</li>\n<li> 100.0 id 空闲CPU时间百分比，如果这个值过低，表明系统CPU存在瓶颈</li>\n<li> 0.0 wa 等待I/O的CPU时间百分比，如果这个值过高，表明IO存在瓶颈</li>\n</ol>\n<h5 id=\"内存瓶颈\"><a href=\"#内存瓶颈\" class=\"headerlink\" title=\"内存瓶颈\"></a>内存瓶颈</h5><p>一般使用free工具</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@172-20-59-60 apt_ui]# free</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:        8009636     2306408     5126984       25144      576244     5397396</span><br><span class=\"line\">Swap:             0           0           0</span><br></pre></td></tr></table></figure>\n\n<p>缺省时free的单位为KB</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>total</td>\n<td>总物理内存大小</td>\n</tr>\n<tr>\n<td>used</td>\n<td>已使用物理内存大小</td>\n</tr>\n<tr>\n<td>free</td>\n<td>未分配物理内存大小</td>\n</tr>\n<tr>\n<td>shared</td>\n<td>共享的物理内存大小</td>\n</tr>\n<tr>\n<td>buff/cache</td>\n<td>为了提高系统的读写速度（包含磁盘块的读写，文件的读写等），操作系统将部分内存作为缓存使用，该数值为缓存占用的物理内存大小</td>\n</tr>\n<tr>\n<td>available</td>\n<td>可用的物理内存大小</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>total</td>\n<td>Swap 分区的总大小</td>\n</tr>\n<tr>\n<td>used</td>\n<td>已使用的 Swap 分区大小</td>\n</tr>\n<tr>\n<td>free</td>\n<td>未使用的 Swap 分区大小</td>\n</tr>\n</tbody></table>\n<p>根据上表，在不考虑 Swap 分区的情况下，内存计算如下：<br>总内存大小：Mem.total = Mem.used + Mem.free + Mem.shared + Mem.buff/cache<br>理论上实际可用内存大小：Mem.actual = Mem.total - Mem.used - Mem.shared = Mem.free + Mem.buff/cache</p>\n<p>在考虑 Swap 分区的情况下，内存计算如下：<br>总内存大小：Mem.total = Mem.used + Mem.free + Mem.shared + Mem.buff/cache<br>理论上实际可用内存大小：Mem.actual = Mem.total - Mem.used - Mem.shared + Swap.free = Mem.free + Mem.buff/cache + Swap.free</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PageCache.size</td>\n<td>可以回收的 PageCache 大小，计算公式见上图</td>\n</tr>\n<tr>\n<td>SlabCache.size</td>\n<td>可以回收的 SlabCache 大小 ，计算公式见上图</td>\n</tr>\n<tr>\n<td>WaterMark.low</td>\n<td>支持系统使用的最低水位线，计算公式见上图</td>\n</tr>\n</tbody></table>\n<p>Mem.available = Mem.free + PageCache.size + SlabCache.size - WaterMark.low</p>\n<p>进一步的监视内存使用情况，可使用vmstat工具，可实时动态监视操作系统的内存和虚拟内存的动态变化使用情况</p>\n<p>vmstat [delay] [count] </p>\n<ul>\n<li>  delay是两次输出之间的延迟时间；</li>\n<li>  count是指按照这个时间间隔统计的次数。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@172-20-59-60 apt_ui]# vmstat 1 3</span><br><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 1  0      0 5126380   2068 574208    0    0     0    22    4    8  0  0 100  0  0</span><br><span class=\"line\"> 0  0      0 5126488   2068 574208    0    0     0     0  422   53  0  0 100  0  0</span><br><span class=\"line\"> 0  0      0 5126488   2068 574208    0    0     0     0  392   49  0  0 100  0  0</span><br></pre></td></tr></table></figure>\n\n<p>Procs（进程）:</p>\n<ul>\n<li>  r: 运行队列中进程数量</li>\n<li>  b: 等待IO的进程数量</li>\n</ul>\n<p>Memory（内存）:</p>\n<ul>\n<li>  swpd: 使用虚拟内存大小</li>\n<li>  free: 可用内存大小</li>\n<li>  buff: 用作缓冲的内存大小</li>\n<li>  cache: 用作缓存的内存大小</li>\n</ul>\n<p>Swap:</p>\n<ul>\n<li>  si: 每秒从交换区写到内存的大小</li>\n<li>  so: 每秒写入交换区的内存大小</li>\n</ul>\n<p>IO：（现在的Linux版本块的大小为1024bytes）</p>\n<ul>\n<li>  bi: 每秒读取的块数</li>\n<li>  bo: 每秒写入的块数</li>\n</ul>\n<p>system：</p>\n<ul>\n<li>  in: 每秒中断数，包括时钟中断</li>\n<li>  cs: 每秒上下文切换数</li>\n</ul>\n<p>CPU（以百分比表示）</p>\n<ul>\n<li>  us: 用户进程执行时间(user time)</li>\n<li>  sy: 系统进程执行时间(system time)</li>\n<li>  id: 空闲时间(包括IO等待时间)</li>\n<li>  wa: 等待IO时间</li>\n</ul>\n<p>内存测试工具我们使用Stream，基准测试，注意数据仅在相同软件相同版本有比较价值</p>\n<h5 id=\"IO瓶颈\"><a href=\"#IO瓶颈\" class=\"headerlink\" title=\"IO瓶颈\"></a>IO瓶颈</h5><p>如果IO存在性能瓶颈，top工具中的%wa会偏高</p>\n<p>可使用iostat 进一步分析</p>\n<p>iostat　[paras] [delay] [count] </p>\n<ul>\n<li>  -c显示CPU使用情况</li>\n<li>  -d 显示磁盘使用情况</li>\n<li>  -k 以 KB 为单位显示</li>\n<li>  -m 以 M 为单位显示</li>\n<li>  -N 显示磁盘阵列(LVM) 信息</li>\n<li>  -p[磁盘] 显示磁盘和分区的情况</li>\n<li>  -t 显示终端和CPU的信息</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-59-60 apt_ui]# iostat 3 3</span><br><span class=\"line\">Linux 3.10.0-693.el7.x86_64 (172-20-59-60)      12/31/2020      _x86_64_        (8 CPU)</span><br><span class=\"line\"></span><br><span class=\"line\">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class=\"line\">           0.03    0.00    0.02    0.02    0.00   99.93</span><br><span class=\"line\"></span><br><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.08         0.59         0.88     308042     462261</span><br><span class=\"line\">vdb               0.52         0.01       176.61       6256   92643328</span><br><span class=\"line\"></span><br><span class=\"line\">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class=\"line\">           0.04    0.00    0.00    0.00    0.00   99.96</span><br><span class=\"line\"></span><br><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.00         0.00         0.00          0          0</span><br><span class=\"line\">vdb               0.00         0.00         0.00          0          0</span><br><span class=\"line\"></span><br><span class=\"line\">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class=\"line\">           0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class=\"line\"></span><br><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.00         0.00         0.00          0          0</span><br><span class=\"line\">vdb               0.00         0.00         0.00          0          0</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  %user：CPU处在用户模式下的时间百分比。</li>\n<li>  %nice：CPU处在带NICE值的用户模式下的时间百分比。</li>\n<li>  %system：CPU处在系统模式下的时间百分比。</li>\n<li>  %iowait：CPU等待输入输出完成时间的百分比。</li>\n<li>  %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li>\n<li>  %idle：CPU空闲时间百分比。</li>\n<li>  rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s</li>\n<li>  wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s</li>\n<li>  r/s: 每秒完成的读 I/O 设备次数。即 rio/s</li>\n<li>  w/s: 每秒完成的写 I/O 设备次数。即 wio/s</li>\n<li>  rsec/s: 每秒读扇区数。即 rsect/s</li>\n<li>  wsec/s: 每秒写扇区数。即 wsect/s</li>\n<li>  rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li>\n<li>  wkB/s: 每秒写K字节数。是 wsect/s 的一半。</li>\n<li>  avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。</li>\n<li>  avgqu-sz: 平均I/O队列长度。</li>\n<li>  await: 平均每次设备I/O操作的等待时间 (毫秒)。</li>\n<li>  svctm: 平均每次设备I/O操作的服务时间 (毫秒)。</li>\n<li>  %util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</li>\n</ul>\n<p>磁盘测试工具我们一般使用iperf3，注意数据仅在相同软件相同版本有比较价值</p>\n<h3 id=\"性能测试工具\"><a href=\"#性能测试工具\" class=\"headerlink\" title=\"性能测试工具\"></a>性能测试工具</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139608R-C.d63f9367c74e1dca73ffbcae473118fa?rik=c734OLrGXr8BPg&riu=http://www.brendangregg.com/Perf/linux_observability_tools.png&ehk=nHWnEkal2z+T0vbSwBOdhejyU03bFpVvmJxFTX6A9tA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"幽灵熔断","slug":"systemstructure/linux/meltdownspectre","date":"2020-08-25T14:24:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/meltdownspectre.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139657R-C.b99abc88fde8d7734d20066ed62d574f?rik=ikTwDJb6AKBbIg&riu=http%3a%2f%2fimg1.mydrivers.com%2fimg%2f20180326%2f7ad298a21c1e40f69f4eac81007e74a9.png&ehk=oGDeClWmtgCwNv4GlhChppBQcmJ1P2UGK34htcD2Ry0%3d&risl=&pid=ImgRaw&r=0","content":"<p>[toc]</p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>Meltdown/Spectre被发现于2018年, 是很有影响力的cpu漏洞。</p>\n<p>Meltdown（熔断）对应编号恶意数据缓存加载 CVE-2017-5754 。</p>\n<p>Spectre （幽灵）对应编号边界检查绕过 CVE-2017-5753 、分支目标注入 CVE-2017-5715 。</p>\n<p>Meltdown 影响几乎所有的 Intel CPU（从1995年起）以及部分 ARM CPU。 Spectre 拥有更广的影响范围，在 Meltdown 的情况下，恶意程序可读取某些自身无权限访问的数据。利用此漏洞低权限用户可以访问到本身无权限访问的内容，例如用户密码、加密密钥。</p>\n<p>Spectre 恶意利用程序，可导致用户的帐号、密码泄漏。在公共云服务器上，可能打破界限，从一台虚拟机器获取到另一个用户的权限。</p>\n<h3 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h3><p>指令周期：CPU取出一条指令并执行该指令所需的时间称为指令周期，指令周期的长短与指令的复杂程度有关，一般多个CPU周期组成指令周期。</p>\n<p>CPU周期：又称机器周期，通常用从主存读取一条指令的最短时间来规定CPU周期，一般多个时钟周期组成CPU周期</p>\n<p>时钟周期：时钟周期是处理操作的最基本时间单位，由机器的主频决定（超到20GHZ，全人类感谢你）</p>\n<h3 id=\"CPU的执行\"><a href=\"#CPU的执行\" class=\"headerlink\" title=\"CPU的执行\"></a>CPU的执行</h3><h4 id=\"基本过程\"><a href=\"#基本过程\" class=\"headerlink\" title=\"基本过程\"></a>基本过程</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211027/16353092843-4-257058.jpg\" alt=\"img\"></p>\n<p>cpu一般按照 取指令–&gt;指令译码—&gt;指令执行–&gt;存储访问–&gt;写回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">取指令 --&gt; 指令译码;</span><br><span class=\"line\">指令译码--&gt;指令执行;</span><br><span class=\"line\">指令执行--&gt;存储访问;</span><br><span class=\"line\">存储访问--&gt;写回;</span><br></pre></td></tr></table></figure>\n\n<p> 取指令:Instruction Fetch,从存储器取指令到CPU</p>\n<p>指令译码:Instruction Decode，对取回的指令进行拆分和解释，识别和区分出不同的指令类别及各种获取操作数的方法</p>\n<p>指令执行:Instruction Execute，使用硬件功能单元执行指令，最常见功能单元为算术逻辑部件运算器（Arithmetic Logical Unit，ALU）</p>\n<p>存储访问:Memory Access，根据指令需要，有可能要访问主存，读取操作数，具体见下表</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>算法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>隐含寻址</td>\n<td>默认操作数地址</td>\n<td>不访存</td>\n<td>数据范围受限</td>\n</tr>\n<tr>\n<td>立即寻址</td>\n<td>D = A</td>\n<td>不访存</td>\n<td>操作数值范围受限</td>\n</tr>\n<tr>\n<td>直接寻址</td>\n<td>EA = A</td>\n<td>简单</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>间接寻址</td>\n<td>EA = (A)</td>\n<td>地址范围大</td>\n<td>多次访存</td>\n</tr>\n<tr>\n<td>寄存器寻址</td>\n<td>EA = R</td>\n<td>不访存</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>寄存器间接寻址</td>\n<td>EA = ®</td>\n<td>地址范围大</td>\n<td>访存</td>\n</tr>\n<tr>\n<td>偏移寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>段寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>堆栈寻址</td>\n<td>EA = SP</td>\n<td>不访存</td>\n<td>应用受限</td>\n</tr>\n</tbody></table>\n<p>写回:把执行指令阶段的运行结果数据“写回”到某种存储形式，经常是写到cpu内部寄存器以便下次快速使用</p>\n<h4 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h4><p>若处理器无流水线结构，一条指令执行一般需要五个处理器周期；流水线使用锁存器（latch，用来缓存电信号）让不同指令的各步操作重叠，从而实现多条指令在不同周期并行处理，只执行一条指令的话，流水线不会提高效率。</p>\n<h4 id=\"分支预测\"><a href=\"#分支预测\" class=\"headerlink\" title=\"分支预测\"></a>分支预测</h4><p>流水线架构对顺序执行的命令，性能提升明显，但遇到命令跳转（goto系列等）就会性能降低，那么就出现了分支预测期，提前把预测到的指令存入流水线，分支跳转指令完成后如果预测正确，流水线正常运行，若错误，清空流水线然后执行正确的指令</p>\n<h4 id=\"乱序执行\"><a href=\"#乱序执行\" class=\"headerlink\" title=\"乱序执行\"></a>乱序执行</h4><p>打乱程序原本的执行顺序（类似上层使用异步，编译器也会乱序执行）</p>\n<p>cpu的乱序执行一般都使用Tomasulo算法，包括</p>\n<ul>\n<li>Common Data Bus (CDB).</li>\n<li>Unified Reservation Station (Scheduler).</li>\n<li>Register Renaming (Reorder Buffer).</li>\n</ul>\n<p>该算法虽然是乱序执行, 但是会顺序完成 (retire), 只有在retire后它的输出才会architectually visible (简单地说, 不影响程序逻辑), 但是没有architectually visible不等于没有影响, 当输出更新到reservation station后, 因为cdb的存在, 其他指令已经可以读到. 另外, 非常重要的一点, 异常只有在指令retire的时候才会触发, 对于上面的例子, 即使cpu已经检查到第一条指令没有访问权限, 也只能等到该指令retire时才会触发, 取决于该指令在ROB的位置, 可能马上触发也可能很久之后, ROB容量可以很容易做到比如192这个级别.</p>\n<h3 id=\"熔断漏洞（利用乱序执行）\"><a href=\"#熔断漏洞（利用乱序执行）\" class=\"headerlink\" title=\"熔断漏洞（利用乱序执行）\"></a>熔断漏洞（利用乱序执行）</h3><p>cpu在执行A语句的同时将B语句中的内存位置的信息加载到cache中，这个加载的过程忽略了权限的判断之后再执行B、C语句，在执行B语句时发现并没有权限，所以放弃乱序执行的结果，回滚到最初的状态依次执行。此时cache中的信息没有还原。之后通过边信道攻击来测试数据，发现对于某一个数据的访问要远远快于其他数据的访问，那么就可推断数据在cache中，并且可以反推回它的内存地址。</p>\n<h3 id=\"幽灵漏洞（利用分支预测）\"><a href=\"#幽灵漏洞（利用分支预测）\" class=\"headerlink\" title=\"幽灵漏洞（利用分支预测）\"></a>幽灵漏洞（利用分支预测）</h3><p>和熔断差不多，比如if else 中，提前预测某一条，预测错误，状态回滚，边信道攻击，反推内存地址</p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>打补丁，关闭乱序执行、分支预测，不过个人电脑建议别关，关了会影响性能。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"内存超分原理","slug":"systemstructure/linux/memoryoverscore","date":"2020-07-25T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/memoryoverscore.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139713OIP-C.xGR2ur4Cwbjx7OEW-pjD9gHaDa?pid=ImgDet&rs=1","content":"<p>KVM中内存也是允许过载使用（over-commit）的，KVM能够让分配给客户机的内存总数大于实际可用的物理内存总数。由于客户机操作系统及其上的应用程序并非一直100%地利用其分配到的内存，而且宿主机上的多个客户机一般也不会同时达到100%的内存使用率，所以内存过载分配是可行的。一般来说，有如下三种方式来实现内存的过载使用。</p>\n<ol>\n<li>内存交换（swapping）：用交换空间（swap space）来弥补内存的不足。</li>\n<li>气球（ballooning）：通过virio_balloon驱动来实现宿主机Hypervisor和客户机之间的协作来完成。</li>\n<li>页共享（page sharing）：通过KSM（Kernel Samepage Merging）合并多个客户机进程使用的相同内存页。</li>\n</ol>\n<p>其中，第一种内存交换的方式是最成熟的（Linux中很早就开始应用），也是目前被广泛使用的，不过，它相比于KSM和ballooning的方式效率较为低一些。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"proc目录解析","slug":"systemstructure/linux/proc","date":"2020-05-23T13:23:23.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/proc.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351398132021100110022315.jpg","content":"<p>在linux中，proc是一个伪文件系统，提供了访问内核数据的一些方法</p>\n<p>proc中PID目录存有进程的一些信息</p>\n<h2 id=\"pid目录ls\"><a href=\"#pid目录ls\" class=\"headerlink\" title=\"pid目录ls\"></a>pid目录ls</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">root@longtaoXiaoXinPro13-2020#</span><span class=\"bash\"> ls /proc/1</span></span><br><span class=\"line\">arch_status         cwd        mem            patch_state   stat</span><br><span class=\"line\">attr                environ    mountinfo      personality   statm</span><br><span class=\"line\">autogroup           exe        mounts         projid_map    status</span><br><span class=\"line\">auxv                fd         mountstats     root          syscall</span><br><span class=\"line\">cgroup              fdinfo     net            sched         task</span><br><span class=\"line\">clear_refs          gid_map    ns             schedstat     timens_offsets</span><br><span class=\"line\">cmdline             io         numa_maps      sessionid     timers</span><br><span class=\"line\">comm                limits     oom_adj        setgroups     timerslack_ns</span><br><span class=\"line\">coredump_filter     loginuid   oom_score      smaps         uid_map</span><br><span class=\"line\">cpu_resctrl_groups  map_files  oom_score_adj  smaps_rollup  wchan</span><br><span class=\"line\">cpuset              maps       pagemap        stack</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"attr\"><a href=\"#attr\" class=\"headerlink\" title=\"attr\"></a>attr</h4><p>目录， 可读可写，安全相关的一些属性，用来支持安全模块，如SELinux等</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /proc/1/attr</span></span><br><span class=\"line\"><span class=\"meta\">apparmor#</span></span><br><span class=\"line\"><span class=\"bash\">current<span class=\"comment\">#当前安全属性</span></span></span><br><span class=\"line\"><span class=\"meta\">exec#</span><span class=\"bash\">执行execve时设置的安全属性</span></span><br><span class=\"line\"><span class=\"meta\">keycreate#</span><span class=\"bash\"> add_key时设置属性</span>  </span><br><span class=\"line\"><span class=\"meta\">smack#</span></span><br><span class=\"line\"><span class=\"bash\">context<span class=\"comment\">#</span></span>   </span><br><span class=\"line\"><span class=\"meta\">display#</span><span class=\"bash\"> </span></span><br><span class=\"line\"><span class=\"meta\">fscreate#</span><span class=\"bash\"> </span> </span><br><span class=\"line\"><span class=\"meta\">prev#</span><span class=\"bash\"> </span> </span><br><span class=\"line\"><span class=\"meta\">sockcreate#</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4>","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"shc与upx加密混淆压缩","slug":"systemstructure/linux/shcandupx","date":"2021-04-25T15:27:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/shcandupx.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635140046OIP-C.6nySy7QLC94Nm0SNCoL5UwHaGE?pid=ImgDet&rs=1","content":"<p>[toc]</p>\n<h2 id=\"shc混淆\"><a href=\"#shc混淆\" class=\"headerlink\" title=\"shc混淆\"></a>shc混淆</h2><h3 id=\"shc安装\"><a href=\"#shc安装\" class=\"headerlink\" title=\"shc安装\"></a>shc安装</h3><p>从官网下载<a href=\"http://www.datsi.fi.upm.es/~frosal/sources/\">http://www.datsi.fi.upm.es/~frosal/sources/</a> (最新2015年的shc-3.8.9b.tgz)，或者源码下载<a href=\"https://github.com/neurobin/shc\">https://github.com/neurobin/shc</a> (有最新的)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://www.datsi.fi.upm.es/~frosal/sources/shc-3.8.9b.tgz</span><br><span class=\"line\">tar zxvf shc-3.8.9b.tgz</span><br><span class=\"line\">cd shc-3.8.9b</span><br><span class=\"line\">make clean</span><br><span class=\"line\">make test # 等待paused 然后回车</span><br><span class=\"line\">make strings&amp;install # 等待继续输入yes</span><br></pre></td></tr></table></figure>\n\n<p>shc命令说明</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-e %s  Expiration date in dd/mm/yyyy format [none]</span><br><span class=\"line\">-m %s  Message to display upon expiration [&quot;Please contact your provider&quot;]</span><br><span class=\"line\">-f %s  File name of the script to compile</span><br><span class=\"line\">-i %s  Inline option for the shell interpreter i.e: -e</span><br><span class=\"line\">-x %s  eXec command, as a printf format i.e: exec(&#x27;%s&#x27;,@ARGV);</span><br><span class=\"line\">-l %s  Last shell option i.e: --</span><br><span class=\"line\">-r     Relax security. Make a redistributable binary</span><br><span class=\"line\">-v     Verbose compilation</span><br><span class=\"line\">-D     Switch ON debug exec calls [OFF]</span><br><span class=\"line\">-T     Allow binary to be traceable [no]</span><br><span class=\"line\">-C     Display license and exit</span><br><span class=\"line\">-A     Display abstract and exit</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用shc给hello-world脚本加密\"><a href=\"#使用shc给hello-world脚本加密\" class=\"headerlink\" title=\"使用shc给hello world脚本加密\"></a>使用shc给hello world脚本加密</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 我们先创建一个sh</span></span><br><span class=\"line\">[root@localhost ~]# echo &#x27;#!/bin/bash&#x27; &gt; hello.sh;echo &quot;echo hello world&quot; &gt;&gt; hello.sh</span><br><span class=\"line\">[root@localhost ~]# chmod +x hello.sh;./hello.sh</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@localhost ~]# shc -f hello.sh</span><br><span class=\"line\">[root@localhost ~]# ./hello.sh.x</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<p>我们使用readelf查看发现是elf文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# readelf -h hello.sh.x </span><br><span class=\"line\">ELF 头：</span><br><span class=\"line\">  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class=\"line\">  Class:                             ELF64</span><br><span class=\"line\">  Data:                              2&#x27;s complement, little endian</span><br><span class=\"line\">  Version:                           1 (current)</span><br><span class=\"line\">  OS/ABI:                            UNIX - System V</span><br><span class=\"line\">  ABI Version:                       0</span><br><span class=\"line\">  Type:                              EXEC (可执行文件)</span><br><span class=\"line\">  Machine:                           Advanced Micro Devices X86-64</span><br><span class=\"line\">  Version:                           0x1</span><br><span class=\"line\">  入口点地址：              0x400d00</span><br><span class=\"line\">  程序头起点：              64 (bytes into file)</span><br><span class=\"line\">  Start of section headers:          9376 (bytes into file)</span><br><span class=\"line\">  标志：             0x0</span><br><span class=\"line\">  本头的大小：       64 (字节)</span><br><span class=\"line\">  程序头大小：       56 (字节)</span><br><span class=\"line\">  Number of program headers:         9</span><br><span class=\"line\">  节头大小：         64 (字节)</span><br><span class=\"line\">  节头数量：         28</span><br><span class=\"line\">  字符串表索引节头： 27</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"shc简单的原理介绍\"><a href=\"#shc简单的原理介绍\" class=\"headerlink\" title=\"shc简单的原理介绍\"></a>shc简单的原理介绍</h3><p>我们在使用<code>shc -f hello.sh</code>时会发现还生成了一个hello.sh.x.c的文件，阅读c我们知道shc是将脚本用rc4进行加密，然后将加密后的脚本、密钥、解密程序再用c编译成elf文件，在执行elf时再将加密的脚本解密运行。  看了shc的混淆方式，我们也可以用其他编译行语言(例如go、rust、c++)等自己实现，更换加解密算法，甚至不用加解密算法。</p>\n<h3 id=\"从shc-可执行文件获取源码-逆向\"><a href=\"#从shc-可执行文件获取源码-逆向\" class=\"headerlink\" title=\"从shc 可执行文件获取源码(逆向)\"></a>从shc 可执行文件获取源码(逆向)</h3><ol>\n<li>使用IDA等反编译工具动态调试，找解密后的函数</li>\n<li>使用coredump 从内存读取。</li>\n<li>使用一些现有的工具，例如<a href=\"https://github.com/yanncam/UnSHc%EF%BC%8C%E6%96%B0%E7%9A%84shc%E5%8A%A0%E5%85%A5%E4%BA%86linux%E5%86%85%E6%A0%B8%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%A5%BD%E5%83%8F%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86\">https://github.com/yanncam/UnSHc，新的shc加入了linux内核本身的安全机制，好像不能用了</a></li>\n</ol>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><ol>\n<li>使用gzexe混淆</li>\n<li> shc -e 过期时间挺好用的</li>\n</ol>\n<h2 id=\"使用upx加壳\"><a href=\"#使用upx加壳\" class=\"headerlink\" title=\"使用upx加壳\"></a>使用upx加壳</h2><h3 id=\"upx安装\"><a href=\"#upx安装\" class=\"headerlink\" title=\"upx安装\"></a>upx安装</h3><p>从<a href=\"https://github.com/upx/upx\">https://github.com/upx/upx</a> 下载源码安装或其他包管理器安装</p>\n<h3 id=\"upx-演示\"><a href=\"#upx-演示\" class=\"headerlink\" title=\"upx 演示\"></a>upx 演示</h3><p>在我们刚刚使用shc对helloworld脚本编译生成elf后，我们可以使用upx对此elf进行加壳压缩，也算是一种混淆方式</p>\n<p>upx压缩前 11k</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# ls -lh ./hello.sh.x</span><br><span class=\"line\">-rwx--x--x. 1 root root 11K 7月  23 10:19 ./hello.sh.x</span><br></pre></td></tr></table></figure>\n\n<p>upx 压缩后 6.9k, -9代表压缩等级（1-9,9个等级）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# upx -9 ./hello.sh.x;ls -lh ./hello.sh.x</span><br><span class=\"line\">                       Ultimate Packer for eXecutables</span><br><span class=\"line\">                          Copyright (C) 1996 - 2013</span><br><span class=\"line\">UPX 3.91        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Sep 30th 2013</span><br><span class=\"line\"></span><br><span class=\"line\">        File size         Ratio      Format      Name</span><br><span class=\"line\">   --------------------   ------   -----------   -----------</span><br><span class=\"line\">     11168 -&gt;      7004   62.71%  linux/ElfAMD   hello.sh.x                    </span><br><span class=\"line\"></span><br><span class=\"line\">Packed 1 file.</span><br><span class=\"line\">-rwx--x--x. 1 root root 6.9K 7月  23 10:19 ./hello.sh.x</span><br></pre></td></tr></table></figure>\n\n<p>我们压缩后的helloworld依然正常运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# ./hello.sh.x </span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"upx原理\"><a href=\"#upx原理\" class=\"headerlink\" title=\"upx原理\"></a>upx原理</h3><p>对elf文件进行压缩并插入解压代码，在运行时（加载到内存时）解压代码</p>\n<h3 id=\"脱壳工具\"><a href=\"#脱壳工具\" class=\"headerlink\" title=\"脱壳工具\"></a>脱壳工具</h3><p>略</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"简洁明了的systemd的使用","slug":"systemstructure/linux/systemd","date":"2021-09-06T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/systemd.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20210923/systemd.11o5sef98c4w.png","content":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><h3 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h3><p>在systemd之前使用initd 管理服务（把启动脚本放在在<code>/etc/init.d/</code>下），但是有两个主要缺点：</p>\n<ol>\n<li>线性(串行)启动导致启动时间过长</li>\n<li>initd只负责在系统启动时启动启动脚本，若要处理脚本状态需要自己实现，导致脚本复杂</li>\n</ol>\n<h3 id=\"systemd设计目标\"><a href=\"#systemd设计目标\" class=\"headerlink\" title=\"systemd设计目标\"></a>systemd设计目标</h3><ol>\n<li>为服务启动和管理提供全套解决方案</li>\n<li>可完全取代init.d ，性能更强，功能更多</li>\n</ol>\n<h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><h3 id=\"系统管理\"><a href=\"#系统管理\" class=\"headerlink\" title=\"系统管理\"></a>系统管理</h3><h4 id=\"综合-systemctl\"><a href=\"#综合-systemctl\" class=\"headerlink\" title=\"综合(systemctl))\"></a>综合(systemctl))</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">常用命令</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重启</span></span><br><span class=\"line\">systemctl reboot</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 关闭电源</span></span><br><span class=\"line\">systemctl poweroff</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> CPU暂停</span></span><br><span class=\"line\">systemctl halt</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 挂起</span></span><br><span class=\"line\">systemctl suspend</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"用户-loginctl\"><a href=\"#用户-loginctl\" class=\"headerlink\" title=\"用户(loginctl)\"></a>用户(loginctl)</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list-sessions            List sessions</span><br><span class=\"line\">session-status [ID...]   Show session status</span><br><span class=\"line\">show-session [ID...]     Show properties of sessions or the manager</span><br><span class=\"line\">activate [ID]            Activate a session</span><br><span class=\"line\">lock-session [ID...]     Screen lock one or more sessions</span><br><span class=\"line\">unlock-session [ID...]   Screen unlock one or more sessions</span><br><span class=\"line\">lock-sessions            Screen lock all current sessions</span><br><span class=\"line\">unlock-sessions          Screen unlock all current sessions</span><br><span class=\"line\">terminate-session ID...  Terminate one or more sessions</span><br><span class=\"line\">kill-session ID...       Send signal to processes of a session</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"时间-timedatectl\"><a href=\"#时间-timedatectl\" class=\"headerlink\" title=\"时间(timedatectl)\"></a>时间(timedatectl)</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">status                   Show current time settings</span><br><span class=\"line\">show                     Show properties of systemd-timedated</span><br><span class=\"line\">set-time TIME            Set system time</span><br><span class=\"line\">set-timezone ZONE        Set system time zone</span><br><span class=\"line\">list-timezones           Show known time zones</span><br><span class=\"line\">set-local-rtc BOOL       Control whether RTC is in local time</span><br><span class=\"line\">set-ntp BOOL             Enable or disable network time synchronization</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"本地化设置-localectl\"><a href=\"#本地化设置-localectl\" class=\"headerlink\" title=\"本地化设置(localectl)\"></a>本地化设置(localectl)</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">status                   Show current locale settings</span><br><span class=\"line\">set-locale LOCALE...     Set system locale</span><br><span class=\"line\">list-locales             Show known locales</span><br><span class=\"line\">set-keymap MAP [MAP]     Set console and X11 keyboard mappings</span><br><span class=\"line\">list-keymaps             Show known virtual console keyboard mappings</span><br><span class=\"line\">set-x11-keymap LAYOUT [MODEL [VARIANT [OPTIONS]]]</span><br><span class=\"line\">                         Set X11 and console keyboard mappings</span><br><span class=\"line\">list-x11-keymap-models   Show known X11 keyboard mapping models</span><br><span class=\"line\">list-x11-keymap-layouts  Show known X11 keyboard mapping layouts</span><br><span class=\"line\">list-x11-keymap-variants [LAYOUT]</span><br><span class=\"line\">                         Show known X11 keyboard mapping variants</span><br><span class=\"line\">list-x11-keymap-options  Show known X11 keyboard mapping options</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"启动信息-systemd-analyze\"><a href=\"#启动信息-systemd-analyze\" class=\"headerlink\" title=\"启动信息(systemd-analyze)\"></a>启动信息(systemd-analyze)</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time                    Print time spent in the kernel</span><br><span class=\"line\">blame                   Print list of running units ordered by time to init</span><br><span class=\"line\">critical-chain          Print a tree of the time critical chain of units</span><br><span class=\"line\">plot                    Output SVG graphic showing service initialization</span><br><span class=\"line\">dot                     Output dependency graph in dot(1) format</span><br><span class=\"line\">set-log-level LEVEL     Set logging threshold for systemd</span><br><span class=\"line\">dump                    Output state serialization of service manager</span><br><span class=\"line\">verify FILE...          Check unit files for correctness</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"主机信息-hostnamectl\"><a href=\"#主机信息-hostnamectl\" class=\"headerlink\" title=\"主机信息(hostnamectl)\"></a>主机信息(hostnamectl)</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">status                 Show current hostname settings</span><br><span class=\"line\">set-hostname NAME      Set system hostname</span><br><span class=\"line\">set-icon-name NAME     Set icon name for host</span><br><span class=\"line\">set-chassis NAME       Set chassis type for host</span><br><span class=\"line\">set-deployment NAME    Set deployment environment for host</span><br><span class=\"line\">set-location NAME      Set location for host</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"资源管理\"><a href=\"#资源管理\" class=\"headerlink\" title=\"资源管理\"></a>资源管理</h3><h4 id=\"支持的资源\"><a href=\"#支持的资源\" class=\"headerlink\" title=\"支持的资源\"></a>支持的资源</h4><p>文件后缀就是资源名，例如service的后缀为.service</p>\n<table>\n<thead>\n<tr>\n<th>资源</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>service</td>\n<td>定义系统服务</td>\n</tr>\n<tr>\n<td>socket</td>\n<td>标识进程间通信使用的socket文件</td>\n</tr>\n<tr>\n<td>target</td>\n<td>模拟实现“运行级别”，多个 Unit 构成的一个组</td>\n</tr>\n<tr>\n<td>device</td>\n<td>定义内核识别的设备</td>\n</tr>\n<tr>\n<td>snapshot</td>\n<td>管理systemd快照</td>\n</tr>\n<tr>\n<td>scope</td>\n<td>非systemd启动的进程</td>\n</tr>\n<tr>\n<td>timer</td>\n<td>管理计划任务</td>\n</tr>\n<tr>\n<td>slice</td>\n<td>进程组</td>\n</tr>\n<tr>\n<td>path</td>\n<td>文件</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换设备</td>\n</tr>\n<tr>\n<td>mount</td>\n<td>文件系统挂载点</td>\n</tr>\n<tr>\n<td>automount</td>\n<td>自动挂载点</td>\n</tr>\n</tbody></table>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">基础命令</span></span><br><span class=\"line\">systemctl status # 状态</span><br><span class=\"line\">systemctl start # 开启</span><br><span class=\"line\">syttemctl stop # 关闭</span><br><span class=\"line\">systemctl restart # 重启</span><br><span class=\"line\">systemctl reload # 重载</span><br><span class=\"line\">systemctl kill # 杀死</span><br><span class=\"line\">systemctl enable # 开机启动</span><br><span class=\"line\">systemctl disable # 开机不启动</span><br><span class=\"line\">systemctl mask # 屏蔽</span><br><span class=\"line\">systemctl unmask # 不屏蔽</span><br><span class=\"line\">systemctl show # 查看配置</span><br><span class=\"line\">systemctl cat # 查看配置文件内容</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询命令</span></span><br><span class=\"line\">systemctl  is-active </span><br><span class=\"line\">systemctl is-failed</span><br><span class=\"line\">systemctl is-enabled</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 列出依赖</span></span><br><span class=\"line\">systemctl list-dependencies</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">查询列表</span></span><br><span class=\"line\">list-sockets</span><br><span class=\"line\">list-unit-files    </span><br><span class=\"line\">list-jobs </span><br><span class=\"line\">list-timers </span><br><span class=\"line\">list-units </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"启动状态\"><a href=\"#启动状态\" class=\"headerlink\" title=\"启动状态\"></a>启动状态</h4><p>static：不可以自己启动，可以被被其它的 enabled 的服务来唤醒。<br>mask：屏蔽掉了，除非unmask否则无论如何无法启动<br>enable：开机启动<br>disable：开机不启动</p>\n<h4 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a>日志管理</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F --field=FIELD         List all values that a specified field takes</span><br><span class=\"line\">   --new-id128           Generate a new 128-bit ID</span><br><span class=\"line\">   --disk-usage          Show total disk usage of all journal files</span><br><span class=\"line\">   --vacuum-size=BYTES   Reduce disk usage below specified size</span><br><span class=\"line\">   --vacuum-time=TIME    Remove journal files older than specified date</span><br><span class=\"line\">   --flush               Flush all journal data from /run into /var</span><br><span class=\"line\">   --header              Show journal header information</span><br><span class=\"line\">   --list-catalog        Show all message IDs in the catalog</span><br><span class=\"line\">   --dump-catalog        Show entries in the message catalog</span><br><span class=\"line\">   --update-catalog      Update the message catalog database</span><br><span class=\"line\">   --setup-keys          Generate a new FSS key pair</span><br><span class=\"line\">   --verify              Verify journal file consistency</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"怎么写一个Unit\"><a href=\"#怎么写一个Unit\" class=\"headerlink\" title=\"怎么写一个Unit\"></a>怎么写一个Unit</h4><p>最好的说明往往都是官网说明<a href=\"https://www.freedesktop.org/software/systemd/man/systemd.unit.html\">https://www.freedesktop.org/software/systemd/man/systemd.unit.html</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">属性=值</span><br><span class=\"line\">[Service]</span><br><span class=\"line\">属性=值</span><br><span class=\"line\">[Install]</span><br><span class=\"line\">属性=值</span><br></pre></td></tr></table></figure>\n\n<p>一般有 Unit(unit元数据)、Install(定义启动)、Service(配置)三个模块，很多情况下Install模块可省略</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description：简短描述</span><br><span class=\"line\">Documentation：文档地址</span><br><span class=\"line\">Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</span><br><span class=\"line\">Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</span><br><span class=\"line\">BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</span><br><span class=\"line\">Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</span><br><span class=\"line\">After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</span><br><span class=\"line\">Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行</span><br><span class=\"line\">Condition...：当前 Unit 运行必须满足的条件，否则不会运行</span><br><span class=\"line\">Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type：定义启动时的进程行为。它有以下几种值。</span><br><span class=\"line\">Type=simple：默认值，执行ExecStart指定的命令，启动主进程</span><br><span class=\"line\">Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</span><br><span class=\"line\">Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</span><br><span class=\"line\">Type=dbus：当前服务通过D-Bus启动</span><br><span class=\"line\">Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</span><br><span class=\"line\">Type=idle：若有其他任务执行完毕，当前服务才会运行</span><br><span class=\"line\">Workingdirectory: 工作目录</span><br><span class=\"line\">ExecStart：启动当前服务的命令</span><br><span class=\"line\">ExecStartPre：启动当前服务之前执行的命令</span><br><span class=\"line\">ExecStartPost：启动当前服务之后执行的命令</span><br><span class=\"line\">ExecReload：重启当前服务时执行的命令</span><br><span class=\"line\">ExecStop：停止当前服务时执行的命令</span><br><span class=\"line\">ExecStopPost：停止当其服务之后执行的命令</span><br><span class=\"line\">RestartSec：自动重启当前服务间隔的秒数</span><br><span class=\"line\">Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</span><br><span class=\"line\">TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</span><br><span class=\"line\">Environment：指定环境变量</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</span><br><span class=\"line\">RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</span><br><span class=\"line\">Alias：当前 Unit 可用于启动的别名</span><br><span class=\"line\">Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h4><ol>\n<li><p>首先我们用c实现一个简单的http helloworld </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PORT 2333</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFER_SIZE 2048</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RESPONSE_HEADER <span class=\"meta-string\">&quot;HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nAccept-Ranges: bytes\\r\\nContent-Type: text/html\\r\\n\\r\\n&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RESPONSE_BODY <span class=\"meta-string\">&quot;Hello longtaoTechLife!&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"keyword\">int</span> conn)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[BUFFER_SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    bzero(buffer, BUFFER_SIZE);</span><br><span class=\"line\">    len = recv(conn, buffer, BUFFER_SIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span> (<span class=\"string\">&quot;recv len not right&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;&#125;</span><br><span class=\"line\">    send(conn, RESPONSE_HEADER RESPONSE_BODY, <span class=\"keyword\">sizeof</span>(RESPONSE_HEADER RESPONSE_BODY), <span class=\"number\">0</span>);</span><br><span class=\"line\">    close(conn);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span> *argv[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> port = PORT;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">clientSockAddr</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverSockAddr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listener = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> conn;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> optval = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> len = <span class=\"keyword\">sizeof</span>(struct sockaddr_in);</span><br><span class=\"line\">    setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    serverSockAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverSockAddr.sin_port = htons(port);</span><br><span class=\"line\">    serverSockAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(bind(listener,(struct sockaddr *)&amp;serverSockAddr,<span class=\"keyword\">sizeof</span>(serverSockAddr))==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;bind error!&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(listen(listener, <span class=\"number\">10</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;listen failed!&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    conn = accept(listener, (struct sockaddr*)&amp;clientSockAddr, &amp;len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(conn &lt; <span class=\"number\">0</span> || handle(conn) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        close(conn);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;&#125;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>我们试一下正常运行,打印了我们期望的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-59-110 ~]# ./hello.server&amp;</span><br><span class=\"line\">[1] 1460</span><br><span class=\"line\">[root@172-20-59-110 ~]# curl -X GET localhost:2333</span><br><span class=\"line\">Hello longtaoTechLife![root@172-20-59-110 ~]# </span><br></pre></td></tr></table></figure></li>\n<li><p>接下来我们写一个简单的systemd service 写入/etc/systemd/system/hello.service</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=this is longtao&#x27;s hello test</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">ExecStart=/root/hello.server #注意一定要写成绝对地址</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target # 缺少此项无法使用systemctl enable/disable 功能</span><br></pre></td></tr></table></figure></li>\n<li><p>我们用systemctl status hello看一下状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-59-110 ~]# systemctl status hello</span><br><span class=\"line\">● hello.service - this is longtao&#x27;s hello test</span><br><span class=\"line\">   Loaded: loaded (/etc/systemd/system/hello.service; static; vendor preset: disabled) #配置文件路径，是否enable等</span><br><span class=\"line\">   Active: inactive (dead) since 四 2021-07-15 18:14:23 CST; 18s ago # 运行状态，我们能看到未运行</span><br><span class=\"line\">  Process: 708 ExecStart=/root/hello.server </span><br><span class=\"line\"> Main PID: 708 (code=killed, signal=TERM) # 显示进程ID</span><br></pre></td></tr></table></figure></li>\n<li><p>我们启动服务systemctl status hello并打开开机启动 systemctl status hello，再看一下状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">● hello.service - this is longtao&#x27;s hello test</span><br><span class=\"line\">   Loaded: loaded (/etc/systemd/system/hello.service; enabled; vendor preset: disabled) # 我们看到状态enbale开机启动设置成功了</span><br><span class=\"line\">   Active: active (running) since 四 2021-07-15 18:18:25 CST; 26s ago #运行状态为正在运行</span><br><span class=\"line\"> Main PID: 1328 (hello.server)</span><br><span class=\"line\">   CGroup: /system.slice/hello.service   #CGroup下显示所有孜进程，CGroup常用于隔离资源，容器中常用，我们以后再说</span><br><span class=\"line\">           └─1328 /root/hello.server </span><br></pre></td></tr></table></figure></li>\n<li><p>这样我们就实现了一个简单的service，可以快乐的使用systemctl restart\\stop\\等管理我们的服务了。</p>\n</li>\n</ol>\n<h2 id=\"优点-好的特性\"><a href=\"#优点-好的特性\" class=\"headerlink\" title=\"优点(好的特性)\"></a>优点(好的特性)</h2><ol>\n<li>功能强大，使用便捷</li>\n<li>启动速度快</li>\n</ol>\n<h2 id=\"特点-中性特性\"><a href=\"#特点-中性特性\" class=\"headerlink\" title=\"特点(中性特性)\"></a>特点(中性特性)</h2><ol>\n<li>systemd 取代了initd，成为了系统第一个进程(PID为1)</li>\n</ol>\n<h2 id=\"缺点-不好的特性\"><a href=\"#缺点-不好的特性\" class=\"headerlink\" title=\"缺点(不好的特性)\"></a>缺点(不好的特性)</h2><ol>\n<li>体系庞大，使用起来非常复杂</li>\n<li>与操作系统的其他模块耦合性过强，不符合Unix的KISS原则，下面是systemd架构图，可以看出需要很多模块支持<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211027/1635309214webp\" alt=\"img\"></li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"linux","path":"api/tags/linux.json"},{"name":"操作系统","path":"api/tags/操作系统.json"}]},{"title":"VirtioSCSI和virtioBLK","slug":"systemstructure/linux/virtioscsiandvirtioblk","date":"2020-05-22T13:10:51.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/virtioscsiandvirtioblk.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635140092virtio-gpio-1.png","content":"<p><strong>qemu对设备的模拟可以分成两类：全模拟和半模拟。全模拟即完全模拟物理设备的工作过程，使得运行在虚拟机上的软件完全感知不到自身运行环境的差异</strong>。例如qemu中实现了对IDE磁盘、LSI控制器(其上可接SCSI磁盘)等物理存储设备的模拟，原先运行在物理机上的IDE驱动、LSI驱动或应用程序不做任何改动即可运行在虚拟机中。因此，<strong>全模拟的优点比较明显，即不用提供专门针对虚拟化场景的设备驱动，完全可以复用物理环境下的驱动程序。那么全模拟有何缺点呢？全模拟时，虚拟机内部驱动会频繁访问虚拟机IO端口，KVM平台下会导致大量的陷入和陷出操作；另外虚拟机内外数据传输时只能通过以字节为单位的拷贝方式进行，无法直接采用共享内存的方式，因此存在较大的访问性能问题</strong>。</p>\n<p>为解决全虚拟化在性能上的问题，半模拟技术应运而生。它构造了一种虚拟化环境所独有的存储设备，因此<strong>半虚拟化需要在虚拟机内部安装特定的驱动程序才能正常驱使该设备进行工作。通常我们称**虚拟机内部的驱动为前端驱动**，称**负责实现其功能模拟的程序(KVM平台下即为qemu程序)为后端程序*<strong>*，**半模拟技术也常常被叫做前后端技术</strong>。**采用半摸拟技术后，配合前端驱动，虚拟化设备完全可以采用全新的事件通知和数据传递机制进而大幅提升性能， 例如在virtio-blk磁盘中，采用io_event_fd进行前端到后端通知，采用中断注入方式实现后端到前端的通知，并通过IO环(vring)进行数据的共享</strong>。至此，主要说明了virtio-blk产生的背景及其价值。附上qemu所模拟的PC(基于intel i440fx主板架构)的组成结构图，以作为后续深入分析的基础。</p>\n<p>virtio-scsi和virtio-blk都是磁盘的半虚拟化驱动，virtio-scsi解决了virtio-blk的一些限制。</p>\n<p>virtio scsi hba取代virtio blk，这是一种简单的高性能准虚拟化存储设备。然而，<strong>virtio blk的设计固有的局限性如下</strong>：</p>\n<ul>\n<li>•virtio blk的范围有限，这使得新的命令实现变得复杂。每次开发一个新命令时，virtio blk驱动程序都必须在每个客户机中更新。</li>\n<li>•<strong>virtio blk将PCI功能和存储设备映射为1:1，限制了可扩展性</strong>。</li>\n<li>•<strong>virtio blk不是真正的SCSI设备。这会导致一些应用程序在从物理机移动到虚拟机时中断。</strong></li>\n</ul>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"Linux IO模式","slug":"systemstructure/linux/linuxio","date":"2021-03-25T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/linuxio.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139551R-C.33d57d1aac13ec6a4e7f917e0a47bb69?rik=o%2fuWsKRpOPc7MA&riu=http%3a%2f%2fwww.thomas-krenn.com%2fde%2fwikiDE%2fimages%2fd%2fda%2fLinux-io-stack-diagram_v1.0.png&ehk=1OGRYIpfyG0jiVPRMEKwfpXnNXxZpCQUOMRDg4u7Pz0%3d&risl=&pid=ImgRaw&r=0","content":"<p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本文讨论的背景是Linux环境下的network IO。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"概念说明\"><a href=\"#概念说明\" class=\"headerlink\" title=\"概念说明\"></a>概念说明</h3><p>在进行解释之前，首先要说明几个概念：<br>- 用户空间和内核空间<br>- 进程切换<br>- 进程的阻塞<br>- 文件描述符<br>- 缓存 I/O</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a>用户空间与内核空间</h4><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>\n<h4 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h4><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>\n<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：<br>\\1. 保存处理机上下文，包括程序计数器和其他寄存器。<br>\\2. 更新PCB信息。<br>\\3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<br>\\4. 选择另一个进程执行，并更新其PCB。<br>\\5. 更新内存管理的数据结构。<br>\\6. 恢复处理机上下文。</p>\n<p>注：<strong>总而言之就是很耗资源</strong>，具体的可以参考这篇文章：<a href=\"http://guojing.me/linux-kernel-architecture/posts/process-switch/\">进程切换</a></p>\n<h4 id=\"进程的阻塞\"><a href=\"#进程的阻塞\" class=\"headerlink\" title=\"进程的阻塞\"></a>进程的阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p>\n<h4 id=\"文件描述符fd\"><a href=\"#文件描述符fd\" class=\"headerlink\" title=\"文件描述符fd\"></a>文件描述符fd</h4><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>\n<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>\n<h4 id=\"缓存-I-O\"><a href=\"#缓存-I-O\" class=\"headerlink\" title=\"缓存 I/O\"></a>缓存 I/O</h4><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>\n<p><strong>缓存 I/O 的缺点：</strong><br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>\n<h3 id=\"IO模式\"><a href=\"#IO模式\" class=\"headerlink\" title=\"IO模式\"></a>IO模式</h3><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：<br>\\1. 等待数据准备 (Waiting for the data to be ready)<br>\\2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p>\n<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。<br>- 阻塞 I/O（blocking IO）<br>- 非阻塞 I/O（nonblocking IO）<br>- I/O 多路复用（ IO multiplexing）<br>- 信号驱动 I/O（ signal driven IO）<br>- 异步 I/O（asynchronous IO）</p>\n<p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>\n<h4 id=\"阻塞-I-O（blocking-IO）\"><a href=\"#阻塞-I-O（blocking-IO）\" class=\"headerlink\" title=\"阻塞 I/O（blocking IO）\"></a>阻塞 I/O（blocking IO）</h4><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://segmentfault.com/img/bVm1c3\" alt=\"clipboard.png\"></p>\n<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>\n<blockquote>\n<p>  所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>\n</blockquote>\n<h4 id=\"非阻塞-I-O（nonblocking-IO）\"><a href=\"#非阻塞-I-O（nonblocking-IO）\" class=\"headerlink\" title=\"非阻塞 I/O（nonblocking IO）\"></a>非阻塞 I/O（nonblocking IO）</h4><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://segmentfault.com/img/bVm1c4\" alt=\"clipboard.png\"></p>\n<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>\n<blockquote>\n<p>  所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p>\n</blockquote>\n<h4 id=\"I-O-多路复用（-IO-multiplexing）\"><a href=\"#I-O-多路复用（-IO-multiplexing）\" class=\"headerlink\" title=\"I/O 多路复用（ IO multiplexing）\"></a>I/O 多路复用（ IO multiplexing）</h4><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://segmentfault.com/img/bVm1c5\" alt=\"clipboard.png\"></p>\n<p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>\n<blockquote>\n<p>  所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>\n</blockquote>\n<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>\n<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>\n<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>\n<h4 id=\"异步-I-O（asynchronous-IO）\"><a href=\"#异步-I-O（asynchronous-IO）\" class=\"headerlink\" title=\"异步 I/O（asynchronous IO）\"></a>异步 I/O（asynchronous IO）</h4><p>inux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139536bVm1c8\" alt=\"clipboard.png\"></p>\n<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><h5 id=\"blocking和non-blocking的区别\"><a href=\"#blocking和non-blocking的区别\" class=\"headerlink\" title=\"blocking和non-blocking的区别\"></a>blocking和non-blocking的区别</h5><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>\n<h5 id=\"synchronous-IO和asynchronous-IO的区别\"><a href=\"#synchronous-IO和asynchronous-IO的区别\" class=\"headerlink\" title=\"synchronous IO和asynchronous IO的区别\"></a>synchronous IO和asynchronous IO的区别</h5><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>- An asynchronous I/O operation does not cause the requesting process to be blocked;</p>\n<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>\n<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>\n<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>\n<p><strong>各个IO Model的比较如图所示：</strong><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139539bVm1c9\" alt=\"clipboard.png\"></p>\n<p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>\n<h3 id=\"I-O-多路复用之select、poll、epoll详解\"><a href=\"#I-O-多路复用之select、poll、epoll详解\" class=\"headerlink\" title=\"I/O 多路复用之select、poll、epoll详解\"></a>I/O 多路复用之select、poll、epoll详解</h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p>\n<h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>\n\n<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>\n<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>\n<h4 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>\n\n<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct pollfd &#123;</span><br><span class=\"line\">    int fd; &#x2F;* file descriptor *&#x2F;</span><br><span class=\"line\">    short events; &#x2F;* requested events to watch *&#x2F;</span><br><span class=\"line\">    short revents; &#x2F;* returned events witnessed *&#x2F;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>\n<blockquote>\n<p>  从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>\n</blockquote>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>\n<h5 id=\"epoll操作过程\"><a href=\"#epoll操作过程\" class=\"headerlink\" title=\"epoll操作过程\"></a>epoll操作过程</h5><p>epoll操作过程需要三个接口，分别如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int epoll_create(int size)；&#x2F;&#x2F;创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class=\"line\">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class=\"line\">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>\n\n<p><strong>1. int epoll_create(int size);</strong><br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>\n<p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong><br>函数是对指定描述符fd执行op操作。<br>- epfd：是epoll_create()的返回值。<br>- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。<br>- fd：是需要监听的fd（文件描述符）<br>- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct epoll_event &#123;</span><br><span class=\"line\">  __uint32_t events;  &#x2F;* Epoll events *&#x2F;</span><br><span class=\"line\">  epoll_data_t data;  &#x2F;* User data variable *&#x2F;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;events可以是以下几个宏的集合：</span><br><span class=\"line\">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class=\"line\">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class=\"line\">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class=\"line\">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class=\"line\">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class=\"line\">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class=\"line\">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>\n<h5 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h5><p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>\n<h6 id=\"LT模式\"><a href=\"#LT模式\" class=\"headerlink\" title=\"LT模式\"></a>LT模式</h6><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>\n<h6 id=\"ET模式\"><a href=\"#ET模式\" class=\"headerlink\" title=\"ET模式\"></a>ET模式</h6><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>\n<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h6 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h6><p><strong>假如有这样一个例子：</strong><br>\\1. 我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符<br>\\2. 这个时候从管道的另一端被写入了2KB的数据<br>\\3. 调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作<br>\\4. 然后我们读取了1KB的数据<br>\\5. 调用epoll_wait(2)……</p>\n<p><strong>LT模式：</strong><br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p>\n<p><strong>ET模式：</strong><br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>\n<p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，<br>读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(rs)&#123;</span><br><span class=\"line\">  buflen &#x3D; recv(activeevents[i].data.fd, buf, sizeof(buf), 0);</span><br><span class=\"line\">  if(buflen &lt; 0)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span><br><span class=\"line\">    &#x2F;&#x2F; 在这里就当作是该次事件已处理处.</span><br><span class=\"line\">    if(errno &#x3D;&#x3D; EAGAIN)&#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else if(buflen &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">     &#x2F;&#x2F; 这里表示对端的socket已正常关闭.</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> if(buflen &#x3D;&#x3D; sizeof(buf)&#123;</span><br><span class=\"line\">      rs &#x3D; 1;   &#x2F;&#x2F; 需要再次读取</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> else&#123;</span><br><span class=\"line\">      rs &#x3D; 0;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  <strong>Linux中的EAGAIN含义</strong></p>\n</blockquote>\n<p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p>\n<p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p>\n<h5 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h5><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define IPADDRESS   &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define PORT        8787</span><br><span class=\"line\">#define MAXSIZE     1024</span><br><span class=\"line\">#define LISTENQ     5</span><br><span class=\"line\">#define FDSIZE      1000</span><br><span class=\"line\">#define EPOLLEVENTS 100</span><br><span class=\"line\"></span><br><span class=\"line\">listenfd &#x3D; socket_bind(IPADDRESS,PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">struct epoll_event events[EPOLLEVENTS];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;创建一个描述符</span><br><span class=\"line\">epollfd &#x3D; epoll_create(FDSIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;添加监听描述符事件</span><br><span class=\"line\">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;循环等待</span><br><span class=\"line\">for ( ; ; )&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;该函数返回已经准备好的描述符事件数目</span><br><span class=\"line\">    ret &#x3D; epoll_wait(epollfd,events,EPOLLEVENTS,-1);</span><br><span class=\"line\">    &#x2F;&#x2F;处理接收到的连接</span><br><span class=\"line\">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;事件处理函数</span><br><span class=\"line\">static void handle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     int i;</span><br><span class=\"line\">     int fd;</span><br><span class=\"line\">     &#x2F;&#x2F;进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span><br><span class=\"line\">     for (i &#x3D; 0;i &lt; num;i++)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         fd &#x3D; events[i].data.fd;</span><br><span class=\"line\">        &#x2F;&#x2F;根据描述符的类型和事件类型进行处理</span><br><span class=\"line\">         if ((fd &#x3D;&#x3D; listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class=\"line\">            handle_accpet(epollfd,listenfd);</span><br><span class=\"line\">         else if (events[i].events &amp; EPOLLIN)</span><br><span class=\"line\">            do_read(epollfd,fd,buf);</span><br><span class=\"line\">         else if (events[i].events &amp; EPOLLOUT)</span><br><span class=\"line\">            do_write(epollfd,fd,buf);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;添加事件</span><br><span class=\"line\">static void add_event(int epollfd,int fd,int state)&#123;</span><br><span class=\"line\">    struct epoll_event ev;</span><br><span class=\"line\">    ev.events &#x3D; state;</span><br><span class=\"line\">    ev.data.fd &#x3D; fd;</span><br><span class=\"line\">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;处理接收到的连接</span><br><span class=\"line\">static void handle_accpet(int epollfd,int listenfd)&#123;</span><br><span class=\"line\">     int clifd;     </span><br><span class=\"line\">     struct sockaddr_in cliaddr;     </span><br><span class=\"line\">     socklen_t  cliaddrlen;     </span><br><span class=\"line\">     clifd &#x3D; accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class=\"line\">     if (clifd &#x3D;&#x3D; -1)         </span><br><span class=\"line\">     perror(&quot;accpet error:&quot;);     </span><br><span class=\"line\">     else &#123;         </span><br><span class=\"line\">         printf(&quot;accept a new client: %s:%d\\n&quot;,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       &#x2F;&#x2F;添加一个客户描述符和事件         </span><br><span class=\"line\">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;读处理</span><br><span class=\"line\">static void do_read(int epollfd,int fd,char *buf)&#123;</span><br><span class=\"line\">    int nread;</span><br><span class=\"line\">    nread &#x3D; read(fd,buf,MAXSIZE);</span><br><span class=\"line\">    if (nread &#x3D;&#x3D; -1)     &#123;         </span><br><span class=\"line\">        perror(&quot;read error:&quot;);         </span><br><span class=\"line\">        close(fd); &#x2F;&#x2F;记住close fd        </span><br><span class=\"line\">        delete_event(epollfd,fd,EPOLLIN); &#x2F;&#x2F;删除监听 </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (nread &#x3D;&#x3D; 0)     &#123;         </span><br><span class=\"line\">        fprintf(stderr,&quot;client close.\\n&quot;);</span><br><span class=\"line\">        close(fd); &#x2F;&#x2F;记住close fd       </span><br><span class=\"line\">        delete_event(epollfd,fd,EPOLLIN); &#x2F;&#x2F;删除监听 </span><br><span class=\"line\">    &#125;     </span><br><span class=\"line\">    else &#123;         </span><br><span class=\"line\">        printf(&quot;read message is : %s&quot;,buf);        </span><br><span class=\"line\">        &#x2F;&#x2F;修改描述符对应的事件，由读改为写         </span><br><span class=\"line\">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;写处理</span><br><span class=\"line\">static void do_write(int epollfd,int fd,char *buf) &#123;     </span><br><span class=\"line\">    int nwrite;     </span><br><span class=\"line\">    nwrite &#x3D; write(fd,buf,strlen(buf));     </span><br><span class=\"line\">    if (nwrite &#x3D;&#x3D; -1)&#123;         </span><br><span class=\"line\">        perror(&quot;write error:&quot;);        </span><br><span class=\"line\">        close(fd);   &#x2F;&#x2F;记住close fd       </span><br><span class=\"line\">        delete_event(epollfd,fd,EPOLLOUT);  &#x2F;&#x2F;删除监听    </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    memset(buf,0,MAXSIZE); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;删除事件</span><br><span class=\"line\">static void delete_event(int epollfd,int fd,int state) &#123;</span><br><span class=\"line\">    struct epoll_event ev;</span><br><span class=\"line\">    ev.events &#x3D; state;</span><br><span class=\"line\">    ev.data.fd &#x3D; fd;</span><br><span class=\"line\">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;修改事件</span><br><span class=\"line\">static void modify_event(int epollfd,int fd,int state)&#123;     </span><br><span class=\"line\">    struct epoll_event ev;</span><br><span class=\"line\">    ev.events &#x3D; state;</span><br><span class=\"line\">    ev.data.fd &#x3D; fd;</span><br><span class=\"line\">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;注：另外一端我就省了</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"epoll总结\"><a href=\"#epoll总结\" class=\"headerlink\" title=\"epoll总结\"></a>epoll总结</h5><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p>\n<p><strong>epoll的优点主要是一下几个方面：</strong><br>\\1. 监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>\n<ol>\n<li> IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>\n</ol>\n<blockquote>\n<p>  如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p>\n</blockquote>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139551R-C.33d57d1aac13ec6a4e7f917e0a47bb69?rik=o/uWsKRpOPc7MA&riu=http://www.thomas-krenn.com/de/wikiDE/images/d/da/Linux-io-stack-diagram_v1.0.png&ehk=1OGRYIpfyG0jiVPRMEKwfpXnNXxZpCQUOMRDg4u7Pz0=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/Anker/p/3269106.html\">用户空间与内核空间，进程上下文与中断上下文总结]</a><br><a href=\"http://guojing.me/linux-kernel-architecture/posts/process-switch/\">进程切换</a><br><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">维基百科-文件描述符</a><br><a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-directio/\">Linux 中直接 I/O 机制的介绍</a><br><a href=\"http://blog.csdn.net/historyasamirror/article/details/5778378\">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a><br><a href=\"http://www.cnblogs.com/bigwangdi/p/3182958.html\">Linux中select poll和epoll的区别</a><br><a href=\"http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html\">IO多路复用之select总结</a><br><a href=\"http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html\">IO多路复用之poll总结</a><br><a href=\"http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html\">IO多路复用之epoll总结</a></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]}]}