{"name":"编程原理","postlist":[{"title":"自旋锁与忙等待","slug":"language/common/busyspinandspinwait","date":"2019-09-09T15:20:21.000Z","updated":"2024-06-30T10:35:56.304Z","comments":true,"path":"api/articles/language/common/busyspinandspinwait.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635133679tennis-1381230__480.jpg","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Busy Spin<br>忙碌的旋转<br>A technique which is used in a way that it loop is running until other thread have to complete his work.<br>一种技术，其使用方式是循环运行，直到其他线程必须完成他的工作。<br>Spin Wait<br>旋转等待<br>A spin wait that you have to wait until condition for thread is true.<br>一种旋转等待，您必须等待，直到线程的条件为真。<br>Spin Loop<br>自旋回路<br>Spin loop is also similar to both of above busy spin and wait spin. It means that threads have to wait for other thread for completing his work.<br>自旋环也类似于上述两种繁忙的自旋和等待自旋。这意味着线程必须等待其他线程完成他的工作。</p>\n<h2 id=\"暴论\"><a href=\"#暴论\" class=\"headerlink\" title=\"暴论\"></a>暴论</h2><p>我们常常听到自旋锁、忙等待、Spin Wait、Spin Loop 、Busy Wait、busy-waiting、busy-looping、 spinning等术语，其实他们都是一个东西。<br>维基百科这么描述<code>busy-waiting, busy-looping or spinning is a technique in which a repeatedly checks to see if a condition is true, such as whether keyboard input or a lock is available</code></p>\n<p>通俗来说就是在循环中判断（等待），不过正确实现自旋锁是很难的，这是因为可能有碰撞产生（例如锁竞争时同时访问锁）。不过我们可以使用一些支持原子操作的语句实现。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h4 id=\"CAS-compare-and-swap-算法\"><a href=\"#CAS-compare-and-swap-算法\" class=\"headerlink\" title=\"CAS(compare and swap)算法\"></a>CAS(compare and swap)算法</h4><p>比较并交换(compare and swap, CAS)，是原子操作的一无锁算法。无锁编程使用，一般用于实现乐观锁，自旋锁</p>\n<p>缺点:ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作</p>\n<p>java中实现自旋锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">spinLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//java 泛型；调用CAS库AtomicReference泛型类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;Thread&gt; cas = <span class=\"keyword\">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">// 利用CAS(Compare And Swap)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!cas.compareAndSet(<span class=\"keyword\">null</span>, current)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// DO nothing</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread current = Thread.currentThread();</span><br><span class=\"line\">        cas.compareAndSet(current, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>golang</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> spinLock <span class=\"keyword\">uint32</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sl *spinLock)</span> <span class=\"title\">Lock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> !atomic.CompareAndSwapUint32((*<span class=\"keyword\">uint32</span>)(sl), <span class=\"number\">0</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        runtime.Gosched()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sl *spinLock)</span> <span class=\"title\">Unlock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    atomic.StoreUint32((*<span class=\"keyword\">uint32</span>)(sl), <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSpinLock</span><span class=\"params\">()</span> <span class=\"title\">sync</span>.<span class=\"title\">Locker</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lock spinLock</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;lock</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"}]},{"title":"什么是运行时","slug":"language/common/whatsruntime","date":"2020-11-24T15:20:21.000Z","updated":"2024-06-30T10:35:56.304Z","comments":true,"path":"api/articles/language/common/whatsruntime.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635133952clock-3222267_960_720.jpg","content":"<p>runtime 描述了<strong>程序运行时候</strong>执行的软件/指令， 在每种语言有着不同的实现。可大可小，在 C 中，runtime 是库代码， 等同于 C runtime library，一系列 C 程序运行所需的函数，在 Java 中，runtime 还提供了 Java 程序运行所需的虚拟机等。</p>\n<p>总而言之，<strong>runtime 是一个通用抽象的术语，指的是计算机程序运行的时候所需要的一切代码库，框架，平台等</strong>。</p>\n<p>在 Go 中， 有一个 runtime 库，其实现了垃圾回收，并发控制， 栈管理以及其他一些 Go 语言的关键特性。 runtime 库是每个 Go 程序的一部分，也就是说编译 Go 代码为机器代码时也会将其也编译进来。所以 Go 官方将其定位偏向类似于 C 语言中的库。Go 中的 runtime 不像 Java runtime （JRE， java runtime envirement ) 一样，jre 还会提供虚拟机， Java 程序要在 JRE 下 才能运行。</p>\n<p>所以在 Go 语言中， runtime 只是提供支持语言特性的库的名称，也就是 Go 程序执行时候使用的库。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"}]},{"title":"go的内置包","slug":"language/golang/built-inpackage","date":"2019-07-19T14:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/built-inpackage.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635134047ground-squirrel-5831591__340.jpg","content":"<h2 id=\"库与包\"><a href=\"#库与包\" class=\"headerlink\" title=\"库与包\"></a>库与包</h2><h4 id=\"archive\"><a href=\"#archive\" class=\"headerlink\" title=\"archive\"></a>archive</h4><h5 id=\"tar包：负责打包、解包-注意tar不负责压缩和解压\"><a href=\"#tar包：负责打包、解包-注意tar不负责压缩和解压\" class=\"headerlink\" title=\"tar包：负责打包、解包,注意tar不负责压缩和解压\"></a>tar包：负责打包、解包,注意tar不负责压缩和解压</h5><p>打包实现原理</p>\n<p>先创建一个文件x.tar，然后向x.tar写入tar头部信息。打开要被tar的文件，向x.tar写入头部信息，然后向x.tar写入文件信息。重复第二步直到所有文件都被写入到x.tar中，关闭x.tar，整个过程就这样完成了</p>\n<p>解包实现原理</p>\n<p>先打开tar文件，然后从这个tar头部中循环读取存储在这个归档文件内的文件头信息，从这个文件头里读取文件名，以这个文件名创建文件，然后向这个文件里写入数据</p>\n<h5 id=\"zip包：打包、解包，并进行压缩\"><a href=\"#zip包：打包、解包，并进行压缩\" class=\"headerlink\" title=\"zip包：打包、解包，并进行压缩\"></a>zip包：打包、解包，并进行压缩</h5><p>压缩实现原理</p>\n<p>工具类：bufio、bytes、string、path、strconv、io/ioutils等，没有领域知识，比较简单</p>\n<p>系统包：os、net、sync、fmt</p>\n<h2 id=\"linux-说明\"><a href=\"#linux-说明\" class=\"headerlink\" title=\"linux 说明\"></a>linux 说明</h2><h4 id=\"linux文件头信息-标志\"><a href=\"#linux文件头信息-标志\" class=\"headerlink\" title=\"linux文件头信息(标志)\"></a>linux文件头信息(标志)</h4><p>使用file命令可以查看文件类型</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# file test ./test/1</span><br><span class=\"line\">test:     directory</span><br><span class=\"line\">./test/1: ASCII text</span><br></pre></td></tr></table></figure>\n\n\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"golang","path":"api/tags/golang.json"}]},{"title":"go逃逸分析","slug":"language/golang/escapeanalysis","date":"2021-05-08T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/escapeanalysis.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635134114header.jpg","content":"<p>[toc]</p>\n<h2 id=\"go逃逸分析\"><a href=\"#go逃逸分析\" class=\"headerlink\" title=\"go逃逸分析\"></a>go逃逸分析</h2><h3 id=\"什么是逃逸\"><a href=\"#什么是逃逸\" class=\"headerlink\" title=\"什么是逃逸\"></a>什么是逃逸</h3><p>内存从栈逃逸到堆中，会增大GC的压力</p>\n<h3 id=\"为什么要做逃逸分析\"><a href=\"#为什么要做逃逸分析\" class=\"headerlink\" title=\"为什么要做逃逸分析\"></a>为什么要做逃逸分析</h3><p>申请到栈内存性能好，不会引起GC，函数返回直接释放</p>\n<p>申请到堆内存会导致gc，引起性能问题</p>\n<p>如何分配：</p>\n<ol>\n<li>如果函数外部没有引用，则优先放到栈中；</li>\n<li>如果函数外部存在引用，则必定放到堆中；</li>\n</ol>\n<p>常见的三种逃逸</p>\n<h3 id=\"指针逃逸\"><a href=\"#指针逃逸\" class=\"headerlink\" title=\"指针逃逸\"></a>指针逃逸</h3><p>函数返回局部变量的指针导致指针逃逸</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pointerEscapeFunc</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v <span class=\"keyword\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;v</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pointerEscapeFunc()<span class=\"comment\">//v会被分配到堆上</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">host$</span><span class=\"bash\"> go build -gcflags <span class=\"string\">&#x27;-m -l&#x27;</span> tem.go <span class=\"comment\">#-m打印信息，-l忽略inline信息</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> command-line-arguments</span></span><br><span class=\"line\">./tem.go:3:6: moved to heap: v #可见v被分配到了堆上</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栈空间不足\"><a href=\"#栈空间不足\" class=\"headerlink\" title=\"栈空间不足\"></a>栈空间不足</h3><p>go的goroutine初始栈大小为2KB，go可以增大栈大小，但不可超过系统栈限制(使用<code>ulimit -s</code>查看)，超过一定大小的变量将会逃逸到堆上，不同go版本大小限制不同</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stackSpaceExhausted</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    v := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>,<span class=\"number\">0</span>,<span class=\"number\">10000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    stackSpaceExhausted()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">host$</span><span class=\"bash\"> go build -gcflags <span class=\"string\">&#x27;-m -l&#x27;</span> tem.go</span> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> command-line-arguments</span></span><br><span class=\"line\">./tem.go:3:11: make([]int, 0, 10000) escapes to heap # 可见逃逸到了堆上，go1.15</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"闭包引用\"><a href=\"#闭包引用\" class=\"headerlink\" title=\"闭包引用\"></a>闭包引用</h3><p>函数类型也分两种，一种是函数字面量类型（未命名类型,func literal），另一种是函数命名类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">outer</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a <span class=\"keyword\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>&#123;</span><br><span class=\"line\">        a++</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    inner := outer()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(inner())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">host$</span><span class=\"bash\"> go build -gcflags <span class=\"string\">&#x27;-m -l&#x27;</span> tem.go</span> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> command-line-arguments</span></span><br><span class=\"line\">./tem.go:3:6: moved to heap: a</span><br><span class=\"line\">./tem.go:4:9: func literal escapes to heap</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p>对象大小不确定或作为不确定大小的参数时发生逃逸</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a <span class=\"keyword\">int</span></span><br><span class=\"line\">    fmt.Println(a)<span class=\"comment\">//fmt.Println的入参是...interface&#123;&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">host$</span><span class=\"bash\"> go build -gcflags <span class=\"string\">&#x27;-m -l&#x27;</span> tem.go</span> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> command-line-arguments</span></span><br><span class=\"line\">./tem.go:7:13: main ... argument does not escape</span><br><span class=\"line\">./tem.go:7:13: a escapes to heap</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"逃逸分析使用\"><a href=\"#逃逸分析使用\" class=\"headerlink\" title=\"逃逸分析使用\"></a>逃逸分析使用</h3><p>传值会拷贝对象，增加对象拷贝开销(听君一席话，胜似一席话)，只读切内存小的结构体使用可以提高性能</p>\n<p>传指针会导致内存逃逸到堆中，增加垃圾回收(GC)负担,对象需要频繁创建删除时，GC开销会特别大，影响性能，但在需要修改对象值、内存占用大的结构体中，传指针性能更好</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"golang","path":"api/tags/golang.json"}]},{"title":"JRE和JDK的区别","slug":"language/java/javabasics","date":"2020-11-25T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/java/javabasics.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351383024c3f44e8-9100-11eb-9353-fa1e86d74c00.png","content":"<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351383024c3f44e8-9100-11eb-9353-fa1e86d74c00.png\" alt=\"0cc3f4a15d3184391a98a7b1c58f6e5f_1440w\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351383094800a192-9100-11eb-8da9-fa1e86d74c00.png\" alt=\"20171221220833133\"></p>\n<h2 id=\"先给出JDK，JRE，JVM（带上JVM有助于理解）的名词解释\"><a href=\"#先给出JDK，JRE，JVM（带上JVM有助于理解）的名词解释\" class=\"headerlink\" title=\"先给出JDK，JRE，JVM（带上JVM有助于理解）的名词解释\"></a><strong>先给出JDK，JRE，JVM（带上JVM有助于理解）的名词解释</strong></h2><ol>\n<li> Java开发工具包（JDK）是一种用    于开发Java应用程序和applet的软件开发环境。它包括Java运行时环境（JRE）、解释器/加载器（Java）、编译器（javac）、归档器（jar）、文档生成器（Javadoc）和Java开发所需的其他工具。</li>\n<li> JRE代表“Java Runtime Environment”，也可以写成“Java RTE”。Java Runtime Environment提供了执行Java应用程序的最低要求；它由Java虚拟机（JVM）、核心类和支持文件组成。</li>\n<li> 另外也给出了JVM（java virtual machine）的解释。</li>\n</ol>\n<ul>\n<li>  它是一种指定Java虚拟机工作的规范。但是实现提供者对算法的选择是独立的。它的实现由Sun和其他公司提供。</li>\n<li>  满足JVM规范要求的计算机程序的一种实现。</li>\n<li>  运行时实例：每当您在命令提示符下编写java命令来运行java类时，就会创建一个JVM实例。</li>\n</ul>\n<h2 id=\"一-JDK、JRE和JVM的区别\"><a href=\"#一-JDK、JRE和JVM的区别\" class=\"headerlink\" title=\"一. JDK、JRE和JVM的区别\"></a><strong>一. JDK、JRE和JVM的区别</strong></h2><p>为了理解这三者之间的区别，让我们考虑下面的图表。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455466v2-20c4773e7e180335fb7f623c79e92303_hd.jpg?source=1940ef5c\" alt=\"img\"></p>\n<ul>\n<li>  <strong>JDK–Java开发工具包</strong>（简称JDK）是一种提供开发和执行（运行）Java程序的环境的工具包。JDK是一个工具包（或包），它包括两个方面</li>\n</ul>\n<ol>\n<li> 开发工具（提供开发java程序的环境）</li>\n<li> JRE（执行java程序）。</li>\n</ol>\n<ul>\n<li>  <strong>JRE–Java Runtime Environment</strong>（也就是说JRE）是一个安装包，它提供的环境只能在您的计算机上运行（而不是开发）Java程序。只有那些只想运行Java程序的用户，也就是系统的最终用户，才会使用JRE。</li>\n<li>  <strong>JVM–Java虚拟机</strong>（JVM）是JDK和JRE的一个非常重要的部分，因为它内置于两者之中。使用JRE或JDK运行的任何Java程序都进入JVM，JVM负责逐行执行Java程序，因此它也被称为解释器。</li>\n</ul>\n<h2 id=\"二-JRE和JDK是如何工作的？\"><a href=\"#二-JRE和JDK是如何工作的？\" class=\"headerlink\" title=\"二. JRE和JDK是如何工作的？\"></a>二. JRE和JDK是如何工作的？</h2><h2 id=\"JRE由什么组成？\"><a href=\"#JRE由什么组成？\" class=\"headerlink\" title=\"JRE由什么组成？\"></a>JRE由什么组成？</h2><p>JRE由以下组件组成：</p>\n<ul>\n<li>  <strong>部署技术</strong>，包括部署、java web start和Java插件。</li>\n<li>  <strong>用户界面工具包</strong>，包括抽象窗口工具包（AWT）、Swing、java2d、辅助功能、图像I/O、打印服务、声音、拖放（DnD）和输入方法。</li>\n<li>  <strong>集成库</strong>，包括接口定义语言（IDL）、Java数据库连接（JDBC）、Java命名和目录接口（JNDI）、远程方法调用（RMI）、Internet Orb间协议远程方法调用（RMI-IIOP）和脚本。</li>\n<li>  <strong>其他基本库</strong>，包括国际支持、输入/输出（I/O）、扩展机制、bean、Java管理扩展（JMX）、Java本机接口（JNI）、数学、网络、覆盖机制、安全性、序列化和Java for XML处理（XML JAXP）。</li>\n<li>  <strong>Lang和util基本库</strong>，包括Lang和util、管理、版本控制、zip、工具、反射、集合、并发实用程序、Java存档（JAR）、日志、首选项API、Ref对象和正则表达式。</li>\n<li>  <strong>Java虚拟机</strong>（JVM），包括Java HotSpot 客户端和<em>Server Virtual Machines</em>。</li>\n</ul>\n<h2 id=\"JRE是如何工作的？\"><a href=\"#JRE是如何工作的？\" class=\"headerlink\" title=\"JRE是如何工作的？\"></a>JRE是如何工作的？</h2><p>为了理解JRE是如何工作的，让我们保存一个java源文件<em>Example.java。</em>该文件被编译成一组字节码，存储在“.class”文件中，这里它就是”<em>Example</em>.class“。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138321v2-514231f8f6536733d294d76dcefa8d96_hd.jpg?source=1940ef5c\" alt=\"img\"><img src= \"/img/loading.gif\" data-lazy-src=\"https://pic1.zhimg.com/80/v2-514231f8f6536733d294d76dcefa8d96_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>下图描述了编译时所做的操作，以下操作在运行时发生：</p>\n<ul>\n<li>  <strong>类加载器</strong></li>\n</ul>\n<p>类加载器加载执行程序所需的所有类。它通过将本地文件系统的名称空间与通过网络导入的名称空间分离来提供安全性。这些文件可以从硬盘、网络或其他来源加载。</p>\n<ul>\n<li>  <strong>字节码校验器</strong></li>\n</ul>\n<p>JVM将代码放入字节码验证器，该验证器检查格式并检查非法代码。例如，非法代码就是违反对象访问权限或违反指针实现的代码。</p>\n<p>字节码验证器确保代码符合JVM规范，并且不违反系统完整性。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/16344554731634455456v2-12142cee79304193c837472e149d3aea_hd.jpg?source=1940ef5c\" alt=\"img\"></p>\n<ul>\n<li>  <strong>解释器</strong></li>\n</ul>\n<p>在运行时，字节码由解释器加载、检查和运行。解释器有以下两个功能：</p>\n<ol>\n<li> 执行字节码</li>\n<li> 对底层硬件进行适当的调用</li>\n</ol>\n<p>两种操作可以显示为：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455479v2-cc90ac57568556eb923f362b10f05178_hd.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>要理解JDK和JRE之间的交互，请考虑下面的图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455482v2-7fa711bae33644cbc7ea6981a8eda4cf_hd.jpg?source=1940ef5c\" alt=\"img\"></p>\n<h2 id=\"三-JVM是如何工作的？\"><a href=\"#三-JVM是如何工作的？\" class=\"headerlink\" title=\"三. JVM是如何工作的？\"></a><strong>三. JVM是如何工作的？</strong></h2><p>JVM在Java程序运行时成为JRE的一个实例。它被广泛地称为运行时解释器。JVM在很大程度上有助于从程序员那里抽象出内部实现，这些程序员为自己的程序使用JDK中的库。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"java","path":"api/tags/java.json"}]},{"title":"perl极简教程","slug":"language/perl/perlbasics","date":"2020-12-26T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/perl/perlbasics.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211026/1635178056perl-banner.png","content":"<p>perl ：practical exteaction report language</p>\n<ol>\n<li><p>perl是动态脚本语言</p>\n</li>\n<li><p>脚本运行是要</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/perl</span></span><br></pre></td></tr></table></figure></li>\n<li><p>使用#单行注释，使用=pod           =cut多行注释</p>\n</li>\n<li><p>perl不关心留白数量</p>\n</li>\n<li><p>heredoc用法，单引号不转义，双引号转义</p>\n</li>\n<li><p>使用反斜杠\\转义</p>\n</li>\n</ol>\n<p>##标量定义</p>\n<p>数字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$num&#x3D;12;</span><br></pre></td></tr></table></figure>\n\n<p>字符串</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stri=<span class=\"string\">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>浮点数</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$float=<span class=\"number\">1.2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@arr&#x3D;(0,1,2);</span><br></pre></td></tr></table></figure>\n\n<p>字典</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%map=(<span class=\"string\">&#x27;a&#x27;</span>=&gt;<span class=\"number\">1</span>,<span class=\"string\">&#x27;b&#x27;</span>=&gt;<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"perl","path":"api/tags/perl.json"}]},{"title":"py2与py3在closerange的区别","slug":"language/python/differencebwtweenpy2andpy3incloserangefuntion","date":"2020-12-23T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/python/differencebwtweenpy2andpy3incloserangefuntion.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138448v2-0647c2d439278d31bcb155d70cfeab31_1200x500.jpg","content":"<h2 id=\"file-descriptors（-proc下）\"><a href=\"#file-descriptors（-proc下）\" class=\"headerlink\" title=\"file descriptors（/proc下）\"></a>file descriptors（/proc下）</h2><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8\">内核</a>为每一个<a href=\"https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B\">进程</a>所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在<a href=\"https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\">程序设计</a>中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于<a href=\"https://zh.wikipedia.org/wiki/UNIX\">UNIX</a>、<a href=\"https://zh.wikipedia.org/wiki/Linux\">Linux</a>这样的操作系统。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>文件描述符的优点主要有两个：</p>\n<ul>\n<li>基于文件描述符的<a href=\"https://zh.wikipedia.org/wiki/I/O\">I/O操作</a>兼容<a href=\"https://zh.wikipedia.org/wiki/POSIX\">POSIX</a>标准。</li>\n<li>在UNIX、Linux的系统调用中，大量的系统调用都是依赖于文件描述符</li>\n</ul>\n<p>此外，在Linux系列的操作系统上，由于Linux的设计思想便是把一切设备都视作文件。因此，文件描述符为在该系列平台上进行设备相关的编程实际上提供了一个统一的方法。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>文件描述符的概念存在两大缺点：</p>\n<ul>\n<li>在非UNIX/Linux <a href=\"https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\">操作系统</a>上（如<a href=\"https://zh.wikipedia.org/wiki/Windows\">Windows</a>），无法基于这一概念进行编程——事实上，Windows下的文件描述符和<a href=\"https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E9%87%8F\">信号量</a>、<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81\">互斥锁</a>等<a href=\"https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1\">内核对象</a>一样都记作HANDLE。</li>\n<li>由于文件描述符在形式上不过是个整数，当代码量增大时，会使编程者难以分清哪些整数意味着数据，哪些意味着文件描述符。因此，完成的代码可读性也就会变得很差，这一点一般通过消除<a href=\"https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%95%B8%E5%AD%97\">魔术数字</a>来解决。</li>\n</ul>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><ol>\n<li>在proc目录下，以数字命名的目录表示当前一个运行的进程，目录名即为进程的pid，进程里的fd是文件描述符。</li>\n<li>魔术数字（magic number）是程式设计中所谓的直接写在程式码里的具体数值（如“10”“123”等以数字直接写出的值）。虽然程式作者写的时候自己能了解数值的意义，但对其他程式员而言，甚至制作者本人经过一段时间后，会难以了解这个数值的用途，只能苦笑讽刺“这个数值的意义虽然不懂，不过至少程式会动，真是个魔术般的数字”而得名。</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"python","path":"api/tags/python.json"}]},{"title":"内置库os","slug":"language/python/import","date":"2020-06-20T15:20:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/python/import.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138518python3-print-function.png","content":"<p>一个 <a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-module\">module</a> 内的 Python 代码通过 <a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-importing\">importing</a> 操作就能够访问另一个模块内的代码。 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import\"><code>import</code></a> 语句是发起调用导入机制的最常用方式，但不是唯一的方式。 <a href=\"https://docs.python.org/zh-cn/3/library/importlib.html#importlib.import_module\"><code>importlib.import_module()</code></a> 以及内置的 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#import__\"><code>__import__()</code></a> 等函数也可以被用来发起调用导入机制。</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import\"><code>import</code></a> 语句结合了两个操作；它先搜索指定名称的模块，然后将搜索结果绑定到当前作用域中的名称。 <code>import</code> 语句的搜索操作被定义为对 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#import__\"><code>__import__()</code></a> 函数的调用并带有适当的参数。 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#import__\"><code>__import__()</code></a> 的返回值会被用于执行 <code>import</code> 语句的名称绑定操作。 请参阅 <code>import</code> 语句了解名称绑定操作的更多细节。</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li>py2和py3在import时即使没有使用，也会初始化import的module文件</li>\n<li>在import文件初始化时，会对类属性进行初始化！</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"python","path":"api/tags/python.json"}]},{"title":"内置库os","slug":"language/python/os","date":"2020-06-20T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/python/os.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138518python3-print-function.png","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listdir(path: AnyStr) -&gt; List[AnyStr] #列出目录下所有文件和文件夹</span><br></pre></td></tr></table></figure>\n\n<p>os.sep与os.path.sep</p>\n<p>根据系统返回分隔符，os.path对于文件路径更健壮</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"python","path":"api/tags/python.json"}]},{"title":"内置库re","slug":"language/python/re","date":"2020-08-20T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/python/re.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138518python3-print-function.png","content":"<p>re是python中的正则表达式内置库</p>\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>re.I</td>\n<td>IGNORECASE，忽略大小写</td>\n</tr>\n<tr>\n<td>re.L</td>\n<td>LOCALE，只对8位字节有效，不建议使用，由当前语言区域决定 <code>\\w</code>, <code>\\W</code>, <code>\\b</code>, <code>\\B</code> 和大小写敏感匹配</td>\n</tr>\n<tr>\n<td>re.U</td>\n<td>UNICODE，根据Unicode字符集解析字符。由当前语言区域决定 <code>\\w</code>, <code>\\W</code>, <code>\\b</code>, <code>\\B</code> 和大小写敏感匹配</td>\n</tr>\n<tr>\n<td>re.M</td>\n<td>MULTILINE，多行匹配，影响 ^ 和 $</td>\n</tr>\n<tr>\n<td>re.S</td>\n<td>DOTALL，.可以匹配除换行符外所有内容</td>\n</tr>\n<tr>\n<td>re.X</td>\n<td>VERBOSE，忽略空格和注释</td>\n</tr>\n</tbody></table>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"python","path":"api/tags/python.json"}]},{"title":"计算机基本组成","slug":"systemstructure/base/computerprinciples","date":"2020-01-25T10:24:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/base/computerprinciples.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138820R-C.a85787a0d06496906299e72de39ffb00?rik=9SM14JX30i1BPQ&riu=http%3a%2f%2fimg.mp.itc.cn%2fupload%2f20170420%2ff813101deccb4bcea732569ecbcf2ab7_th.jpeg&ehk=Mprq0bxfRYz7AO70UBj3%2fqUqXpN6ELRfJqKVMtD3pUY%3d&risl=&pid=ImgRaw&r=0","content":"<p>[toc]</p>\n<h1 id=\"计算机基本组成\"><a href=\"#计算机基本组成\" class=\"headerlink\" title=\"计算机基本组成\"></a>计算机基本组成</h1><h2 id=\"基本组成\"><a href=\"#基本组成\" class=\"headerlink\" title=\"基本组成\"></a>基本组成</h2><h3 id=\"存储器\"><a href=\"#存储器\" class=\"headerlink\" title=\"存储器\"></a>存储器</h3><p>存放数据和程序的设备，根据功能分为主存、辅存</p>\n<h4 id=\"主存\"><a href=\"#主存\" class=\"headerlink\" title=\"主存\"></a>主存</h4><p>主存储器，通俗称内存，直接与CPU通过MMU交换信息(cpu内部还有几级高速缓存)，速度比较快，容量比较小，ROM掉电非易失，RAM掉电易失(我们电脑的内存)</p>\n<h4 id=\"辅存\"><a href=\"#辅存\" class=\"headerlink\" title=\"辅存\"></a>辅存</h4><p>又称外存，与主存交换信息，速度慢，容量大，掉电非易失，一般就是指我们的固态硬盘、机械硬盘、U盘、光驱+光盘等</p>\n<h3 id=\"运算器\"><a href=\"#运算器\" class=\"headerlink\" title=\"运算器\"></a>运算器</h3><p>位于CPU(中央处理器，central processing unit)中，基本就是指ALU，中文世界一般还把FPU、GPU、寄存器组、累加器、数据总线划入其中</p>\n<h4 id=\"FPU\"><a href=\"#FPU\" class=\"headerlink\" title=\"FPU\"></a>FPU</h4><p>浮点运算器(floating point unit)，电路实现的运行浮点运算的结构(以前用ALU模拟，精度低)，通常集成在CPU中，现代计算机中浮点运算会与SIMD(Single Instruction Multiple Data，一个控制器控制多个处理器)集成在一个指令集内</p>\n<h4 id=\"GPU\"><a href=\"#GPU\" class=\"headerlink\" title=\"GPU\"></a>GPU</h4><p>入行处理单元，详见GPU设计与架构文章</p>\n<h3 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h3><p>控制器 control unit，现代计算机集成在CPU中，指导处理器操作(二进制解码指令转换为控制、定时等信号)</p>\n<h3 id=\"输入设备\"><a href=\"#输入设备\" class=\"headerlink\" title=\"输入设备\"></a>输入设备</h3><p>外设输入，键鼠等</p>\n<h3 id=\"输出设备\"><a href=\"#输出设备\" class=\"headerlink\" title=\"输出设备\"></a>输出设备</h3><p>外设输出，显示器等</p>\n<h2 id=\"总线信息\"><a href=\"#总线信息\" class=\"headerlink\" title=\"总线信息\"></a>总线信息</h2><h3 id=\"位置分类\"><a href=\"#位置分类\" class=\"headerlink\" title=\"位置分类\"></a>位置分类</h3><ul>\n<li>片内总线：芯片内部传送信息的通道</li>\n<li>外部总线：CPU与外设通信,PCI(E)、PXI(E)总线等</li>\n<li>系统总线：<ul>\n<li>数据总线：在CPU与RAM之间传输数据</li>\n<li>地址总线：指定RAM存储地址或者I/O设备地址</li>\n<li>控制总线：将控制器信号传输到其他设备(存储器、I/O设备等)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"传送方式分类\"><a href=\"#传送方式分类\" class=\"headerlink\" title=\"传送方式分类\"></a>传送方式分类</h3><ul>\n<li>串行总线：Serial communication每次传一位(bit)，rs-232/422/423/485、I2C、PCIE、USB、以太网、SATA等，现在是高速串行总线时代！</li>\n<li>并行总线：同时传送多位数，ATA、PCI、SCSI等，目前用处较少，原因是根据SSN原理限制了并行带宽</li>\n</ul>\n<h2 id=\"主板接口\"><a href=\"#主板接口\" class=\"headerlink\" title=\"主板接口\"></a>主板接口</h2><h4 id=\"PCIE插槽\"><a href=\"#PCIE插槽\" class=\"headerlink\" title=\"PCIE插槽\"></a>PCIE插槽</h4><p>一般插显卡、声卡、无线网卡等，由短到长分别为：PCIEx1、PCIEx4、PCIEx8、PCIEx16，后面数字代表PCIE通道数量</p>\n<h4 id=\"M-2插槽\"><a href=\"#M-2插槽\" class=\"headerlink\" title=\"M.2插槽\"></a>M.2插槽</h4><p>有两个PCIE通道的socket2和四通道的socket3两个版本</p>\n<h4 id=\"SATA插槽\"><a href=\"#SATA插槽\" class=\"headerlink\" title=\"SATA插槽\"></a>SATA插槽</h4><p>硬盘插槽，一般一个PCIE通道</p>\n<h4 id=\"DIMM插槽\"><a href=\"#DIMM插槽\" class=\"headerlink\" title=\"DIMM插槽\"></a>DIMM插槽</h4><p>内存插槽</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"编程基础","path":"api/tags/编程基础.json"}]},{"title":"CPU简介","slug":"systemstructure/base/cpu","date":"2021-08-20T10:24:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/base/cpu.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211221/16400752521640075186v2-ce7b6f2b4dfbceef66fa8a97866cf3b1_1440w.jpg","content":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>CPU:( <code>CentralProcessingUnit</code>): 中央处理单元，CPU不等于物理核，更不等于逻辑核,一个逻辑核包含多个物理核，一个物理核可以分成n个逻辑核</p>\n<p>物理核(<code>physical core</code>): 可以看的到的，真实的cpu核，有独立的电路元件以及L1,L2缓存，可以独立地执行指令。</p>\n<p>逻辑核( <code>logical core，LCPU</code>): 在同一个物理核内，逻辑层面的核。1LCPU=1THREAD</p>\n<p>超线程( <code>Hyper-threading， HT</code>)：时间管理大师，超线程可以在一个逻辑核等待指令执行的间隔把时间片分配到另一个逻辑核。同一物理核超出的逻辑核之间为兄弟线程；</p>\n<p>虚拟核：使用虚拟化技术，超分出的核心，位于虚拟机中；</p>\n<p>CPU Die(裸晶): 生产中引入概念，从晶圆上切下来的裸晶，通过片外总线互联，可以封装在一个Package中,die之间通过HT(HyperTransport)总线通信</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211222/1640103678R-C.4ac803e989bb4f90f212532d90337994?rik=easxlVWcYVTbiQ&riu=http://www.quantgrav.com/wordpress/wp-content/uploads/2020/02/10-1582802010-1.jpeg&ehk=sywkHVPXnt5dsrGybbhzM075BW1qO6GPaaplhltTfTw=&risl=&pid=ImgRaw&r=0&sres=1&sresct=1\" alt=\"See the source image\"></p>\n<p>CPU Package(封装)：对应一个cpu socket的一个CPU；</p>\n<p>双路服务器:主板上有两个cpu插槽(socket),多个处理器通过 QPI 链路相连;</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211222/16401033685c295e257dc738d5.jpg\" alt=\"超微（SUPERMICRO）X11DPH-T双路服务器主板【图片价格品牌报价】-京东\"></p>\n<p>对称多处理机(Symmetric multiprocessing,SMP)：每个处理器的地位都是平等的，对资源的使用权限相同。拥有超过一个以上的处理器，这些处理器都连接到同一个共享的主存上，并由单一操作系统来控制。在多核心处理器的例子中，对称多处理架构，将每一个核心都当成是独立的处理器。</p>\n<p>下图为双路服务器的两个CPU，每个CPU 封装了4个die</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211221/16400752521640075186v2-ce7b6f2b4dfbceef66fa8a97866cf3b1_1440w.jpg\" alt=\"img\"></p>\n<h2 id=\"cpu缓存\"><a href=\"#cpu缓存\" class=\"headerlink\" title=\"cpu缓存\"></a>cpu缓存</h2><p><strong>CPU高速缓存</strong>(cpu cache)目的是减少处理器访问内存的延时，在存储体系中仅次于cpu寄存器，速度快，接近处理器频率；</p>\n<p>缓存是SRAM(<strong>S</strong>tatic <strong>R</strong>andom <strong>A</strong>ccess <strong>M</strong>emory),使用CMOS(<strong>C</strong>omplementary <strong>M</strong>etal-<strong>O</strong>xide-<strong>S</strong>emiconductor)工艺；</p>\n<h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><ol>\n<li>处理器访问内存时先检查cache中是否存在，命中则返回，未命中，存入cache再返回；</li>\n<li>处理器写入内存时命中直接改写，未命中按照策略，写入或不写入cache；</li>\n</ol>\n<h3 id=\"缓存级别-常见\"><a href=\"#缓存级别-常见\" class=\"headerlink\" title=\"缓存级别(常见)\"></a>缓存级别(常见)</h3><p>缓存一般有三层，L1距离cpu最近，运行速率最高，容量最小;一般L1、L2为每个物理核独占</p>\n<p>曾经有过L4 Cache 是个eDRAM,(Haswell/Broadwell:在Iris系列中)</p>\n<h4 id=\"缓存的设计\"><a href=\"#缓存的设计\" class=\"headerlink\" title=\"缓存的设计\"></a>缓存的设计</h4><ul>\n<li>exclusive：L1 cahce中的内容不能包含在L2中</li>\n<li>strictly inclusive：L1cache的内容一定严格包含在L2中。</li>\n<li>Third one（没有正式名字）:不要求L1的一定包含在L2中</li>\n</ul>\n<h2 id=\"背景事件\"><a href=\"#背景事件\" class=\"headerlink\" title=\"背景事件\"></a>背景事件</h2><h3 id=\"晶体管的诞生\"><a href=\"#晶体管的诞生\" class=\"headerlink\" title=\"晶体管的诞生\"></a>晶体管的诞生</h3><p>1947年贝尔实验室的肖克莱、布拉顿、巴丁共同发明晶体管(包括二极管、三极管、晶闸管、场效应管等)，晶体管相比电子管功耗低、效率高。</p>\n<h3 id=\"八叛逆与仙童半导体\"><a href=\"#八叛逆与仙童半导体\" class=\"headerlink\" title=\"八叛逆与仙童半导体\"></a>八叛逆与仙童半导体</h3><p>1955年，肖克利回到老家硅谷创建“肖克利半导体实验室”，两年招募8位年轻的科学家；后八人退出并找到Fairchild摄影器材公司的投资成立Fairchild仙童半导体。</p>\n<h3 id=\"Intel的成立\"><a href=\"#Intel的成立\" class=\"headerlink\" title=\"Intel的成立\"></a>Intel的成立</h3><p>因仙童半导体与母公司矛盾，1968年7月，诺依斯和摩尔、格鲁夫脱离仙童成立Intel</p>\n<h3 id=\"AMD的成立\"><a href=\"#AMD的成立\" class=\"headerlink\" title=\"AMD的成立\"></a>AMD的成立</h3><p>1969年5月，桑德斯带着7位仙童员工创办AMD</p>\n<h3 id=\"Intel-4004\"><a href=\"#Intel-4004\" class=\"headerlink\" title=\"Intel 4004\"></a>Intel 4004</h3><p>1971年11月，英特尔公司推出了世界上第一款CPU Inter 4004，这是第一个可用于微型计算机的四位微处理器。此时MOS LSI(大规模集成)技术的可用性，刚刚开始在计算器业务从机电到电子的根本变化，4004的出现宣布了电子一体化的新时代，开始为PC机的出现铺路。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">740kHz</td>\n<td align=\"left\">4bit 单核</td>\n<td align=\"left\">2300</td>\n<td align=\"left\">10微米</td>\n</tr>\n</tbody></table>\n<p>但当时的Inter作为一个小厂难以达到IBM 1620在1960的算力水平。</p>\n<p>Inter在1972年生产了Inter 8008，打算用作终端控制器，与Inter 4040类似，是第一个8bit处理器</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">200-800KHz</td>\n<td align=\"left\">8bit单核</td>\n<td align=\"left\">3500</td>\n<td align=\"left\">10微米</td>\n</tr>\n</tbody></table>\n<h3 id=\"TMS-1000\"><a href=\"#TMS-1000\" class=\"headerlink\" title=\"TMS 1000\"></a>TMS 1000</h3><p>德州仪器（TI）生产，这是第一个包含足够RAM和足够用于程序ROM的空间以及在单个芯片上具有I / O支持的微处理器。从而使其无需多个芯片即可运行外部支持芯片，使其成为第一个微控制器。它还具有一项创新功能，可以向CPU添加<strong>自定义指令</strong>。</p>\n<p>不足：内存不是连续的，内存都是内部的。所有硬连线都是单周期的，不允许中断。</p>\n<h3 id=\"Intel-8080\"><a href=\"#Intel-8080\" class=\"headerlink\" title=\"Intel 8080\"></a>Intel 8080</h3><p>974年4月，8008的后续产品8080发布，是第一个成功的PC机Altair的处理器。</p>\n<p>14位的PC和寻址功能，16位地址总线和8位数据总线，七个8位寄存器。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2MHz</td>\n<td align=\"left\">8bit单核</td>\n<td align=\"left\">4500</td>\n<td align=\"left\">6微米</td>\n</tr>\n</tbody></table>\n<p>有IO端口，可以连接256个IO设备。因此可以连接I / O设备而不会占用或干扰寻址空间，还有一个信号引脚，该信号引脚可使堆栈占用单独的内存</p>\n<h3 id=\"x86架构出现-Intel-8086\"><a href=\"#x86架构出现-Intel-8086\" class=\"headerlink\" title=\"x86架构出现 Intel 8086\"></a>x86架构出现 Intel 8086</h3><p>1978年6月Intel 8086发布，x86架构诞生</p>\n<p>总线接口单元通过一个6字节的预取队列将指令流馈送到执行单元，因此，获取和执行是并发的-流水线的一种原始形式。</p>\n<p>数据寄存器通常被指令隐式使用，使临时值的寄存器分配变得复杂。它具有64K 8位I / O（或32K 16位）端口和固定向量中断。还可以通过索引寄存器设置四个段寄存器</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">5MHz</td>\n<td align=\"left\">16bit单核</td>\n<td align=\"left\">29000</td>\n<td align=\"left\">3微米</td>\n</tr>\n</tbody></table>\n<p>不足：与大多数分段处理器一样，8086不仅提供缺失的字节，还将分段寄存器（X 16或左移4位）添加到地址中。由于不增加地址位的情况下扩展地址空间而进行尝试的奇怪结果，有可能使两个具有相同值的指针指向两个不同的存储位置，或者使两个具有不同值的指针指向同一位置，并且受到限制典型的数据结构小于64K。但在高级语言中却引起了持续的混乱（例如近/远指针）。更糟糕的是，这使得将地址空间扩展到1 MB以上变得困难。</p>\n<h3 id=\"Intel-80286（1982）\"><a href=\"#Intel-80286（1982）\" class=\"headerlink\" title=\"Intel 80286（1982）\"></a>Intel 80286（1982）</h3><p>80286芯片，该芯片比8006和8088都有了飞跃的发展，时钟频率由最初的6MHz逐渐提高到20MHz。其内部和外部数据总线皆为16位，地址总线24位，可寻址16MB内存。采用PGA的正方形包装</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">6MHz</td>\n<td align=\"left\">16bit 单核</td>\n<td align=\"left\">134000</td>\n<td align=\"left\">1.5微米</td>\n</tr>\n</tbody></table>\n<p>从80286开始，CPU的工作方式也演变成两种：实模式和保护模式。</p>\n<p>实模式：微处理器可以访问内存限制在1MB</p>\n<p>保护模式：保护操作系统，遇到异常使用时系统不会停机</p>\n<p>不足：仅通过添加新模式将设计扩展到32位。进行切换返回时需要使用原始80286中被保留了下来的bug进行切换。所有内存访问都仍然限于64K段。</p>\n<h3 id=\"Intel-80386（1985）\"><a href=\"#Intel-80386（1985）\" class=\"headerlink\" title=\"Intel 80386（1985）\"></a>Intel 80386（1985）</h3><p>具有几种处理器模式（包括单独的分页和分段模式），添加了MMU，安全模式</p>\n<p>英特尔为80386设计了高速缓存（Cache），采取预读内存的方法来缓解这个速度瓶颈，从此以后，Cache就和CPU成为了如影随形的东西。</p>\n<p>英特尔借此机会修复了以前设计中剩余的一些最受欢迎的功能。转向x86-64，AMD决定进一步改进设计，增加了更简洁的64位模式</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">16MHz</td>\n<td align=\"left\">32bit 单核</td>\n<td align=\"left\">275000</td>\n<td align=\"left\">1.5微米</td>\n</tr>\n</tbody></table>\n<p>不足： 64位功能被设计为32位附加组件，并且在低端版本中被禁用。启用后，扩展的32位流水线将比主流水线晚1/2个时钟周期。</p>\n<h3 id=\"Intel-80486（1989）\"><a href=\"#Intel-80486（1989）\" class=\"headerlink\" title=\"Intel 80486（1989）\"></a>Intel 80486（1989）</h3><p>将80386和数学协微处理器80387以及一个8KB的高速缓存集成在一个芯片内。</p>\n<p>添加了完整的流水线，单片8K缓存，片上FPU和时钟加倍版本（例如Z-280）。</p>\n<p>内部缓存缩短了微处理器与慢速DRAM的等待时间。</p>\n<p>在80×86系列中首次采用了RISC（精简指令集）技术，可以在一个时钟周期内执行一条指令。它还采用了突发总线方式，大大提高了与内存的数据交换速度。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">25MHz</td>\n<td align=\"left\">32bit 单核</td>\n<td align=\"left\">1.2M</td>\n<td align=\"left\">1微米</td>\n</tr>\n</tbody></table>\n<p>不足：CPU的频率越来越快，而PC机外部设备受工艺限制，能够承受的工作频率有限，这就阻碍了CPU主频的进一步提高。</p>\n<p>在486的基础上，发展出了Intel 80486 DX/SX/DX2/DX4/SL CPU；Inter486 OverDrive，TI 486Dx，Cyrix 486DLC，Cyrix5x86，AMD 5×86</p>\n<h3 id=\"微-micro-架构的出现\"><a href=\"#微-micro-架构的出现\" class=\"headerlink\" title=\"微(micro)架构的出现\"></a>微(micro)架构的出现</h3><p>intel推出奔腾系列，P5微架构;</p>\n<p>amd推出K5微架构竞争，性能较差;</p>\n<h3 id=\"Intel-Pentium（1993）\"><a href=\"#Intel-Pentium（1993）\" class=\"headerlink\" title=\"Intel Pentium（1993）\"></a>Intel Pentium（1993）</h3><p>它也是第一个超标量Intel x86处理器（Intel公司把这种同时执行两条指令的能力称为超标量技术）。它具有双Integer流水线和单个浮点单元，允许它每个时钟发出并完成多个指令。</p>\n<p>从PENTIUM开始，我们大家有了超频这样一个用尝试少的钱换取尝试多的性能的好方法</p>\n<p>从Pentium开始，CPU封装开始出现扇热盖的设计，CPU的发热问题已经突显。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">60, 66MHz</td>\n<td align=\"left\">32bit 单核</td>\n<td align=\"left\">3.1M</td>\n<td align=\"left\">0.8微米</td>\n</tr>\n</tbody></table>\n<p>不足：i586程序(这个程序还有一些其他的名字，比如Linux用户就把它称为f00f程序)是一种越界攻击手段，处理器芯片会因为无法执行这个程序发来的非法指令而出现死机现象。</p>\n<p>这个程序似乎并没有利用奔腾CPU里浮点运算的弱点，它直接向CPU送去错误的指令。这种死机现象除了手动重置计算机外没有其他好的解决办法</p>\n<h3 id=\"Intel-Pentium-Pro（1995）\"><a href=\"#Intel-Pentium-Pro（1995）\" class=\"headerlink\" title=\"Intel Pentium Pro（1995）\"></a>Intel Pentium Pro（1995）</h3><p>为工作站和服务器设计，超算ASCI Red（第一台达到每秒万亿次浮点运算的计算机）。</p>\n<p>Pentium临的是在Pentium Pro的一个封装中除Pentium Pro芯片外还包括一个256KB的二级缓存芯片，两个芯片之间用高频宽的奔腾Pro200MHZ CPU的L2 CACHE即正在运行在200MHZ上，内部通讯总线互连，处理器与高速缓存的连接线路也被安置在该封装中，这样就使高速缓存能更容易地运行在更高的频率上。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">200MHz</td>\n<td align=\"left\">32bit 单核</td>\n<td align=\"left\">5.5M</td>\n<td align=\"left\">0.35微米</td>\n</tr>\n</tbody></table>\n<p>不足：但是肇因于0.35微米制程发热功率甚大，故其时脉不曾高于233 MHz（正式版不能超频）。此外，由于指令队列的问题，Pentium Pro的16bit指令执行能力低于Pentium，造成Windows3.X和Windows9X与DOS系统下Pentium Pro性能低下。</p>\n<h3 id=\"64位处理器的诞生\"><a href=\"#64位处理器的诞生\" class=\"headerlink\" title=\"64位处理器的诞生\"></a>64位处理器的诞生</h3><ul>\n<li>1961年：IBM发表IBM 7030 Stretch 超级电脑。它使用64位资料字组，以及32或64位的指令字组。</li>\n<li>1999年：Intel发布IA-64架构的指令集。AMD首次公开64位集以扩展给IA-32，称为x86-64（后来改名为AMD64）。</li>\n</ul>\n<h3 id=\"Intel-Xeon（2001）\"><a href=\"#Intel-Xeon（2001）\" class=\"headerlink\" title=\"Intel Xeon（2001）\"></a>Intel Xeon（2001）</h3><p>主要供非消费级服务站，服务器和嵌入式系统使用。</p>\n<p>基于英特尔的NetBurst架构，有更高级的网络功能，及更复杂更的3D图形性能，另一方面，支持至强的芯片组也在并行运算、支持高性能I/O子系统（如SCSI磁盘阵列、千兆网络接口）、支持PCI总线分段等方面更好地支持服务器端的运算。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1.7GHz</td>\n<td align=\"left\">32bit 单核</td>\n<td align=\"left\">42M</td>\n<td align=\"left\">180nm</td>\n</tr>\n</tbody></table>\n<h3 id=\"多核处理器的出现\"><a href=\"#多核处理器的出现\" class=\"headerlink\" title=\"多核处理器的出现\"></a>多核处理器的出现</h3><p>2000年IBM发布POWER4,双核心处理器；</p>\n<p>2005年4月，AMD发布皓龙(Opteron)双核处理器</p>\n<h3 id=\"Core-2（2009）\"><a href=\"#Core-2（2009）\" class=\"headerlink\" title=\"Core 2（2009）\"></a>Core 2（2009）</h3><p>第一款微架构处理器，取代由2000年起大多数英特尔处理器采用的NetBurst架构。</p>\n<p>提升缓冲存储器效率、核心数量等作出优化。这些新处理器的功耗比以往的Pentium 4/D处理器低很多。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时钟频率</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">晶体管</th>\n<th align=\"left\">工艺</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1.06GHz~3.33GHz</td>\n<td align=\"left\">64bit，1,2,4核</td>\n<td align=\"left\">291M</td>\n<td align=\"left\">65nm</td>\n</tr>\n</tbody></table>\n<p>不足：Core 2处理器的主板售价较高，导致组装成本大幅增加所致</p>\n<h3 id=\"Alder-Lake-大小核\"><a href=\"#Alder-Lake-大小核\" class=\"headerlink\" title=\"Alder Lake 大小核\"></a>Alder Lake 大小核</h3><p>待补充。。。</p>\n","raw":null,"categories":[{"name":"基础架构","path":"api/categories/基础架构.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"编程基础","path":"api/tags/编程基础.json"}]},{"title":"计算机体系架构","slug":"systemstructure/base/nounsofcomputersystem","date":"2020-02-12T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/base/nounsofcomputersystem.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635138915ec7f297aec7014e527553987e20070c8","content":"<p>[toc]</p>\n<h1 id=\"cpu\"><a href=\"#cpu\" class=\"headerlink\" title=\"cpu\"></a>cpu</h1><h3 id=\"socket-s\"><a href=\"#socket-s\" class=\"headerlink\" title=\"socket(s)\"></a>socket(s)</h3><p>主板上物理CPU插槽</p>\n<h3 id=\"cpu-die\"><a href=\"#cpu-die\" class=\"headerlink\" title=\"cpu die\"></a>cpu die</h3><p>Die指从晶圆上切割下来的小方块，一个die内可能存在多个cpu内核，一个或多个Die可封装成一个CPU package(cpu socket)。</p>\n<p>die之间通过片外总线互联，不同die之间的cpu内核不能共享cpu缓存(cache)，die内内核可共享L3 cache</p>\n<h3 id=\"NUMA-nodes\"><a href=\"#NUMA-nodes\" class=\"headerlink\" title=\"NUMA nodes\"></a>NUMA nodes</h3><p>一个socket可以划分多个NUMA node</p>\n<ul>\n<li>NUMA 引入了本地内存和远程内存，CPU 访问本地内存的延迟会小于访问远程内存；</li>\n<li>NUMA 的内存分配与内存回收策略结合时会可能会导致 Linux 的频繁交换分区（Swap）进而影响系统的稳定性</li>\n</ul>\n<h3 id=\"Core\"><a href=\"#Core\" class=\"headerlink\" title=\"Core\"></a>Core</h3><p>CPU的内核，一般一个socket含有多个Core</p>\n<h3 id=\"Thread-s\"><a href=\"#Thread-s\" class=\"headerlink\" title=\"Thread(s)\"></a>Thread(s)</h3><p>超线程技术，一个core包含多个并行处理任务的thread，thread有独立执行上下文，共享内部寄存器，我们常说(看)的</p>\n<h1 id=\"主板\"><a href=\"#主板\" class=\"headerlink\" title=\"主板\"></a>主板</h1><h3 id=\"PCH-蓝厂南桥，Platform-Controller-Hub\"><a href=\"#PCH-蓝厂南桥，Platform-Controller-Hub\" class=\"headerlink\" title=\"PCH(蓝厂南桥，Platform Controller Hub)\"></a>PCH(蓝厂南桥，Platform Controller Hub)</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://upload.wikimedia.org/wikipedia/commons/5/53/Intel_5_Series_architecture.png\" alt=\"img\"></p>\n<p>淘汰南北桥设计，即将被SOP(不用DMI，用PCIe、USB等)淘汰，功能一直在增删</p>\n<p>PCH具有原来ICH(I/O controller hub,南桥)的全部功能，又具有原来MCH(memory control hub,北桥)的管理引擎功能</p>\n<h3 id=\"mmu-memory-management-unit，内存管理单元\"><a href=\"#mmu-memory-management-unit，内存管理单元\" class=\"headerlink\" title=\"mmu(memory management unit，内存管理单元)\"></a>mmu(memory management unit，内存管理单元)</h3><p>负责处理cpu的内存访问请求的计算机硬件</p>\n<p>功能：虚拟地址到物理地址转换、内存保护、cpu告诉缓存控制</p>\n<h4 id=\"虚拟内存管理技术\"><a href=\"#虚拟内存管理技术\" class=\"headerlink\" title=\"虚拟内存管理技术\"></a>虚拟内存管理技术</h4><p>早期PC 程序直接运行在屋里内存上，有下面几个缺点：</p>\n<ol>\n<li>物理内存不够，如，程序需要100k，物理内存只有64k</li>\n<li>程序每次装载到内存地址不一样</li>\n<li>内存使用率低，需要将整个程序放入内存才能运行</li>\n<li>多任务操作系统，多个进程间地址空间不隔离，一个任务失败可能导致整个系统崩溃</li>\n</ol>\n<h4 id=\"MMU的分页技术\"><a href=\"#MMU的分页技术\" class=\"headerlink\" title=\"MMU的分页技术\"></a>MMU的分页技术</h4><p>虚拟地址空间划分成页(page)，物理地址分成页框(frame)，页和页框大小相同，程序访问虚拟内存，虚拟内存对应物理内存，物理内存并不一定存着虚拟内存所需要的页，可能存在外存中。</p>\n<h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><h3 id=\"网络字节序\"><a href=\"#网络字节序\" class=\"headerlink\" title=\"网络字节序\"></a>网络字节序</h3><p>msb：most significant bit,最高有效位，二进制中的msb是最高位</p>\n<p>lsb：least significant bit, 最低有效位，二进制中的lsb事最后一位</p>\n<p>大端模式：big-endian，数据高位字节放内存低地址端</p>\n<p>小端模式：little-eendian，数据低位字节放内存低地址端</p>\n<p>主机可能大端也可能小端</p>\n<p>网络字节序与cpu类型、操作系统无关，网络字节序采用大端模式</p>\n<h1 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h1><h1 id=\"体系技术\"><a href=\"#体系技术\" class=\"headerlink\" title=\"体系技术\"></a>体系技术</h1>","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"编程基础","path":"api/tags/编程基础.json"}]},{"title":"三分钟入门分布式系统","slug":"systemstructure/distributedsystems/distributedbasics","date":"2021-06-25T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/distributedsystems/distributedbasics.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139026v2-d8c785337cc8600d5a444e949e9ab236_r.jpg","content":"<p>[toc]</p>\n<h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>为了完成共同的任务，通过某种通信方式(一般是网络)使用多个计算机节点。这个由多个计算节点组成的系统就是分布式系统。通俗来说就是使用更多机器来处理问题，其实我们的互联网就是一个分布式系统。</p>\n<h2 id=\"为什么要使用分布式系统\"><a href=\"#为什么要使用分布式系统\" class=\"headerlink\" title=\"为什么要使用分布式系统\"></a>为什么要使用分布式系统</h2><p>单节点计算、存储能力弱，硬件提升性价比低，应用消耗资源过于高时；要实现高可用、高并发时；可以无限的横向扩展</p>\n<h2 id=\"如何实现分布式\"><a href=\"#如何实现分布式\" class=\"headerlink\" title=\"如何实现分布式\"></a>如何实现分布式</h2><p>简单来说就是对任务分而治之(贯穿整个计算机上下的底层思想，而且来源于生活)，即是分片(partition),把不同分片交给不同节点处理即可，在未来保证可用性与并发性时，我们将分片冗余处理(一个分片交给多个节点处理)</p>\n<h2 id=\"CAP定理\"><a href=\"#CAP定理\" class=\"headerlink\" title=\"CAP定理\"></a>CAP定理</h2><p>定理指的是一个经过逻辑证明的猜想；2000年布鲁尔提出此猜想2002年MIT的大佬给出证明</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>CAP定理指出一个分布式系统不能同时满足一下三点</p>\n<ul>\n<li>一致性(Consistency)所有节点访问同一份最新的数据副本</li>\n<li>可用性(Availability)每次请求都能获取到非错的响应</li>\n<li>分区容错性(Partition tolerance)一个分布式系统中出现故障导致分裂成多个计算节点（区）；这些区应能使系统正常运行，一般来说P应该一定要满足的，弱不满足那么就违背了分布式系统初衷</li>\n</ul>\n<h3 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h3><p>CAP只能三选二，那么我们就有三种策略，我们看一下有哪些情况会用到</p>\n<p>CA：放弃P，会导致分布式节点无法进行扩展，传统的关系型数据库就是如此，一般P是必选项</p>\n<p>CP：牺牲用户体验，常见分布式数据库以及银行系统就是</p>\n<p>AP：牺牲一致性，淘宝、12306等就是</p>\n<h2 id=\"BASE理论\"><a href=\"#BASE理论\" class=\"headerlink\" title=\"BASE理论\"></a>BASE理论</h2><p>为平衡CAP提出，包含</p>\n<p>基本可用(Basically Available): 在出现故障时，允许部分可用性（基础可用）</p>\n<p>软状态(Soft State):允许出现中间状态，不同节点之间数据不一致</p>\n<p>最终一致性(Eventual Consistency):软状态不可持续，在有限期限后应能保证数据的最终一致</p>\n<h2 id=\"一致性算法\"><a href=\"#一致性算法\" class=\"headerlink\" title=\"一致性算法\"></a>一致性算法</h2><p>后续文章会详细介绍这些算法</p>\n<h3 id=\"强一致性算法\"><a href=\"#强一致性算法\" class=\"headerlink\" title=\"强一致性算法\"></a>强一致性算法</h3><p>Paxos：我最喜欢的图灵奖获得者Leslie Lamport于90年提出，几乎所有强一致性算法鼻祖，后续文章会详细介绍</p>\n<p>Raft(Paxos变种)：etcd使用</p>\n<p>ZAB(Paxos变种)：ZooKeeper使用</p>\n<h3 id=\"最终一致性算法\"><a href=\"#最终一致性算法\" class=\"headerlink\" title=\"最终一致性算法\"></a>最终一致性算法</h3><p>DNS系统：域名解析，超过TTL逐步向上询问</p>\n<p>Gossip算法：逆熵算法，Cassandra中使用</p>\n<h2 id=\"不要做那些假设\"><a href=\"#不要做那些假设\" class=\"headerlink\" title=\"不要做那些假设\"></a>不要做那些假设</h2><p>还记得我们前几天发的极客法则吗，不要做以下假设，在实际生产上会遇到不同问题需要实际处理</p>\n<ul>\n<li>网络可靠</li>\n<li>延迟为零</li>\n<li>带宽无限</li>\n<li>网络安全</li>\n<li>拓扑恒定</li>\n<li>单一管理员</li>\n<li>运输成本为零</li>\n<li>网络为同构的</li>\n</ul>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"分布式","path":"api/tags/分布式.json"}]},{"title":"react antd","slug":"systemstructure/font/reactandantd","date":"2020-03-25T11:34:56.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/font/reactandantd.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139070react_hooks_web-min.png","content":"<ol>\n<li>antd  是<a href=\"https://www.html.cn/create-react-app/\">react </a>UI 组件库 </li>\n<li>使用 <code>npx create-react-app 项目名（项目名不能为大写字母）</code>yarn create  react-app 项目名`</li>\n<li><code>npm start</code>  <code>yarn start</code></li>\n<li><code>yarn test</code> 测试</li>\n<li>package-lock.json文件锁定所有模块的版本号，包括主模块和所有依赖子模块。 当你执行npm install的时候，node从package.json文件读取模块名称，从package-lock.json文件中获取版本号，(类似 go.mod 和 go.sum )</li>\n<li>Webpack 只处理 <code>src</code> 中的文件。 你需要<strong>将任何 JS 和 CSS 文件放在 <code>src</code> 中</strong>，否则 Webpack 将发现不了它们。webpack 是react的前端打包工具</li>\n</ol>\n<h4 id=\"ajax\"><a href=\"#ajax\" class=\"headerlink\" title=\"ajax\"></a>ajax</h4><ol>\n<li><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）</p>\n</li>\n<li><p>AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p>\n</li>\n<li><p>AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。</p>\n</li>\n<li><p>如需将请求发送到服务器，我们使用 <strong>XMLHttpRequest</strong> 对象的 <strong>open()</strong> 和 <strong>send()</strong> 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);</span><br><span class=\"line\">xmlhttp.send();</span><br></pre></td></tr></table></figure></li>\n<li><p>如需使用 async=false，请将 open() 方法中的第三个参数改为 false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);</span><br></pre></td></tr></table></figure>\n\n<p>我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。</p>\n<p>请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。</p>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"前端","path":"api/tags/前端.json"}]},{"title":"linux的boot目录","slug":"systemstructure/linux/boot","date":"2021-09-25T12:13:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/boot.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351392001-642-png_6_0_0_0_0_0_0_1258.74_1781.819-1259-0-755-1259.jpg","content":"<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351392001-642-png_6_0_0_0_0_0_0_1258.74_1781.819-1259-0-755-1259.jpg\" alt=\"See the source image\"></p>\n<p>1.查看当前运行的linux内核编译参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">两个方法，proc要求在内核编译时增减相应的选项才会生成，很多系统没有/proc/config.gz，第二种方法，一般</span></span><br><span class=\"line\">zcat /proc/config.gz</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">或</span></span><br><span class=\"line\">cat /boot/config-$(uname -r)</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"计算机启动到操作系统运行","slug":"systemstructure/linux/bootofcomputer","date":"2020-04-25T12:13:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/bootofcomputer.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139306R-C.81d56db1bef63aa01cbba73b33caedf3?rik=3YtNM7LX%2fwHS5Q&riu=http%3a%2f%2fwww.linuxidc.com%2fupload%2f2016_06%2f160617100110611.png&ehk=0SHzV%2fqNHRE7jk8jqfwwge4teKMqurNw7sM4KipqkaA%3d&risl=&pid=ImgRaw&r=0","content":"<p>首先学一个东西，一定要有一个<strong>前置</strong>的知识，我们把它当做已知的，我不可能从原子组成分子开始讲原理。那学习计算机启动过程的前置知识是什么呢？我要求你已知以下几点：</p>\n<ol>\n<li>内存是存储数据的地方，给出一个地址信号，内存可以返回该地址所对应的数据。</li>\n<li>CPU 的工作方式就是不断从内存中取出指令，并执行。</li>\n<li>CPU 从内存的哪个地址取出指令，是由一个寄存器中的值决定的，这个值会不断进行 +1 操作，或者由某条跳转指令指定其值是多少。</li>\n</ol>\n<p>好了，只需要知道这三点<strong>前置</strong>知识，你就能专业地解释计算机的启动过程了。</p>\n<h2 id=\"一、为什么是-BIOS-主导？\"><a href=\"#一、为什么是-BIOS-主导？\" class=\"headerlink\" title=\"一、为什么是 BIOS 主导？\"></a>一、为什么是 BIOS 主导？</h2><p>都说开机后，BIOS 就开始运行自己的程序了，又硬件自检，又加载启动区的。我就不服了，为什么开机后是执行 BIOS 里的程序？为啥不是内存里的？为啥不是硬盘里的？</p>\n<p>好的，不要怀疑前置知识，CPU 的工作方式，就是不断从内存中取指令并执行，那为什么会说是执行 BIOS 里的程序呢？这就不得不说说<strong>内存映射</strong>了。</p>\n<h2 id=\"二、内存映射\"><a href=\"#二、内存映射\" class=\"headerlink\" title=\"二、内存映射\"></a>二、内存映射</h2><p><strong>CPU 地址总线的宽度决定了可访问的内存空间的大小</strong>。比如 16 位的 CPU 地址总线宽度为 20 位，地址范围是 1M。32 位的 CPU 地址总线宽度为 32 位，地址范围是 4G。你可以算算我们现在的 64 位机的地址范围。</p>\n<p>可是，可访问的内存空间这么大，并不等于说全都给内存使用，也就是说寻址的对象不只有内存，还有一些外设也要通过地址总线的方式去访问，那怎么去访问这些外设呢？就是在地址范围中划出一片片的区域，这块给显存使用，那块给硬盘控制器使用，等等 。</p>\n<p>这样说，其实就不符合我们的前置知识了，所以可以有一种不太正确的理解方式，那就是内存中的这块位置就是显存，那块位置就是硬盘控制器。我们在相应的位置上读取或者写入，就相当于在显存等外设的相应位置上读取或者写入，就好像这些外设的存储区域，被<strong>映射</strong>到了内存中的某一片区域一样。这样我们就不用管那些外设啦，关注点仍然是一个简简单单的内存。这就是所谓的<strong>内存映射</strong>。</p>\n<p>太好了，现在又用简单的前置知识就能解释得通了，我们继续往下推。</p>\n<h2 id=\"三、实模式下的内存分布\"><a href=\"#三、实模式下的内存分布\" class=\"headerlink\" title=\"三、实模式下的内存分布\"></a>三、实模式下的内存分布</h2><p>刚刚说到内存中划分出了一片一片区域给各种外设，那么问题自然就来了，哪块区域，分给了哪块外设了呢？如果是规定，那应该有一张表比较好吧。嗯没错，还真有，它就是实模式下的内存分布，笔者给它画了一张图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139328640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">在这里插入图片描述</p>\n<p>哎哟我真是个小天使，把比例都表现出来了，网上能再找出比我这个更直观的请给我留言。实模式之后再解释，现在简单理解就是计算机刚开机的时候只有 1M 的内存可用。</p>\n<p>我们看到，内存被各种外设瓜分了，即映射在了内存中。BIOS 更狠，不但其空间被映射到了内存 0xC0000 - 0xFFFFF 位置，其里面的程序还占用了开头的一些区域，比如把中断向量表写在了内存开始的位置，真所谓先到先得啊。</p>\n<h2 id=\"四、怎么就从-BIOS-里的程序开始执行了\"><a href=\"#四、怎么就从-BIOS-里的程序开始执行了\" class=\"headerlink\" title=\"四、怎么就从 BIOS 里的程序开始执行了\"></a>四、怎么就从 BIOS 里的程序开始执行了</h2><p>好了，现在我们知道 BIOS 里的信息被映射到了内存 0xC0000 - 0xFFFFF 位置，其中最为关键的系统 BIOS 被映射到了 0xF0000 - 0xFFFFF 位置。假如我现在说，CPU 开机就是执行了这块区域的代码，然后巴拉巴拉一顿操作就开机了，你肯定要喷我了，为什么就执行到这了呢，那咋不从头开始执行？</p>\n<p>这就自然有了一种猜想，我们要用到另一个前置知识了，就是 CPU 从内存的哪个位置取出执行并执行呢？<strong>是 PC 寄存器中的地址值</strong>。BIOS 程序的入口地址也就是开始地址是 0xFFFF0（人家就那么写的），也就是开机键一按下，一定有一个神奇的力量，将 pc 寄存器中的值变成 0xFFFF0，然后 CPU 就开始马不停蹄地跑了起来。没错，接下来这句话，可能就是你找了很久的答案，请做好准备：</p>\n<p><strong>在你开机的一瞬间，CPU 的 PC 寄存器被强制初始化为 0xFFFF0</strong>。如果再说具体些，CPU 将段基址寄存器 cs 初始化为 0xF000，将偏移地址寄存器 IP 初始化为 0xFFF0，根据实模式下的最终地址计算规则，将段基址左移 4 位，加上偏移地址，得到最终的物理地址也就是抽象出来的 PC 寄存器地址为 0xFFFF0。</p>\n<p>当我在学习这段知识时，看到这句话才让将我心里积压了很久的疑惑解开，多么简单粗暴的道理啊。写到这里我也是长舒了一口气，因为剩下的过程，就几乎只是流水账一样的正推了。</p>\n<p>至于怎么强制初始化的，我觉得就越过了前置知识的边界了，况且各个厂商的硬件实现也不一定相同，有很多办法，也很简单。讨论起来意义就不大了。</p>\n<h2 id=\"五、BIOS-里到底写了什么程序\"><a href=\"#五、BIOS-里到底写了什么程序\" class=\"headerlink\" title=\"五、BIOS 里到底写了什么程序\"></a>五、BIOS 里到底写了什么程序</h2><p>好了，我们现在知道了 BIOS 被映射到了内存的某个位置，并且开机一瞬间 CPU 强制将自己的 pc 寄存器初始化为 BIOS 程序的入口地址，从这里开始 CPU 马不停蹄地向前跑了起来。那接下来的问题似乎也非常自然地就问出来了，那就是 BIOS 程序里到底写了啥？</p>\n<p>把 BIOS 程序里的二进制信息全贴出来也不合适，我们分析一些主要的。我们首先还是来猜测，你看入口地址是 0xFFFF0，说明程序是从这执行的。实模式下内存的下边界就是 0xFFFFF，也就是只剩下 16 个字节的空间可以写代码了，这够干啥的呢？如果你有心的话应该能猜出，入口地址处可能是个跳转指令，跳到一个更大范围的空间去执行自己的任务。没错就是这样，0xFFFF0 处存储的机器指令，翻译成汇编语言是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp far f000:e05b</span><br></pre></td></tr></table></figure>\n\n<p>意思是跳转到物理地址 0xfe05b 处开始执行（回忆下前面说的实模式下的地址计算方式）。</p>\n<p>地址 0xfe05b 处开始，便是 BIOS 真正发挥作用的代码了，这块代码会检测一些外设信息，并初始化好硬件，建立中断向量表并填写中断例程。这里的部分不要展开，这只是一段写死的程序而已，而且对理解开机启动过程无帮助，我们看后面精彩的部分，也就是 BIOS 的最后一项工作：<strong>加载启动区</strong>。</p>\n<h2 id=\"六、0x7c00-是啥\"><a href=\"#六、0x7c00-是啥\" class=\"headerlink\" title=\"六、0x7c00 是啥\"></a>六、0x7c00 是啥</h2><p>该较真的地方就是要较真，我绝对不会让<strong>加载</strong>这种魔幻的词出现在这里，我们现在就来把它拆解成人话。</p>\n<p>其实这个词也并不魔幻，加载在计算机领域就是指，<strong>把某设备上（比如硬盘）的程序复制到内存中的过程</strong>。那加载启动区这个过程，翻译过来就是，<strong>BIOS 程序把启动区的内容复制到了内存中的某个区域</strong>。好了，问题又自然出来了，启动区是哪里？被复制到了内存的哪个位置？然后呢？我们一个个来回答。</p>\n<p>什么是启动区呢？即使你不知道，你也应该能够猜到，一定是符合某种特征的一块区域，于是人们把它就叫做启动区了，那要符合什么特征呢？先不急，不知道你有没有过设置 BIOS 启动顺序的经历，通常有 U 盘启动、硬盘启动、软盘启动、光盘启动等等，<strong>BIOS 会按照顺序，读取这些启动盘中位于 0 盘 0 道 1 扇区的内容</strong>。</p>\n<p>至于磁盘格式的划分，本篇就不做讲解了，总之对于内存，我们给出一个数字地址就能获取到该地址的数据，而对于磁盘，我们需要给出磁头、柱面、扇区这三个信息才能定位某个位置的数据，都是描述位置的一种方式而已。</p>\n<p>接着说， 这 0 盘 0 道 1 扇区的内容一共有 512 个字节，<strong>如果末尾的两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区</strong>。如果不是，那么按顺序继续向下个设备中寻找位于 0 盘 0 道 1 扇区的内容。如果最后发现都没找到符合条件的，那直接报出一个无启动区的错误。</p>\n<p>BIOS 找到了这个启动区之后干嘛呢？哦，前面说过了是加载，<strong>就是把这 512 个字节的内容，一个比特都不少的全部复制到内存的 0x7c00 这个位置</strong>。怎么复制的？当然是指令啦。哪些指令呢？这里我只能简单说指令集中是有 in 和 out 的，用来将外设中的数据复制到内存，或者将内存中的数据复制到外设，用这两个指令，以及外设给我们提供的读取方式，就能做到这一点啦。</p>\n<p>启动区内容此时已经被 BIOS 程序复制到了内存的 0x7c00 这个位置，然后呢？这个其实也不难猜测，启动区的内容就是我们自己写的代码了，复制到这里之后，就开始执行呗，之后我们的程序就接管了接下来的流程，BIOS 的使命也就结束啦。所以复制完之后，接下来应该是一个跳转指令吧！没错，正是这样，PC 寄存器的值变为 0x7c00，指令开始从这里执行。</p>\n<p>咦？不知道你有没有发现，我们似乎不知不觉又把之前的一句魔法语言翻译成人话了，开头我们说：</p>\n<blockquote>\n<p>BIOS 把控制权转交给排在第一位的存储设备。</p>\n</blockquote>\n<p>所以这句话是什么意思呢？<strong>就是 BIOS 把启动区的 512 字节复制到内存的 0x7c00 位置，并且用一条跳转指令将 pc 寄存器的值指向 0x7c00</strong>。你看，这不是也没多几个字嘛，就把这个问题说得明明白白，简简单单。</p>\n<p>哦，对了，现在似乎就剩下一个问题了，为什么非要是 0x7c00 呢？好问题，当然答案也很简单，那就是人家 BIOS 开发团队就是这样定的，之后也不好改了，不然不兼容。为什么不好改？我们看一个简单的启动区 512 字节的代码。（代码摘抄自《30 天自制操作系统》）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; hello-os</span><br><span class=\"line\">; TAB&#x3D;4</span><br><span class=\"line\"></span><br><span class=\"line\">  ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置</span><br><span class=\"line\"></span><br><span class=\"line\">;程序主体</span><br><span class=\"line\"></span><br><span class=\"line\">entry:</span><br><span class=\"line\">  MOV  AX,0   ;初始化寄存器</span><br><span class=\"line\">  MOV  SS,AX</span><br><span class=\"line\">  MOV  SP,0x7c00</span><br><span class=\"line\">  MOV  DS,AX   ;段寄存器初始化为 0</span><br><span class=\"line\">  MOV  ES,AX</span><br><span class=\"line\">  MOV  SI,msg</span><br><span class=\"line\">putloop:</span><br><span class=\"line\">  MOV  AL,[SI]</span><br><span class=\"line\">  ADD  SI,1</span><br><span class=\"line\">  CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符</span><br><span class=\"line\">  JE  fin</span><br><span class=\"line\">  MOV  AH,0x0e   ;指定文字</span><br><span class=\"line\">  MOV  BX,15   ;指定颜色</span><br><span class=\"line\">  INT  0x10   ;调用 BIOS 显示字符函数</span><br><span class=\"line\">  JMP  putloop</span><br><span class=\"line\">fin:</span><br><span class=\"line\">  HLT</span><br><span class=\"line\">  JMP  fin</span><br><span class=\"line\">msg:</span><br><span class=\"line\">  DB  0x0a,0x0a  ;换行、换行</span><br><span class=\"line\">  DB  &quot;hello-os&quot;</span><br><span class=\"line\">  DB  0x0a   ;换行</span><br><span class=\"line\">  DB  0    ;0 结尾</span><br><span class=\"line\"></span><br><span class=\"line\">  RESB 0x7dfe-$   ;填充0到512字节</span><br><span class=\"line\">  DB 0x55, 0xaa   ;可启动设备标识</span><br></pre></td></tr></table></figure>\n\n<p>我们看第一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ORG  0x7c00</span><br></pre></td></tr></table></figure>\n\n<p>这个数字就是刚刚说的启动区加载位置，这行汇编代码简单说就表示把下面的地址统统加上 0x7c00。正因为 BIOS 将启动区的代码加载到了这里，因此有了一个偏移量，所以所有写启动区代码的人就需要在开头写死一个这样的代码，不然全都串位了。</p>\n<p>然后正因为所有写操作系统的，启动区的第一行汇编代码都写死了这个数字，那 BIOS 开发者最初定的这个数字就不好改了，否则它得挨个联系各个操作系统的开发厂商，说唉我这个地址改一下哈，你们跟着改改。在公司推动另一个团队改个代码都得大费周折，想想看这样的推动得耗费多大人力。况且即使改了，之前的代码也都不兼容了，这不得被人们骂死啊。</p>\n<p>再看最后一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DB 0x55, 0xaa</span><br></pre></td></tr></table></figure>\n\n<p>这也验证了我们之前说的这 512 字节的最后两个字节得是 0x55 0xaa，BIOS 才会认为它是一个启动区，才会去加载它，仅此而已。</p>\n<p>回过头来说 0x7c00 这个值，它其实就是一个规定死的值，但还是会有人问，那必然有它的合理性吧。其实，我的解释也只能说是人家规定了这个值，后人们替他们解释这个合理性，并不是说当初人家就一定是这样想的，就好比我们做语文的阅读理解题一样。</p>\n<p>第一个 BIOS 开发团队是 IBM PC 5150 BIOS，当时被认为的第一个操作系统是 DOS 1.0 操作系统，BIOS 团队就假设是为它服务的。但操作系统还没出，BIOS 团队假设其操作系统需要的最小内存为 32 KB。BIOS 希望自己所加载的启动区代码尽量靠后，这样比较“安全”，不至于过早的被其他程序覆盖掉。可是如果仅仅留 512 字节又感觉太悬了，还有一些栈空间需要预留，那扩大到 1 KB 吧。这样 32 KB 的末尾是 0x8000，减去 1KB(0x400) ，刚好等于 0x7c00。哇塞，太精准了，这可以是一种解释方式。</p>\n<h2 id=\"七、启动区里的代码写了啥\"><a href=\"#七、启动区里的代码写了啥\" class=\"headerlink\" title=\"七、启动区里的代码写了啥\"></a>七、启动区里的代码写了啥</h2><p>其实写到这，我这篇文章就应该戛然而止了，因为最初的那个问题已经解决了，CPU 已经开始马不停蹄地从我们预期的位置跑起来了，万事开头难，剩下的内容，就是操作系统想怎么玩就怎么玩了。</p>\n<p>但我觉得还不够味，似乎还有些问题萦绕在你脑海里。比如说这个问题：</p>\n<blockquote>\n<p>启动区里的代码写了啥？就 512 字节就是全部操作系统内容了？</p>\n</blockquote>\n<p>这是一个好问题，512 个字节确实干不了啥，现在的操作系统怎么也得按 M 为单位算吧，512 个字节远远不够呢，那是怎么回事呢？</p>\n<p>其实我们可以按照之前的思路猜测，BIOS 用很少的代码就把 512 字节的启动区内容加载到了内存，并跳转过去开始执行。那按照这个套路，这 512 字节的启动区代码，是不是也可以把更多磁盘中存储的操作系统程序，加载到内存的某个位置，然后跳转过去呢？</p>\n<p>没错，就是这个套路。<strong>所以 BIOS 负责加载了启动区，而启动区又负责加载真正的操作系统内核</strong>，这配合默契吧？</p>\n<p>由于用于启动盘的磁盘是人家写操作系统的厂商制作的，俗称制作启动盘，所以他也肯定知道操作系统的核心代码存储在磁盘的哪个扇区，因此启动区就把这个扇区，以及之后的好多好多扇区（具体取决于操作系统有多大）都读到内存中，然后跳转到开始的程序开始的位置。跳转到哪里呢？这个就不像 0x7c00 这个数那么经典了，不同的操作系统肯定也不一样，也不用事先规定好，反正写操作系统的人给自己定一个就好了，别覆盖其他关键设备用到的区域就好。</p>\n<h2 id=\"八、操作系统内核写了啥\"><a href=\"#八、操作系统内核写了啥\" class=\"headerlink\" title=\"八、操作系统内核写了啥\"></a>八、操作系统内核写了啥</h2><p>好了现在经过好几轮跳跳跳，终于跳到内核代码啦，我们来一起回顾一下：</p>\n<ol>\n<li>按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址（一跳）</li>\n<li>该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）</li>\n<li>执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）</li>\n<li>启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139335949069-20190421160331677-268089991.png\" alt=\"img\"></p>\n<h1 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h1><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351393421635139306R-C.81d56db1bef63aa01cbba73b33caedf3?rik=3YtNM7LX/wHS5Q&riu=http://www.linuxidc.com/upload/2016_06/160617100110611.png&ehk=0SHzV/qNHRE7jk8jqfwwge4teKMqurNw7sM4KipqkaA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"linux kernel更换","slug":"systemstructure/linux/changekernel","date":"2020-04-15T12:02:01.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/changekernel.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139368linux-kernel.png","content":"<p>CentOS 是RHEL（Red Hat Enterprise Linux）源代码再编译的产物</p>\n<table>\n<thead>\n<tr>\n<th>发行版本</th>\n<th>发行时间</th>\n<th>内核版本</th>\n<th>发布时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2.1</td>\n<td>2004.05.14</td>\n<td>kernel-2.4.9</td>\n<td>2011.08</td>\n</tr>\n<tr>\n<td>3.1~3.9</td>\n<td>2004.03.19~2007.07.26</td>\n<td>kernel-2.4.21</td>\n<td>2003.01</td>\n</tr>\n<tr>\n<td>4.0~4.9</td>\n<td>2005.03.09~2011.03.02</td>\n<td>kernel-2.6.9</td>\n<td>2004.10</td>\n</tr>\n<tr>\n<td>5.0~5.11</td>\n<td>2007.04.12~2014.09.30</td>\n<td>kernel-2.6.18</td>\n<td>2006.09</td>\n</tr>\n<tr>\n<td>6.0~6.10</td>\n<td>2011.07.04~</td>\n<td>kernel-2.6.32</td>\n<td>2009.12</td>\n</tr>\n<tr>\n<td>7.0.1406</td>\n<td>2014.07.07</td>\n<td>kernel-3.10.0-123</td>\n<td>2013.07</td>\n</tr>\n<tr>\n<td>7.1.1503</td>\n<td>2015.03.31</td>\n<td>kernel-3.10.0-229</td>\n<td></td>\n</tr>\n<tr>\n<td>7.2.1511</td>\n<td>2015.12.15</td>\n<td>kernel-3.10.0-327</td>\n<td></td>\n</tr>\n<tr>\n<td>7.3.1611</td>\n<td>2016.12.12</td>\n<td>kernel-3.10.0-514</td>\n<td></td>\n</tr>\n<tr>\n<td>7.4.1708</td>\n<td>2017.09.13</td>\n<td>kernel-3.10.0-693</td>\n<td></td>\n</tr>\n<tr>\n<td>7.5.1804</td>\n<td>2018.05.10</td>\n<td>kernel-3.10.0-862</td>\n<td></td>\n</tr>\n<tr>\n<td>7.6.1810</td>\n<td>2018.12.04</td>\n<td>kernel-3.10.0-957</td>\n<td></td>\n</tr>\n<tr>\n<td>7.7.1908</td>\n<td>2019.09.18</td>\n<td>kernel-3.10.0-1062</td>\n<td></td>\n</tr>\n<tr>\n<td>8.0.1905</td>\n<td>2019-09-25</td>\n<td>kernel-4.18.0-80</td>\n<td>2018.08</td>\n</tr>\n</tbody></table>\n<p>ubuntu</p>\n<table>\n<thead>\n<tr>\n<th>发行版本</th>\n<th>发行时间</th>\n<th>内核版本</th>\n<th>发布时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>4.10</td>\n<td>2004.10.20</td>\n<td>2.6.8</td>\n<td>2004.08</td>\n</tr>\n<tr>\n<td>5.04</td>\n<td>2005.04.08</td>\n<td>2.6.10</td>\n<td>2004.12</td>\n</tr>\n<tr>\n<td>5.10</td>\n<td>2005.10.13</td>\n<td>2.6.12</td>\n<td>2005.01</td>\n</tr>\n<tr>\n<td>6.06</td>\n<td>2006.06.01(LTS)</td>\n<td>2.6.15</td>\n<td>2006.01</td>\n</tr>\n<tr>\n<td>6.10</td>\n<td>2006.10.06</td>\n<td>2.6.17</td>\n<td>2006.06</td>\n</tr>\n<tr>\n<td>7.04</td>\n<td>2007.04.19</td>\n<td>2.6.20</td>\n<td>2007.02</td>\n</tr>\n<tr>\n<td>7.10</td>\n<td>2007.10.18</td>\n<td>2.6.22</td>\n<td>2007.07</td>\n</tr>\n<tr>\n<td>8.04</td>\n<td>2008.04.24(LTS)</td>\n<td>2.6.24</td>\n<td>2008.01</td>\n</tr>\n<tr>\n<td>8.10</td>\n<td>2008.10.30</td>\n<td>2.6.27</td>\n<td>2008.10</td>\n</tr>\n<tr>\n<td>9.04</td>\n<td>2009.04.23</td>\n<td>2.6.28</td>\n<td>2009.01</td>\n</tr>\n<tr>\n<td>9.10</td>\n<td>2009.10.29</td>\n<td>2.6.31</td>\n<td>2009.09</td>\n</tr>\n<tr>\n<td>10.04</td>\n<td>2010.4.29</td>\n<td>2.6.32</td>\n<td>2009.12</td>\n</tr>\n<tr>\n<td>10.10</td>\n<td>2010.10.13</td>\n<td>2.6.35</td>\n<td>2010.08</td>\n</tr>\n<tr>\n<td>11.04</td>\n<td>2011.04.28</td>\n<td>2.6.38</td>\n<td>2011.03</td>\n</tr>\n<tr>\n<td>11.10</td>\n<td>2011.10.13</td>\n<td>3.0</td>\n<td>2011.08</td>\n</tr>\n<tr>\n<td>12.04</td>\n<td>2012.04.26(LTS)</td>\n<td>3.2+</td>\n<td>2012.01</td>\n</tr>\n<tr>\n<td>12.10</td>\n<td>2012.10.20</td>\n<td>3.5</td>\n<td>2012.08</td>\n</tr>\n<tr>\n<td>13.04</td>\n<td>2013.04.25</td>\n<td>3.8</td>\n<td>2013.02</td>\n</tr>\n<tr>\n<td>13.10</td>\n<td>2013.10.17</td>\n<td>3.11</td>\n<td>2013.09</td>\n</tr>\n<tr>\n<td>14.04</td>\n<td>2014.04.18 (LTS)</td>\n<td>3.13</td>\n<td>2014.01</td>\n</tr>\n<tr>\n<td>14.10</td>\n<td>2014.10.23</td>\n<td>3.16</td>\n<td>2014.08</td>\n</tr>\n<tr>\n<td>15.04</td>\n<td>2015.04</td>\n<td>3.19</td>\n<td>2015.03</td>\n</tr>\n<tr>\n<td>15.10</td>\n<td>2015.10</td>\n<td>4.2</td>\n<td>2015.08</td>\n</tr>\n<tr>\n<td>16.04</td>\n<td>2016.04（LTS）</td>\n<td>4.4</td>\n<td>2016.01</td>\n</tr>\n<tr>\n<td>16.10</td>\n<td>2016.10</td>\n<td>4.8</td>\n<td>2016.10</td>\n</tr>\n<tr>\n<td>17.04</td>\n<td>2017.04</td>\n<td>4.10</td>\n<td>2017.02</td>\n</tr>\n<tr>\n<td>17.10</td>\n<td>2017.10</td>\n<td>4.13</td>\n<td>2017.09</td>\n</tr>\n<tr>\n<td>18.04</td>\n<td>2018.04.26</td>\n<td>4.15</td>\n<td>2018.01</td>\n</tr>\n<tr>\n<td>18.10</td>\n<td>2018.10.18</td>\n<td>4.18</td>\n<td>2018.08</td>\n</tr>\n<tr>\n<td>19.04</td>\n<td>2019.04.18</td>\n<td>5.0</td>\n<td>2019.03</td>\n</tr>\n<tr>\n<td>19.10</td>\n<td>2019.10.17</td>\n<td>5.2</td>\n<td>2019.07</td>\n</tr>\n<tr>\n<td>20.04</td>\n<td>2020.04.23</td>\n<td>5.4</td>\n<td>2019.11</td>\n</tr>\n</tbody></table>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p>centos</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name grub.cfg #grub是引导操作系统的程序，它会根据自己的配置文件，去引导内核，当内核被加载到内存以后，内核会根据grub配置文件中的配置，找到根分区所使用的文件系统对应的驱动，通过根分区文件系统对应的驱动，挂载根分区，从而达到启动操作系统的目的。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-1-30 ~]# grub2-</span><br><span class=\"line\">grub2-bios-setup           grub2-macbless             grub2-mkrelpath            grub2-script-check</span><br><span class=\"line\">grub2-editenv              grub2-menulst2cfg          grub2-mkrescue             grub2-set-default</span><br><span class=\"line\">grub2-file                 grub2-mkconfig             grub2-mkstandalone         grub2-setpassword</span><br><span class=\"line\">grub2-fstest               grub2-mkfont               grub2-ofpathname           grub2-sparc64-setup</span><br><span class=\"line\">grub2-get-kernel-settings  grub2-mkimage              grub2-probe                grub2-syslinux2cfg</span><br><span class=\"line\">grub2-glue-efi             grub2-mklayout             grub2-reboot               </span><br><span class=\"line\">grub2-install              grub2-mknetdir             grub2-render-label         </span><br><span class=\"line\">grub2-kbdcomp              grub2-mkpasswd-pbkdf2      grub2-rpm-sort    </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> centos7 以上使用grub2 系列命令 centos7 以下是grub系列命令，用于grub设置</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -a  # 查看kernel版本</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h3><ol>\n<li><a href=\"https://blog.csdn.net/weixin_40161232/article/details/85251250\">https://blog.csdn.net/weixin_40161232/article/details/85251250</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_34194087/article/details/93497024\">https://blog.csdn.net/weixin_34194087/article/details/93497024</a></li>\n<li><a href=\"https://blog.csdn.net/zhaihaibo168/article/details/102673669\">https://blog.csdn.net/zhaihaibo168/article/details/102673669</a></li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"grub介绍及使用","slug":"systemstructure/linux/grub","date":"2022-01-01T12:13:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/grub.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20220221/grub.png","content":"<h2 id=\"多重操作系统引导管理器\"><a href=\"#多重操作系统引导管理器\" class=\"headerlink\" title=\"多重操作系统引导管理器\"></a>多重操作系统引导管理器</h2><h3 id=\"什么是多重引导\"><a href=\"#什么是多重引导\" class=\"headerlink\" title=\"什么是多重引导\"></a>什么是多重引导</h3><p>多重引导指一台计算机上安装多个操作系统,同时可以选择启动哪一个,例如常见的双系统也被叫做双引导</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>grub是GNU项目的启动引导程序，可以用于选择操作系统分区中的不同内核也可以向内核传递启动参数</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ol>\n<li><p>修改/etc/default/grub中的参数</p>\n</li>\n<li><p>1.当为legacyBIOS时</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class=\"line\"><span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>2.当为UEFIBIOS时</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grub2-mkconfig -o /boot/efi/EFI/操作系统名称/grub.cfg </span><br></pre></td></tr></table></figure></li>\n<li><p>重启机器</p>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"中断","slug":"systemstructure/linux/iterruptrequest","date":"2020-05-05T12:28:43.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/iterruptrequest.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139455kernel_interface.png","content":"<h2 id=\"中断是什么\"><a href=\"#中断是什么\" class=\"headerlink\" title=\"中断是什么\"></a>中断是什么</h2><p>中断是操作系统、CPU、CPU与IO设备中的概念，为中断CPU执行。其中涉及的概念都有无限深的概念栈(其实是无限深)我们就从简单的系统层面讲一讲。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139455kernel_interface.png\" alt=\"See the source image\"></p>\n<h2 id=\"前置概念\"><a href=\"#前置概念\" class=\"headerlink\" title=\"前置概念\"></a>前置概念</h2><p>IRQ：interrupt request,中断请求</p>\n<p>ISR：interrupt service routine， 中断服务程序，中断后运行的服务，ISR运行结束才会结束中断</p>\n<p>PIC：programmable interrupt contolle,可编程中断控制器（中断控制芯片），与I/O设备直连，可以触发CPU的INTR(中断请求)引脚，发起中断请求</p>\n<p>APIC：advanced programmable interrupt contolle,高级编程中断控制器，有两部分，Local APIC 在CPU内部(每个核都有)，I/O APIC在主板芯片组内，I/O APIC和LAPIC通过总线连接</p>\n<h2 id=\"硬中断\"><a href=\"#硬中断\" class=\"headerlink\" title=\"硬中断\"></a>硬中断</h2><p>硬件设备通知CPU就绪中使用，分为：</p>\n<h3 id=\"可屏蔽中断\"><a href=\"#可屏蔽中断\" class=\"headerlink\" title=\"可屏蔽中断\"></a>可屏蔽中断</h3><p>外设或借口的中断、可以在CPU处理其他紧急操作时忽略或屏蔽</p>\n<h3 id=\"不可屏蔽中断\"><a href=\"#不可屏蔽中断\" class=\"headerlink\" title=\"不可屏蔽中断\"></a>不可屏蔽中断</h3><p>电源断电、内存错误等，不可通过软件屏蔽，必须响应中断</p>\n<h2 id=\"软中断\"><a href=\"#软中断\" class=\"headerlink\" title=\"软中断\"></a>软中断</h2><p>软件触发的中断，如定时器、网卡收发包</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>一般为程序调用CPU的指令错误时产生，console能看到 segmention fault、core dumped等</p>\n<p>错误：系统可纠正、纠正成功继续运行(如内存页从磁盘加载)</p>\n<p>陷阱：陷阱主要用在调试中。</p>\n<p>终止：终止是由系统表中的硬件错误或值不一致而导致的。终止不会报告造成异常的指令的所在位置。这是最严重的中断，终止将会调用系统的终止异常处理程序来结束造成异常的进程。</p>\n<h2 id=\"top命令解析\"><a href=\"#top命令解析\" class=\"headerlink\" title=\"top命令解析\"></a>top命令解析</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 10:40:48 up  1:04,  1 user,  load average: 2.39, 2.22, 2.07</span><br><span class=\"line\">任务: 400 total,   2 running, 397 sleeping,   0 stopped,   1 zombie</span><br><span class=\"line\">%Cpu(s):  5.2 us,  3.4 sy,  0.0 ni, 90.5 id,  0.1 wa,  0.0 hi,  0.8 si,  0.0 st</span><br><span class=\"line\">MiB Mem :  15430.3 total,   3579.7 free,   8020.7 used,   3829.9 buff/cache</span><br><span class=\"line\">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   6880.5 avail Mem </span><br><span class=\"line\">ID USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND  </span><br><span class=\"line\">4389 longtao   20   0 6273452 451044 148220 S  37.7   2.9  27:28.46 gnome-shell           </span><br></pre></td></tr></table></figure>\n\n<p>第一行分别为：系统时间、系统已运行时间(1h4min)、用户数、平均CPU负载情况(1分钟、5分钟、15分钟)</p>\n<p>第二行分别为：当前总任务(进程)数量、运行中的2个、休眠397个、stoped0个，zombie0个</p>\n<p>第三为cpu的状态使用情况</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>5.2 us</td>\n<td>用户空间占用CPU%5.2</td>\n</tr>\n<tr>\n<td>3.4 sy</td>\n<td>内核空间占用CPU%3.4</td>\n</tr>\n<tr>\n<td>0.0 ni</td>\n<td>更改过优先级的进程占用CPU%0</td>\n</tr>\n<tr>\n<td>90.5 id</td>\n<td>90.5%的CPU空闲</td>\n</tr>\n<tr>\n<td>0.1 wa</td>\n<td>IO等待占用CPU百分比</td>\n</tr>\n<tr>\n<td>0.8 si</td>\n<td>软中断占用CPU%0.8</td>\n</tr>\n<tr>\n<td>0.0 hi</td>\n<td>硬中断占用</td>\n</tr>\n<tr>\n<td>0.0 st</td>\n<td>steal time,对云主机来说被Hypervisor偷去的CPU所占比例</td>\n</tr>\n</tbody></table>\n<p>第四行为内存状态分别为：物理总内存total、used使用了的、free空闲的、缓存内存</p>\n<p>第五行为swap交换分区状态：total交换分区总量、空闲、使用了的、缓冲的</p>\n<p>第六行往下都是每个进程使用情况：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>进程号</td>\n</tr>\n<tr>\n<td>USER</td>\n<td>用户</td>\n</tr>\n<tr>\n<td>PR</td>\n<td>进程优先级</td>\n</tr>\n<tr>\n<td>NI</td>\n<td>nice值，正表示低优先值、负表示高</td>\n</tr>\n<tr>\n<td>VIRT</td>\n<td>进程使用虚拟内存总量，VIRT=SWAP+RES</td>\n</tr>\n<tr>\n<td>RES</td>\n<td>进程使用的、未释放的物理内存，RES=CODE+DATA</td>\n</tr>\n<tr>\n<td>SHR</td>\n<td>共享内存</td>\n</tr>\n<tr>\n<td>S</td>\n<td>进程状态，D不可中断的睡眠状态 R运行 S睡眠 T跟踪/停止 Z僵尸进程</td>\n</tr>\n<tr>\n<td>%CPU</td>\n<td>CPU占比(对单个CPU的)</td>\n</tr>\n<tr>\n<td>%MEM</td>\n<td>物理内存占比</td>\n</tr>\n<tr>\n<td>TIME+</td>\n<td>进程使用的CPU时间总计，单位为us</td>\n</tr>\n<tr>\n<td>COMMAND</td>\n<td>进程名称和命令</td>\n</tr>\n</tbody></table>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>数字1：查看每个cpu的情况</p>\n<p>数字2：查看每个numa的情况</p>\n<p>数字3：查看某个numa里每个CPU的情况</p>\n<p>字母P：CPU使用排序</p>\n<p>字母M：内存使用排序</p>\n<p>字母m：改变内存和交换区显示</p>\n<p>字母b：高亮运行太进程</p>\n<p>字母f：编排显示</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"Linux瓶颈分析","slug":"systemstructure/linux/linuxperformanceanalysis","date":"2021-05-05T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/linuxperformanceanalysis.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139608R-C.d63f9367c74e1dca73ffbcae473118fa?rik=c734OLrGXr8BPg&riu=http%3a%2f%2fwww.brendangregg.com%2fPerf%2flinux_observability_tools.png&ehk=nHWnEkal2z%2bT0vbSwBOdhejyU03bFpVvmJxFTX6A9tA%3d&risl=&pid=ImgRaw&r=0","content":"<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p>性能优化一项最重要的步骤就是寻找到系统的瓶颈</p>\n<h5 id=\"粗略分析\"><a href=\"#粗略分析\" class=\"headerlink\" title=\"粗略分析\"></a>粗略分析</h5><p>系统响应慢，一般的瓶颈在IO、CPU、内存还有应用。</p>\n<p>使用top查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@172-20-59-60 apt_ui]# top</span><br><span class=\"line\">top - 15:59:31 up 6 days,  1:10,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">Tasks: 144 total,   1 running, 142 sleeping,   0 stopped,   1 zombie</span><br><span class=\"line\"><span class=\"meta\">%</span><span class=\"bash\">Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class=\"line\">KiB Mem :  8009636 total,  5126364 free,  2307032 used,   576240 buff/cache</span><br><span class=\"line\">KiB Swap:        0 total,        0 free,        0 used.  5396772 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\"> 9307 root      20   0  620968  28320   6064 S   0.0  0.4   3:39.37 python3</span><br><span class=\"line\">  861 root      20   0  567404  16752   5992 S   0.0  0.2   0:57.56 tuned</span><br><span class=\"line\">  651 root      20   0   21684   1324    988 S   0.0  0.0   0:47.08 irqbalance</span><br><span class=\"line\">  662 avahi     20   0   55952   2392   1920 S   0.0  0.0   0:35.02 avahi-daemon</span><br><span class=\"line\">  809 root      20   0  113440  12796    308 S   0.0  0.2   0:24.29 dhclient</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li> 输入M，进程列表按内存使用大小降序排序，便于我们观察最大内存使用者使用有问题</li>\n<li> 输入P，进程列表按CPU使用大小降序排序，便于我们观察最耗CPU资源</li>\n<li> 100.0 id 空闲CPU时间百分比，如果这个值过低，表明系统CPU存在瓶颈</li>\n<li> 0.0 wa 等待I/O的CPU时间百分比，如果这个值过高，表明IO存在瓶颈</li>\n</ol>\n<h5 id=\"内存瓶颈\"><a href=\"#内存瓶颈\" class=\"headerlink\" title=\"内存瓶颈\"></a>内存瓶颈</h5><p>一般使用free工具</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@172-20-59-60 apt_ui]# free</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:        8009636     2306408     5126984       25144      576244     5397396</span><br><span class=\"line\">Swap:             0           0           0</span><br></pre></td></tr></table></figure>\n\n<p>缺省时free的单位为KB</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>total</td>\n<td>总物理内存大小</td>\n</tr>\n<tr>\n<td>used</td>\n<td>已使用物理内存大小</td>\n</tr>\n<tr>\n<td>free</td>\n<td>未分配物理内存大小</td>\n</tr>\n<tr>\n<td>shared</td>\n<td>共享的物理内存大小</td>\n</tr>\n<tr>\n<td>buff/cache</td>\n<td>为了提高系统的读写速度（包含磁盘块的读写，文件的读写等），操作系统将部分内存作为缓存使用，该数值为缓存占用的物理内存大小</td>\n</tr>\n<tr>\n<td>available</td>\n<td>可用的物理内存大小</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>total</td>\n<td>Swap 分区的总大小</td>\n</tr>\n<tr>\n<td>used</td>\n<td>已使用的 Swap 分区大小</td>\n</tr>\n<tr>\n<td>free</td>\n<td>未使用的 Swap 分区大小</td>\n</tr>\n</tbody></table>\n<p>根据上表，在不考虑 Swap 分区的情况下，内存计算如下：<br>总内存大小：Mem.total = Mem.used + Mem.free + Mem.shared + Mem.buff/cache<br>理论上实际可用内存大小：Mem.actual = Mem.total - Mem.used - Mem.shared = Mem.free + Mem.buff/cache</p>\n<p>在考虑 Swap 分区的情况下，内存计算如下：<br>总内存大小：Mem.total = Mem.used + Mem.free + Mem.shared + Mem.buff/cache<br>理论上实际可用内存大小：Mem.actual = Mem.total - Mem.used - Mem.shared + Swap.free = Mem.free + Mem.buff/cache + Swap.free</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PageCache.size</td>\n<td>可以回收的 PageCache 大小，计算公式见上图</td>\n</tr>\n<tr>\n<td>SlabCache.size</td>\n<td>可以回收的 SlabCache 大小 ，计算公式见上图</td>\n</tr>\n<tr>\n<td>WaterMark.low</td>\n<td>支持系统使用的最低水位线，计算公式见上图</td>\n</tr>\n</tbody></table>\n<p>Mem.available = Mem.free + PageCache.size + SlabCache.size - WaterMark.low</p>\n<p>进一步的监视内存使用情况，可使用vmstat工具，可实时动态监视操作系统的内存和虚拟内存的动态变化使用情况</p>\n<p>vmstat [delay] [count] </p>\n<ul>\n<li>  delay是两次输出之间的延迟时间；</li>\n<li>  count是指按照这个时间间隔统计的次数。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@172-20-59-60 apt_ui]# vmstat 1 3</span><br><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 1  0      0 5126380   2068 574208    0    0     0    22    4    8  0  0 100  0  0</span><br><span class=\"line\"> 0  0      0 5126488   2068 574208    0    0     0     0  422   53  0  0 100  0  0</span><br><span class=\"line\"> 0  0      0 5126488   2068 574208    0    0     0     0  392   49  0  0 100  0  0</span><br></pre></td></tr></table></figure>\n\n<p>Procs（进程）:</p>\n<ul>\n<li>  r: 运行队列中进程数量</li>\n<li>  b: 等待IO的进程数量</li>\n</ul>\n<p>Memory（内存）:</p>\n<ul>\n<li>  swpd: 使用虚拟内存大小</li>\n<li>  free: 可用内存大小</li>\n<li>  buff: 用作缓冲的内存大小</li>\n<li>  cache: 用作缓存的内存大小</li>\n</ul>\n<p>Swap:</p>\n<ul>\n<li>  si: 每秒从交换区写到内存的大小</li>\n<li>  so: 每秒写入交换区的内存大小</li>\n</ul>\n<p>IO：（现在的Linux版本块的大小为1024bytes）</p>\n<ul>\n<li>  bi: 每秒读取的块数</li>\n<li>  bo: 每秒写入的块数</li>\n</ul>\n<p>system：</p>\n<ul>\n<li>  in: 每秒中断数，包括时钟中断</li>\n<li>  cs: 每秒上下文切换数</li>\n</ul>\n<p>CPU（以百分比表示）</p>\n<ul>\n<li>  us: 用户进程执行时间(user time)</li>\n<li>  sy: 系统进程执行时间(system time)</li>\n<li>  id: 空闲时间(包括IO等待时间)</li>\n<li>  wa: 等待IO时间</li>\n</ul>\n<p>内存测试工具我们使用Stream，基准测试，注意数据仅在相同软件相同版本有比较价值</p>\n<h5 id=\"IO瓶颈\"><a href=\"#IO瓶颈\" class=\"headerlink\" title=\"IO瓶颈\"></a>IO瓶颈</h5><p>如果IO存在性能瓶颈，top工具中的%wa会偏高</p>\n<p>可使用iostat 进一步分析</p>\n<p>iostat　[paras] [delay] [count] </p>\n<ul>\n<li>  -c显示CPU使用情况</li>\n<li>  -d 显示磁盘使用情况</li>\n<li>  -k 以 KB 为单位显示</li>\n<li>  -m 以 M 为单位显示</li>\n<li>  -N 显示磁盘阵列(LVM) 信息</li>\n<li>  -p[磁盘] 显示磁盘和分区的情况</li>\n<li>  -t 显示终端和CPU的信息</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-59-60 apt_ui]# iostat 3 3</span><br><span class=\"line\">Linux 3.10.0-693.el7.x86_64 (172-20-59-60)      12/31/2020      _x86_64_        (8 CPU)</span><br><span class=\"line\"></span><br><span class=\"line\">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class=\"line\">           0.03    0.00    0.02    0.02    0.00   99.93</span><br><span class=\"line\"></span><br><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.08         0.59         0.88     308042     462261</span><br><span class=\"line\">vdb               0.52         0.01       176.61       6256   92643328</span><br><span class=\"line\"></span><br><span class=\"line\">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class=\"line\">           0.04    0.00    0.00    0.00    0.00   99.96</span><br><span class=\"line\"></span><br><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.00         0.00         0.00          0          0</span><br><span class=\"line\">vdb               0.00         0.00         0.00          0          0</span><br><span class=\"line\"></span><br><span class=\"line\">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class=\"line\">           0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class=\"line\"></span><br><span class=\"line\">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class=\"line\">vda               0.00         0.00         0.00          0          0</span><br><span class=\"line\">vdb               0.00         0.00         0.00          0          0</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  %user：CPU处在用户模式下的时间百分比。</li>\n<li>  %nice：CPU处在带NICE值的用户模式下的时间百分比。</li>\n<li>  %system：CPU处在系统模式下的时间百分比。</li>\n<li>  %iowait：CPU等待输入输出完成时间的百分比。</li>\n<li>  %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li>\n<li>  %idle：CPU空闲时间百分比。</li>\n<li>  rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s</li>\n<li>  wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s</li>\n<li>  r/s: 每秒完成的读 I/O 设备次数。即 rio/s</li>\n<li>  w/s: 每秒完成的写 I/O 设备次数。即 wio/s</li>\n<li>  rsec/s: 每秒读扇区数。即 rsect/s</li>\n<li>  wsec/s: 每秒写扇区数。即 wsect/s</li>\n<li>  rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li>\n<li>  wkB/s: 每秒写K字节数。是 wsect/s 的一半。</li>\n<li>  avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。</li>\n<li>  avgqu-sz: 平均I/O队列长度。</li>\n<li>  await: 平均每次设备I/O操作的等待时间 (毫秒)。</li>\n<li>  svctm: 平均每次设备I/O操作的服务时间 (毫秒)。</li>\n<li>  %util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</li>\n</ul>\n<p>磁盘测试工具我们一般使用iperf3，注意数据仅在相同软件相同版本有比较价值</p>\n<h3 id=\"性能测试工具\"><a href=\"#性能测试工具\" class=\"headerlink\" title=\"性能测试工具\"></a>性能测试工具</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139608R-C.d63f9367c74e1dca73ffbcae473118fa?rik=c734OLrGXr8BPg&riu=http://www.brendangregg.com/Perf/linux_observability_tools.png&ehk=nHWnEkal2z+T0vbSwBOdhejyU03bFpVvmJxFTX6A9tA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"幽灵熔断","slug":"systemstructure/linux/meltdownspectre","date":"2020-08-25T14:24:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/meltdownspectre.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139657R-C.b99abc88fde8d7734d20066ed62d574f?rik=ikTwDJb6AKBbIg&riu=http%3a%2f%2fimg1.mydrivers.com%2fimg%2f20180326%2f7ad298a21c1e40f69f4eac81007e74a9.png&ehk=oGDeClWmtgCwNv4GlhChppBQcmJ1P2UGK34htcD2Ry0%3d&risl=&pid=ImgRaw&r=0","content":"<p>[toc]</p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>Meltdown/Spectre被发现于2018年, 是很有影响力的cpu漏洞。</p>\n<p>Meltdown（熔断）对应编号恶意数据缓存加载 CVE-2017-5754 。</p>\n<p>Spectre （幽灵）对应编号边界检查绕过 CVE-2017-5753 、分支目标注入 CVE-2017-5715 。</p>\n<p>Meltdown 影响几乎所有的 Intel CPU（从1995年起）以及部分 ARM CPU。 Spectre 拥有更广的影响范围，在 Meltdown 的情况下，恶意程序可读取某些自身无权限访问的数据。利用此漏洞低权限用户可以访问到本身无权限访问的内容，例如用户密码、加密密钥。</p>\n<p>Spectre 恶意利用程序，可导致用户的帐号、密码泄漏。在公共云服务器上，可能打破界限，从一台虚拟机器获取到另一个用户的权限。</p>\n<h3 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h3><p>指令周期：CPU取出一条指令并执行该指令所需的时间称为指令周期，指令周期的长短与指令的复杂程度有关，一般多个CPU周期组成指令周期。</p>\n<p>CPU周期：又称机器周期，通常用从主存读取一条指令的最短时间来规定CPU周期，一般多个时钟周期组成CPU周期</p>\n<p>时钟周期：时钟周期是处理操作的最基本时间单位，由机器的主频决定（超到20GHZ，全人类感谢你）</p>\n<h3 id=\"CPU的执行\"><a href=\"#CPU的执行\" class=\"headerlink\" title=\"CPU的执行\"></a>CPU的执行</h3><h4 id=\"基本过程\"><a href=\"#基本过程\" class=\"headerlink\" title=\"基本过程\"></a>基本过程</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211027/16353092843-4-257058.jpg\" alt=\"img\"></p>\n<p>cpu一般按照 取指令–&gt;指令译码—&gt;指令执行–&gt;存储访问–&gt;写回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">取指令 --&gt; 指令译码;</span><br><span class=\"line\">指令译码--&gt;指令执行;</span><br><span class=\"line\">指令执行--&gt;存储访问;</span><br><span class=\"line\">存储访问--&gt;写回;</span><br></pre></td></tr></table></figure>\n\n<p> 取指令:Instruction Fetch,从存储器取指令到CPU</p>\n<p>指令译码:Instruction Decode，对取回的指令进行拆分和解释，识别和区分出不同的指令类别及各种获取操作数的方法</p>\n<p>指令执行:Instruction Execute，使用硬件功能单元执行指令，最常见功能单元为算术逻辑部件运算器（Arithmetic Logical Unit，ALU）</p>\n<p>存储访问:Memory Access，根据指令需要，有可能要访问主存，读取操作数，具体见下表</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>算法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>隐含寻址</td>\n<td>默认操作数地址</td>\n<td>不访存</td>\n<td>数据范围受限</td>\n</tr>\n<tr>\n<td>立即寻址</td>\n<td>D = A</td>\n<td>不访存</td>\n<td>操作数值范围受限</td>\n</tr>\n<tr>\n<td>直接寻址</td>\n<td>EA = A</td>\n<td>简单</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>间接寻址</td>\n<td>EA = (A)</td>\n<td>地址范围大</td>\n<td>多次访存</td>\n</tr>\n<tr>\n<td>寄存器寻址</td>\n<td>EA = R</td>\n<td>不访存</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>寄存器间接寻址</td>\n<td>EA = ®</td>\n<td>地址范围大</td>\n<td>访存</td>\n</tr>\n<tr>\n<td>偏移寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>段寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>堆栈寻址</td>\n<td>EA = SP</td>\n<td>不访存</td>\n<td>应用受限</td>\n</tr>\n</tbody></table>\n<p>写回:把执行指令阶段的运行结果数据“写回”到某种存储形式，经常是写到cpu内部寄存器以便下次快速使用</p>\n<h4 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h4><p>若处理器无流水线结构，一条指令执行一般需要五个处理器周期；流水线使用锁存器（latch，用来缓存电信号）让不同指令的各步操作重叠，从而实现多条指令在不同周期并行处理，只执行一条指令的话，流水线不会提高效率。</p>\n<h4 id=\"分支预测\"><a href=\"#分支预测\" class=\"headerlink\" title=\"分支预测\"></a>分支预测</h4><p>流水线架构对顺序执行的命令，性能提升明显，但遇到命令跳转（goto系列等）就会性能降低，那么就出现了分支预测期，提前把预测到的指令存入流水线，分支跳转指令完成后如果预测正确，流水线正常运行，若错误，清空流水线然后执行正确的指令</p>\n<h4 id=\"乱序执行\"><a href=\"#乱序执行\" class=\"headerlink\" title=\"乱序执行\"></a>乱序执行</h4><p>打乱程序原本的执行顺序（类似上层使用异步，编译器也会乱序执行）</p>\n<p>cpu的乱序执行一般都使用Tomasulo算法，包括</p>\n<ul>\n<li>Common Data Bus (CDB).</li>\n<li>Unified Reservation Station (Scheduler).</li>\n<li>Register Renaming (Reorder Buffer).</li>\n</ul>\n<p>该算法虽然是乱序执行, 但是会顺序完成 (retire), 只有在retire后它的输出才会architectually visible (简单地说, 不影响程序逻辑), 但是没有architectually visible不等于没有影响, 当输出更新到reservation station后, 因为cdb的存在, 其他指令已经可以读到. 另外, 非常重要的一点, 异常只有在指令retire的时候才会触发, 对于上面的例子, 即使cpu已经检查到第一条指令没有访问权限, 也只能等到该指令retire时才会触发, 取决于该指令在ROB的位置, 可能马上触发也可能很久之后, ROB容量可以很容易做到比如192这个级别.</p>\n<h3 id=\"熔断漏洞（利用乱序执行）\"><a href=\"#熔断漏洞（利用乱序执行）\" class=\"headerlink\" title=\"熔断漏洞（利用乱序执行）\"></a>熔断漏洞（利用乱序执行）</h3><p>cpu在执行A语句的同时将B语句中的内存位置的信息加载到cache中，这个加载的过程忽略了权限的判断之后再执行B、C语句，在执行B语句时发现并没有权限，所以放弃乱序执行的结果，回滚到最初的状态依次执行。此时cache中的信息没有还原。之后通过边信道攻击来测试数据，发现对于某一个数据的访问要远远快于其他数据的访问，那么就可推断数据在cache中，并且可以反推回它的内存地址。</p>\n<h3 id=\"幽灵漏洞（利用分支预测）\"><a href=\"#幽灵漏洞（利用分支预测）\" class=\"headerlink\" title=\"幽灵漏洞（利用分支预测）\"></a>幽灵漏洞（利用分支预测）</h3><p>和熔断差不多，比如if else 中，提前预测某一条，预测错误，状态回滚，边信道攻击，反推内存地址</p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>打补丁，关闭乱序执行、分支预测，不过个人电脑建议别关，关了会影响性能。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"内存超分原理","slug":"systemstructure/linux/memoryoverscore","date":"2020-07-25T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/memoryoverscore.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139713OIP-C.xGR2ur4Cwbjx7OEW-pjD9gHaDa?pid=ImgDet&rs=1","content":"<p>KVM中内存也是允许过载使用（over-commit）的，KVM能够让分配给客户机的内存总数大于实际可用的物理内存总数。由于客户机操作系统及其上的应用程序并非一直100%地利用其分配到的内存，而且宿主机上的多个客户机一般也不会同时达到100%的内存使用率，所以内存过载分配是可行的。一般来说，有如下三种方式来实现内存的过载使用。</p>\n<ol>\n<li>内存交换（swapping）：用交换空间（swap space）来弥补内存的不足。</li>\n<li>气球（ballooning）：通过virio_balloon驱动来实现宿主机Hypervisor和客户机之间的协作来完成。</li>\n<li>页共享（page sharing）：通过KSM（Kernel Samepage Merging）合并多个客户机进程使用的相同内存页。</li>\n</ol>\n<p>其中，第一种内存交换的方式是最成熟的（Linux中很早就开始应用），也是目前被广泛使用的，不过，它相比于KSM和ballooning的方式效率较为低一些。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"proc目录解析","slug":"systemstructure/linux/proc","date":"2020-05-23T13:23:23.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/proc.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351398132021100110022315.jpg","content":"<p>在linux中，proc是一个伪文件系统，提供了访问内核数据的一些方法</p>\n<p>proc中PID目录存有进程的一些信息</p>\n<h2 id=\"pid目录ls\"><a href=\"#pid目录ls\" class=\"headerlink\" title=\"pid目录ls\"></a>pid目录ls</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">root@longtaoXiaoXinPro13-2020#</span><span class=\"bash\"> ls /proc/1</span></span><br><span class=\"line\">arch_status         cwd        mem            patch_state   stat</span><br><span class=\"line\">attr                environ    mountinfo      personality   statm</span><br><span class=\"line\">autogroup           exe        mounts         projid_map    status</span><br><span class=\"line\">auxv                fd         mountstats     root          syscall</span><br><span class=\"line\">cgroup              fdinfo     net            sched         task</span><br><span class=\"line\">clear_refs          gid_map    ns             schedstat     timens_offsets</span><br><span class=\"line\">cmdline             io         numa_maps      sessionid     timers</span><br><span class=\"line\">comm                limits     oom_adj        setgroups     timerslack_ns</span><br><span class=\"line\">coredump_filter     loginuid   oom_score      smaps         uid_map</span><br><span class=\"line\">cpu_resctrl_groups  map_files  oom_score_adj  smaps_rollup  wchan</span><br><span class=\"line\">cpuset              maps       pagemap        stack</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"attr\"><a href=\"#attr\" class=\"headerlink\" title=\"attr\"></a>attr</h4><p>目录， 可读可写，安全相关的一些属性，用来支持安全模块，如SELinux等</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ls /proc/1/attr</span></span><br><span class=\"line\"><span class=\"meta\">apparmor#</span></span><br><span class=\"line\"><span class=\"bash\">current<span class=\"comment\">#当前安全属性</span></span></span><br><span class=\"line\"><span class=\"meta\">exec#</span><span class=\"bash\">执行execve时设置的安全属性</span></span><br><span class=\"line\"><span class=\"meta\">keycreate#</span><span class=\"bash\"> add_key时设置属性</span>  </span><br><span class=\"line\"><span class=\"meta\">smack#</span></span><br><span class=\"line\"><span class=\"bash\">context<span class=\"comment\">#</span></span>   </span><br><span class=\"line\"><span class=\"meta\">display#</span><span class=\"bash\"> </span></span><br><span class=\"line\"><span class=\"meta\">fscreate#</span><span class=\"bash\"> </span> </span><br><span class=\"line\"><span class=\"meta\">prev#</span><span class=\"bash\"> </span> </span><br><span class=\"line\"><span class=\"meta\">sockcreate#</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4>","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"shc与upx加密混淆压缩","slug":"systemstructure/linux/shcandupx","date":"2021-04-25T15:27:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/shcandupx.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635140046OIP-C.6nySy7QLC94Nm0SNCoL5UwHaGE?pid=ImgDet&rs=1","content":"<p>[toc]</p>\n<h2 id=\"shc混淆\"><a href=\"#shc混淆\" class=\"headerlink\" title=\"shc混淆\"></a>shc混淆</h2><h3 id=\"shc安装\"><a href=\"#shc安装\" class=\"headerlink\" title=\"shc安装\"></a>shc安装</h3><p>从官网下载<a href=\"http://www.datsi.fi.upm.es/~frosal/sources/\">http://www.datsi.fi.upm.es/~frosal/sources/</a> (最新2015年的shc-3.8.9b.tgz)，或者源码下载<a href=\"https://github.com/neurobin/shc\">https://github.com/neurobin/shc</a> (有最新的)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://www.datsi.fi.upm.es/~frosal/sources/shc-3.8.9b.tgz</span><br><span class=\"line\">tar zxvf shc-3.8.9b.tgz</span><br><span class=\"line\">cd shc-3.8.9b</span><br><span class=\"line\">make clean</span><br><span class=\"line\">make test # 等待paused 然后回车</span><br><span class=\"line\">make strings&amp;install # 等待继续输入yes</span><br></pre></td></tr></table></figure>\n\n<p>shc命令说明</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-e %s  Expiration date in dd/mm/yyyy format [none]</span><br><span class=\"line\">-m %s  Message to display upon expiration [&quot;Please contact your provider&quot;]</span><br><span class=\"line\">-f %s  File name of the script to compile</span><br><span class=\"line\">-i %s  Inline option for the shell interpreter i.e: -e</span><br><span class=\"line\">-x %s  eXec command, as a printf format i.e: exec(&#x27;%s&#x27;,@ARGV);</span><br><span class=\"line\">-l %s  Last shell option i.e: --</span><br><span class=\"line\">-r     Relax security. Make a redistributable binary</span><br><span class=\"line\">-v     Verbose compilation</span><br><span class=\"line\">-D     Switch ON debug exec calls [OFF]</span><br><span class=\"line\">-T     Allow binary to be traceable [no]</span><br><span class=\"line\">-C     Display license and exit</span><br><span class=\"line\">-A     Display abstract and exit</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用shc给hello-world脚本加密\"><a href=\"#使用shc给hello-world脚本加密\" class=\"headerlink\" title=\"使用shc给hello world脚本加密\"></a>使用shc给hello world脚本加密</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 我们先创建一个sh</span></span><br><span class=\"line\">[root@localhost ~]# echo &#x27;#!/bin/bash&#x27; &gt; hello.sh;echo &quot;echo hello world&quot; &gt;&gt; hello.sh</span><br><span class=\"line\">[root@localhost ~]# chmod +x hello.sh;./hello.sh</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@localhost ~]# shc -f hello.sh</span><br><span class=\"line\">[root@localhost ~]# ./hello.sh.x</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<p>我们使用readelf查看发现是elf文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# readelf -h hello.sh.x </span><br><span class=\"line\">ELF 头：</span><br><span class=\"line\">  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class=\"line\">  Class:                             ELF64</span><br><span class=\"line\">  Data:                              2&#x27;s complement, little endian</span><br><span class=\"line\">  Version:                           1 (current)</span><br><span class=\"line\">  OS/ABI:                            UNIX - System V</span><br><span class=\"line\">  ABI Version:                       0</span><br><span class=\"line\">  Type:                              EXEC (可执行文件)</span><br><span class=\"line\">  Machine:                           Advanced Micro Devices X86-64</span><br><span class=\"line\">  Version:                           0x1</span><br><span class=\"line\">  入口点地址：              0x400d00</span><br><span class=\"line\">  程序头起点：              64 (bytes into file)</span><br><span class=\"line\">  Start of section headers:          9376 (bytes into file)</span><br><span class=\"line\">  标志：             0x0</span><br><span class=\"line\">  本头的大小：       64 (字节)</span><br><span class=\"line\">  程序头大小：       56 (字节)</span><br><span class=\"line\">  Number of program headers:         9</span><br><span class=\"line\">  节头大小：         64 (字节)</span><br><span class=\"line\">  节头数量：         28</span><br><span class=\"line\">  字符串表索引节头： 27</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"shc简单的原理介绍\"><a href=\"#shc简单的原理介绍\" class=\"headerlink\" title=\"shc简单的原理介绍\"></a>shc简单的原理介绍</h3><p>我们在使用<code>shc -f hello.sh</code>时会发现还生成了一个hello.sh.x.c的文件，阅读c我们知道shc是将脚本用rc4进行加密，然后将加密后的脚本、密钥、解密程序再用c编译成elf文件，在执行elf时再将加密的脚本解密运行。  看了shc的混淆方式，我们也可以用其他编译行语言(例如go、rust、c++)等自己实现，更换加解密算法，甚至不用加解密算法。</p>\n<h3 id=\"从shc-可执行文件获取源码-逆向\"><a href=\"#从shc-可执行文件获取源码-逆向\" class=\"headerlink\" title=\"从shc 可执行文件获取源码(逆向)\"></a>从shc 可执行文件获取源码(逆向)</h3><ol>\n<li>使用IDA等反编译工具动态调试，找解密后的函数</li>\n<li>使用coredump 从内存读取。</li>\n<li>使用一些现有的工具，例如<a href=\"https://github.com/yanncam/UnSHc%EF%BC%8C%E6%96%B0%E7%9A%84shc%E5%8A%A0%E5%85%A5%E4%BA%86linux%E5%86%85%E6%A0%B8%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%A5%BD%E5%83%8F%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86\">https://github.com/yanncam/UnSHc，新的shc加入了linux内核本身的安全机制，好像不能用了</a></li>\n</ol>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><ol>\n<li>使用gzexe混淆</li>\n<li> shc -e 过期时间挺好用的</li>\n</ol>\n<h2 id=\"使用upx加壳\"><a href=\"#使用upx加壳\" class=\"headerlink\" title=\"使用upx加壳\"></a>使用upx加壳</h2><h3 id=\"upx安装\"><a href=\"#upx安装\" class=\"headerlink\" title=\"upx安装\"></a>upx安装</h3><p>从<a href=\"https://github.com/upx/upx\">https://github.com/upx/upx</a> 下载源码安装或其他包管理器安装</p>\n<h3 id=\"upx-演示\"><a href=\"#upx-演示\" class=\"headerlink\" title=\"upx 演示\"></a>upx 演示</h3><p>在我们刚刚使用shc对helloworld脚本编译生成elf后，我们可以使用upx对此elf进行加壳压缩，也算是一种混淆方式</p>\n<p>upx压缩前 11k</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# ls -lh ./hello.sh.x</span><br><span class=\"line\">-rwx--x--x. 1 root root 11K 7月  23 10:19 ./hello.sh.x</span><br></pre></td></tr></table></figure>\n\n<p>upx 压缩后 6.9k, -9代表压缩等级（1-9,9个等级）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# upx -9 ./hello.sh.x;ls -lh ./hello.sh.x</span><br><span class=\"line\">                       Ultimate Packer for eXecutables</span><br><span class=\"line\">                          Copyright (C) 1996 - 2013</span><br><span class=\"line\">UPX 3.91        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Sep 30th 2013</span><br><span class=\"line\"></span><br><span class=\"line\">        File size         Ratio      Format      Name</span><br><span class=\"line\">   --------------------   ------   -----------   -----------</span><br><span class=\"line\">     11168 -&gt;      7004   62.71%  linux/ElfAMD   hello.sh.x                    </span><br><span class=\"line\"></span><br><span class=\"line\">Packed 1 file.</span><br><span class=\"line\">-rwx--x--x. 1 root root 6.9K 7月  23 10:19 ./hello.sh.x</span><br></pre></td></tr></table></figure>\n\n<p>我们压缩后的helloworld依然正常运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@172-20-65-67 ~]# ./hello.sh.x </span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"upx原理\"><a href=\"#upx原理\" class=\"headerlink\" title=\"upx原理\"></a>upx原理</h3><p>对elf文件进行压缩并插入解压代码，在运行时（加载到内存时）解压代码</p>\n<h3 id=\"脱壳工具\"><a href=\"#脱壳工具\" class=\"headerlink\" title=\"脱壳工具\"></a>脱壳工具</h3><p>略</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"VirtioSCSI和virtioBLK","slug":"systemstructure/linux/virtioscsiandvirtioblk","date":"2020-05-22T13:10:51.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/virtioscsiandvirtioblk.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635140092virtio-gpio-1.png","content":"<p><strong>qemu对设备的模拟可以分成两类：全模拟和半模拟。全模拟即完全模拟物理设备的工作过程，使得运行在虚拟机上的软件完全感知不到自身运行环境的差异</strong>。例如qemu中实现了对IDE磁盘、LSI控制器(其上可接SCSI磁盘)等物理存储设备的模拟，原先运行在物理机上的IDE驱动、LSI驱动或应用程序不做任何改动即可运行在虚拟机中。因此，<strong>全模拟的优点比较明显，即不用提供专门针对虚拟化场景的设备驱动，完全可以复用物理环境下的驱动程序。那么全模拟有何缺点呢？全模拟时，虚拟机内部驱动会频繁访问虚拟机IO端口，KVM平台下会导致大量的陷入和陷出操作；另外虚拟机内外数据传输时只能通过以字节为单位的拷贝方式进行，无法直接采用共享内存的方式，因此存在较大的访问性能问题</strong>。</p>\n<p>为解决全虚拟化在性能上的问题，半模拟技术应运而生。它构造了一种虚拟化环境所独有的存储设备，因此<strong>半虚拟化需要在虚拟机内部安装特定的驱动程序才能正常驱使该设备进行工作。通常我们称**虚拟机内部的驱动为前端驱动**，称**负责实现其功能模拟的程序(KVM平台下即为qemu程序)为后端程序*<strong>*，**半模拟技术也常常被叫做前后端技术</strong>。**采用半摸拟技术后，配合前端驱动，虚拟化设备完全可以采用全新的事件通知和数据传递机制进而大幅提升性能， 例如在virtio-blk磁盘中，采用io_event_fd进行前端到后端通知，采用中断注入方式实现后端到前端的通知，并通过IO环(vring)进行数据的共享</strong>。至此，主要说明了virtio-blk产生的背景及其价值。附上qemu所模拟的PC(基于intel i440fx主板架构)的组成结构图，以作为后续深入分析的基础。</p>\n<p>virtio-scsi和virtio-blk都是磁盘的半虚拟化驱动，virtio-scsi解决了virtio-blk的一些限制。</p>\n<p>virtio scsi hba取代virtio blk，这是一种简单的高性能准虚拟化存储设备。然而，<strong>virtio blk的设计固有的局限性如下</strong>：</p>\n<ul>\n<li>•virtio blk的范围有限，这使得新的命令实现变得复杂。每次开发一个新命令时，virtio blk驱动程序都必须在每个客户机中更新。</li>\n<li>•<strong>virtio blk将PCI功能和存储设备映射为1:1，限制了可扩展性</strong>。</li>\n<li>•<strong>virtio blk不是真正的SCSI设备。这会导致一些应用程序在从物理机移动到虚拟机时中断。</strong></li>\n</ul>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]},{"title":"中间人攻击与HTTPS","slug":"systemstructure/network/maninthemiddleattackandhttps","date":"2021-04-15T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/maninthemiddleattackandhttps.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635168198HTTP-vs-HTTPS.png","content":"<p>[toc]</p>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>HTTP(hypertext transfer protocol )协议是一种七层协议，是万维网通信的基石，通常使用tcp协议(HTTP3使用quic(udp))，默认端口80</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>GET、HEAD：获取资源</p>\n<p>POST：上传资源</p>\n<p>PUT：修改资源</p>\n<p>DELETE：删除资源</p>\n<p>TRACE：回显请求</p>\n<p>OPTIONS：回复资源所有可用方法</p>\n<p>CONNECT：留给SSL加密使用</p>\n<h3 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h3><p>在函数式编程中，幂等函数是对任何值x具有f（f（x））= f（x）属性的函数，在编程领域，则意为同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的</p>\n<p>GET、HEAD、PUT、DELETE、OPTIONS、TRACE都是幂等的，而GET、HEAD、OPTIONS、TRACE一般来说没有副作用。</p>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><ul>\n<li>1xx消息：请求已被服务器接收，继续处理</li>\n<li>2xx成功：请求成功</li>\n<li>3xx重定向：重定向</li>\n<li>4xx请求错误：客户端错误</li>\n<li>5xx服务器错误：服务器错误</li>\n</ul>\n<h3 id=\"HTTP-keeep-alive\"><a href=\"#HTTP-keeep-alive\" class=\"headerlink\" title=\"HTTP keeep-alive\"></a>HTTP keeep-alive</h3><p>HTTP1.1加入</p>\n<p>优点：同时打开的TCP链接少了、降低延时</p>\n<p>缺点：请求后保持链接，可能会影响性能</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>HTTPS(hypertext transfer protocol secure)是使用HTTP通信，使用SSL/TLS加密数据包，默认端口443</p>\n<h3 id=\"传输过程\"><a href=\"#传输过程\" class=\"headerlink\" title=\"传输过程\"></a>传输过程</h3><p>证书验证阶段：</p>\n<ol>\n<li>浏览器发起HTTPS请求</li>\n<li>服务端返回HTTPS证书和SSL非对称加密公钥</li>\n<li>浏览器，验证HTTPS证书合法性，合法就生成随机数</li>\n</ol>\n<p>传输阶段：</p>\n<ol>\n<li>浏览器通过SSL公钥加密随机数，传输到服务端</li>\n<li>服务端通过SSL私钥解密，通过随机数构造对称加密(TLS)，通过TLS传输</li>\n</ol>\n<h4 id=\"如何验证证书合法性\"><a href=\"#如何验证证书合法性\" class=\"headerlink\" title=\"如何验证证书合法性\"></a>如何验证证书合法性</h4><p>证书包含：公钥、持有者信息、证书机构信息(CA)、数字签名和算法、有效期等</p>\n<p>证书签发：</p>\n<ol>\n<li>CA把各种信息打包通过计算得到hash值</li>\n<li>CA使用私钥对hash值加密生成证书签名</li>\n<li>将证书签名加到文件证书上，形成数字证书</li>\n</ol>\n<p>证书校验：</p>\n<ol>\n<li>浏览器通过同样hash算法得到hash值</li>\n<li>浏览器用公钥对CA数字签名解密与自己算的hash值比较，若相同就是可信的</li>\n</ol>\n<p>证书信任链：通过当前证书-中间证书-根证书逐级担保信任</p>\n<h2 id=\"中间人攻击\"><a href=\"#中间人攻击\" class=\"headerlink\" title=\"中间人攻击\"></a>中间人攻击</h2><p>A与C进行通信时，需要经过B进行传输，B获取了A和C的通话信息，B分别伪装成A和C通信，伪装成C和A通信</p>\n<h3 id=\"非对称加密场景\"><a href=\"#非对称加密场景\" class=\"headerlink\" title=\"非对称加密场景\"></a>非对称加密场景</h3><p>A发送公钥给C时，B作为中间人攻击，B也生成公私钥，B将自己的公钥发给C和C通信，B通过A发送的公钥和A通信</p>\n<h3 id=\"HTTPS中的中间人攻击\"><a href=\"#HTTPS中的中间人攻击\" class=\"headerlink\" title=\"HTTPS中的中间人攻击\"></a>HTTPS中的中间人攻击</h3><p>在缺少证书验证环节时，可以进行HTTPS中间人攻击，具体流程如下</p>\n<ol>\n<li>A与C进行通信时，本地请求劫持，B成为中间人</li>\n<li>B返回自己伪造的证书给A，B与C通信</li>\n<li>A不会验证证书，直接创建随机数，与B进行通信</li>\n<li>B与C按照正常流程进行通信</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"网卡驱动","slug":"systemstructure/network/nicdriver","date":"2020-07-19T12:30:22.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/nicdriver.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171258170855_4Tcf_3260790.png","content":"<p>驱动程序（Device Driver）全称为“设备驱动程序”，是一种可以使计算机中央处理器——CPU控制和使用设备的特殊程序，相当于硬件的接口，操作系统通过这个接口，控制硬件设备的工作。</p>\n<p>网卡设备与字符设备和块设备不同， 网络设备并不对应于/dev目录下的文件,不过会存放在/sys/class/net目录下</p>\n<p>Linux系统对网络设备驱动定义了4个层次， 这4个层次到下分为:</p>\n<p>网络协议接口层:</p>\n<p>实现统一的数据包收发的协议,该层主要负责调用dev_queue_xmit()函数发送数据， netif_rx()函数接收数据</p>\n<p>网络设备接口层:</p>\n<p>通过net_device结构体来描述一个具体的网络设备的信息,实现不同的硬件的统一</p>\n<p>设备驱动功能层：</p>\n<p>用来负责驱动网络设备硬件来完成各个功能, 它通过hard_start_xmit() 函数启动发送操作， 并通过网络设备上的中断触发接收操作,</p>\n<p>网络设备与媒介层：</p>\n<p>用来负责完成数据包发送和接收的物理实体, 设备驱动功能层的函数都在这物理上驱动的</p>\n<p><strong>层次结构如下图所示:</strong></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351712071182576-20171031190853498-1599050801.png\" alt=\"img\"></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171258170855_4Tcf_3260790.png\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"udp offload","slug":"systemstructure/network/offload","date":"2021-03-25T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/offload.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171342R-C.3fd39d32acf22e924676ae13410bc7f8?rik=CpqSRGJGylO%2fBw&riu=http%3a%2f%2fwiki.networksecuritytoolkit.org%2fimages%2fthumb%2fNo_segmentation_offloading.png%2f964px-No_segmentation_offloading.png&ehk=pAE0DfOX5Ii0DGj2zezPKbufNwQEX0uE62lUjaW09OA%3d&risl=&pid=ImgRaw&r=0","content":"<h2 id=\"tx-udp-tnl-segmentation\"><a href=\"#tx-udp-tnl-segmentation\" class=\"headerlink\" title=\"tx-udp_tnl-segmentation\"></a><strong>tx-udp_tnl-segmentation</strong></h2><p>Overlay网络，例如VxLAN，现在应用的越来越多。Overlay网络可以使得用户不受物理网络的限制，进而创建，配置并管理所需要的虚拟网络连接。同时Overlay可以让多个租户共用一个物理网络，提高网络的利用率。Overlay网络有很多种，但是最具有代表性的是VxLAN。VxLAN是一个MAC in UDP的设计，具体格式如下所示。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455587v2-f6d9dcd0ad97394b4c4585ee161245f0_1440w.jpg\" alt=\"img\"></p>\n<p>从VxLAN的格式可以看出，以VxLAN为代表的Overlay网络在性能上存在两个问题。一个是Overhead的增加，VxLAN在原始的Ethernet Frame上再包了一层Ethernet+IP+UDP+VXLAN，这样每个Ethernet Frame比原来要多传输50个字节。所以可以预见的是，Overlay网络的效率必然要低于Underlay网络。另一个问题比传50个字节更为严重，那就是需要处理这额外的50个字节。这50个字节包括了4个Header，每个Header都涉及到拷贝，计算，都需要消耗CPU。而我们现在迫切的问题在于CPU可以用来处理每个网络数据包的时间更少了。</p>\n<p>首先，VxLAN的这50个字节是没法避免的。其次，那就只能降低它的影响。这里仍然可以采用Jumbo Frames的思想，因为50个字节是固定的，那网络数据包越大，50字节带来的影响就相对越小。</p>\n<p>先来看一下虚拟机的网络连接图。虚拟机通过QEMU连接到位于宿主机的TAP设备，之后再通过虚机交换机转到VTEP（VxLAN Tunnel EndPoint），封装VxLAN格式，发给宿主机网卡。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455592v2-a4653d5451d3cf9737399d07be171d6e_1440w.jpg\" alt=\"img\"></p>\n<p>理想情况就是，一大段VxLAN数据直接传给网卡，由网卡去完成剩下的分片，分段，并对分成的小的网络包分别封装VxLAN，计算校验和等工作。这样VxLAN对虚机网络带来影响就可以降到最低。实际中，这是可能的，但是需要一系列的前提条件。</p>\n<p>首先，虚拟机要把大的网络包发到宿主机。因为虚拟机里面也运行了一个操作系统，也有自己的TCP/IP协议栈，所以虚拟机完全有能力自己就把大的网络包分成多个小的网络包。从前面介绍的内容看，只有TSO才能真正将一个大的网络包发到网卡。GSO在发到网卡的时候，已经在进入驱动的前一刻将大的网络包分成了若干个小的网络数据包。所以这里要求：虚机的网卡支持TSO（Virtio默认支持），并且打开TSO（默认打开），同时虚机发出的是TCP数据。</p>\n<p>之后，经过QEMU，虚拟交换机的转发，VTEP的封装，这个大的TCP数据被封装成了VxLAN格式。50个字节的VxLAN数据被加到了这个大的TCP数据上。接下来问题来了，这本来是个TCP数据，但是因为做了VxLAN的封装，现在看起来像是个UDP的数据。如果操作系统不做任何处理，按照前面的介绍，那就应该走GSO做IP Fragmentation，并在发送给网卡的前一刻分成多个小包。这样，如果网卡本来支持TSO现在就用不上了。并且更加严重的是，现在还没做TCP Segmentation。我们在上一篇花了很大的篇幅介绍其必要性的TCP Segmentation在这里也丢失了。</p>\n<p>对于现代的网卡，除了TSO，GSO等offload选项外，还多了一个选项tx-udp_tnl-segmentation。如果这个选项打开，操作系统自己会识别封装成VxLAN的UDP数据是一个tunnel数据，并且操作系统会直接把这一大段VxLAN数据丢给网卡去处理。在网卡里面，网卡会针对内层的TCP数据，完成TCP Segmentation。之后再为每个TCP Segment加上VxLAN封装（50字节），如下图右所示。这样，VxLAN封装对于虚拟机网络来说，影响降到了最低。</p>\n<p>从前面描述看，要达成上述的效果，需要宿主机网卡同时支持TSO和tx-udp_tnl-segmentation。如果这两者任意一个不支持或者都不支持。那么系统内核会调用GSO，将封装成VxLAN格式的大段TCP数据，在发给网卡驱动前完成TCP Segmentation，并且为每个TCP Segment加上VxLAN封装。如下图左所示。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211017/1634455599v2-539c4c2923a10f9c331325ef604b1864_1440w.jpg\" alt=\"img\"></p>\n<p>如果关闭虚拟机内的TSO，或者虚拟机内发送的是UDP数据。那么在虚拟机的TCP/IP协议栈会调用GSO，发给虚拟机网卡驱动的前一刻，完成了分段、分片。虚拟机最终发到QEMU的网络数据包就是多个小的网络数据包。这个时候，无论宿主机怎么配置，都需要处理多个小的网络包，并对他们做VxLAN封装。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171342R-C.3fd39d32acf22e924676ae13410bc7f8?rik=CpqSRGJGylO/Bw&riu=http://wiki.networksecuritytoolkit.org/images/thumb/No_segmentation_offloading.png/964px-No_segmentation_offloading.png&ehk=pAE0DfOX5Ii0DGj2zezPKbufNwQEX0uE62lUjaW09OA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"SYN攻击","slug":"systemstructure/network/synattack","date":"2020-07-23T12:45:23.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/synattack.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171435tcp-three-way-handshake-and-syn-flood-attack.png","content":"<p>SYN：同步序列编号（***Synchronize Sequence Numbers***）。</p>\n<p>是TCP/IP建立连接时使用的握手信号。在客户机和<a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571\">服务器</a>之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以<a href=\"https://baike.baidu.com/item/ACK/3692629\">ACK</a>消息响应。这样在<a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E6%9C%BA/5168153\">客户机</a>和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递</p>\n<h3 id=\"TCP报文首部\"><a href=\"#TCP报文首部\" class=\"headerlink\" title=\"TCP报文首部\"></a>TCP报文首部</h3><p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>\n<ol>\n<li>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</li>\n<li>序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li>\n<li>确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li>\n<li>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li>\n<li>保留，占6位，保留今后使用，但目前应都位0；</li>\n<li>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li>\n<li>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</li>\n<li>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</li>\n<li>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</li>\n<li>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</li>\n<li>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li>\n<li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li>\n<li>检验和，占2字节，校验首部和数据这两部分；</li>\n<li>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</li>\n<li>选项，长度可变，定义一些其他的可选的参数。</li>\n</ol>\n<h3 id=\"TCP连接的建立（三次握手）\"><a href=\"#TCP连接的建立（三次握手）\" class=\"headerlink\" title=\"TCP连接的建立（三次握手）\"></a>TCP连接的建立（三次握手）</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171424format,png\" alt=\"三次握手\"></p>\n<ol>\n<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>\n<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>\n<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>\n<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>\n<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>\n</ol>\n<p><strong>必须三次握手的原因：</strong>双方必须确认对方正确知道对方的seq序号并以ack返回</p>\n<h3 id=\"TCP连接的释放（四次挥手）\"><a href=\"#TCP连接的释放（四次挥手）\" class=\"headerlink\" title=\"TCP连接的释放（四次挥手）\"></a>TCP连接的释放（四次挥手）</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png\" alt=\"四次挥手\"></p>\n<ol>\n<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>\n<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>\n<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>\n<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>\n<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>\n<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>\n</ol>\n<p><strong>point：</strong></p>\n<ol>\n<li>服务端和客户端都可以主动断开连接</li>\n<li>在收到FIN包，只是发送方这边不再发送数据了，但是接收方可能还有数据在发送给发送方，所以此时不能直接断开连接，也因此不能立马发送FIN包。</li>\n<li><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171435tcp-three-way-handshake-and-syn-flood-attack.png\" alt=\"See the source image\"></li>\n</ol>\n<p>author:longtao.wu</p>\n<p>blog:<a href=\"http://www.longtao.fun/\">www.longtao.fun</a></p>\n<p><strong>refrence：</strong></p>\n<ol>\n<li><a href=\"https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md\">https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md</a></li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"vlan和vxlan","slug":"systemstructure/network/vlanandvxlan","date":"2020-06-17T12:24:54.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/vlanandvxlan.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171476vlan-t.jpg","content":"<h1 id=\"vlan\"><a href=\"#vlan\" class=\"headerlink\" title=\"vlan\"></a>vlan</h1><p>VLAN(Virtual LAN)，翻译成中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。</p>\n<p>vlan被创建后，应将交换机端口分配给vlan，以此使得接入该端口的电脑属于该vlan，需要使用该vlan所属的网络IP。</p>\n<p> 广播风暴防范<br>限制网络上bai的广播，将网络划分为多个VLAN可减少参与广播风暴的设备数量。LAN分段可以防止广播风暴波及整个网络。VLAN可以提供建立防火墙的机制，防止交换网络的过量广播。使用VLAN，可以将某个交换端口或用户赋于某一个特定的VLAN组，该VLAN组可以在一个交换网中或跨接多个交换机，在一个VLAN中的广播不会送到VLAN之外。同样，相邻的端口不会收到其他VLAN产生的广 播。这样可以减少广播流量，释放带宽给用户应用，减少广播的产生。<br>2. 安全<br>　　增强局域网的安全性，含有敏感数据的用户组可与网络的其余部分隔离，从而降低泄露机密信息的可能性。不同VLAN内的报文在传输时是相互隔离的，即一个VLAN内的用户不能和其它VLAN内的用户直接通信，如果不同VLAN要进行通信，则需要通过路由器或三层交换机等三层设备。<br>　　　　　　　　3.成本降低<br>　　　　　　　　　　成本高昂的网络升级需求减少，现有带宽和上行链路的利用率更高，因此可节约成本。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"DOS与DDOS","slug":"systemstructure/security/dosandddos","date":"2020-08-15T15:34:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/security/dosandddos.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171524DDoS-Attack.jpg","content":"<p>　TCP报头中一共有六个标志位：URG/ACK/PSH/RST/SYN/FIN。<br>SYN<br>　　表示建立一个方向的连接。<br>ACK<br>　　收到数据或请求后发送响应时发送ACK报文。<br>RST<br>　　关闭异常连接<br>FIN<br>　　表示关闭连接 　<br>PSH<br>　　　发送端需要发送一段数据，这个数据需要接收端一收到就进行向上交付。而接收端在收到PSH标志位有效的数据时，迅速将数据交付给应用层。所以PSH又叫急迫比特。<br>　　　但是现在已经不需要将数据交付给应用层了，因为这些效果在TCP栈已经可以自行处理这些问题了。<br>URG<br>　　URG成为紧急指针，意为URG位有效的数据包，是一个紧急需要处理的数据包，需要接收端在接收到之后迅速处理。</p>\n<p>dos全称是denial of service，dos攻击是使目标计算机或网络无法提供正常服务(拒绝服务)</p>\n<p>产生dos攻击效果的方式有很多</p>\n<p>syn攻击</p>\n<p>半连接攻击，向服务器端连续发送大量只有SYN标志的TCP链接请求，服务器会吧这些半连接排到链接缓冲区(Backlog queue)中，缓冲区满，无法接受新的请求，其他合法用户的请求就会被拒绝</p>\n<p>rst攻击</p>\n<p>自己攻击自己</p>\n<p>消耗资源攻击(带宽、磁盘等)</p>\n<p>泛洪攻击(flood)发送大量报文syc、ack、rst、udp、icmp、dns、http/https等</p>\n<p>反射攻击，伪装成被攻击对象向其它机器发送请求，其他机器响应请求，发送大量报文给攻击目标，从而早成攻击目标的性能耗尽一般用udp报文，因为udp的响应报文比请求报文更大，能实现攻击流量放大的作用</p>\n<p>畸形报文攻击</p>\n<p>发送大量有缺陷或者特殊控制作用的报文，造成主机处理报文时系统崩溃</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"获取系统信息","slug":"systemstructure/security/linuxinfo","date":"2020-09-09T15:40:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/security/linuxinfo.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171571Linux-system-info-Tools.jpg","content":"<h3 id=\"版本信息\"><a href=\"#版本信息\" class=\"headerlink\" title=\"版本信息\"></a>版本信息</h3><h4 id=\"uname工具\"><a href=\"#uname工具\" class=\"headerlink\" title=\"uname工具\"></a>uname工具</h4><p>uname工具是对sys/utsname函数的一个封装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a或--all：显示全部的信息；</span><br><span class=\"line\">-m或--machine：显示电脑类型；</span><br><span class=\"line\">-n或-nodename：显示在网络上的主机名称；</span><br><span class=\"line\">-r或--release：显示操作系统的发行编号；</span><br><span class=\"line\">-s或--sysname：显示操作系统名称；</span><br><span class=\"line\">-v：显示操作系统的版本；</span><br><span class=\"line\">-p或--processor：输出处理器类型或&quot;unknown&quot;；</span><br><span class=\"line\">-i或--hardware-platform：输出硬件平台或&quot;unknown&quot;；</span><br><span class=\"line\">-o或--operating-system：输出操作系统名称；</span><br></pre></td></tr></table></figure>\n\n<p>简单实例如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;sys/utsname.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">utsname</span> <span class=\"title\">uts</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Put information about the system in NAME.  */</span></span><br><span class=\"line\">    uname(&amp;uts);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name=%s\\n&quot;</span>,uts.sysname);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;version=%s\\n&quot;</span>,uts.version);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;release=%s\\n&quot;</span>,uts.release);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nodename=%s\\n&quot;</span>,uts.nodename);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;machine=%s\\n&quot;</span>,uts.machine);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**out：</span></span><br><span class=\"line\"><span class=\"comment\">    name=Linux</span></span><br><span class=\"line\"><span class=\"comment\">\tversion=#29~20.04.1-Ubuntu SMP Mon Aug 01 20:58:17 UTC 2021</span></span><br><span class=\"line\"><span class=\"comment\">\trelease=5.11.0-27-generic</span></span><br><span class=\"line\"><span class=\"comment\">\tnodename=longtaoXiaoXinPro13-2020</span></span><br><span class=\"line\"><span class=\"comment\">\tmachine=x86_64 </span></span><br><span class=\"line\"><span class=\"comment\">\t**/</span></span><br></pre></td></tr></table></figure>\n\n<p>utsname结构体如下,如果定义了_GNU_SOURCE还可以再打印个domainname</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">utsname</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Name of the implementation of the operating system.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> sysname[_UTSNAME_SYSNAME_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Name of this node on the network.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> nodename[_UTSNAME_NODENAME_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Current release level of this implementation.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> release[_UTSNAME_RELEASE_LENGTH];</span><br><span class=\"line\">    <span class=\"comment\">/* Current version level of this release.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> version[_UTSNAME_VERSION_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Name of the hardware type the system is running on.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> machine[_UTSNAME_MACHINE_LENGTH];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> _UTSNAME_DOMAIN_LENGTH - 0</span></span><br><span class=\"line\">    <span class=\"comment\">/* Name of the domain of this node on the network.  */</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">ifdef</span> __USE_GNU</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> domainname[_UTSNAME_DOMAIN_LENGTH];</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> __domainname[_UTSNAME_DOMAIN_LENGTH];</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"通过文件查看\"><a href=\"#通过文件查看\" class=\"headerlink\" title=\"通过文件查看\"></a>通过文件查看</h4><h5 id=\"内核信息\"><a href=\"#内核信息\" class=\"headerlink\" title=\"内核信息\"></a>内核信息</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;proc&#x2F;version</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"发行信息\"><a href=\"#发行信息\" class=\"headerlink\" title=\"发行信息\"></a>发行信息</h5><p>简要</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;etc&#x2F;issue</span><br></pre></td></tr></table></figure>\n\n<p>完整</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;etc&#x2F;*-release</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"CPU信息\"><a href=\"#CPU信息\" class=\"headerlink\" title=\"CPU信息\"></a>CPU信息</h5><p>lscpu命令或</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure>\n\n<p>除此之外还可以获取一些其他信息</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ ls /proc|grep info</span><br><span class=\"line\">buddyinfo </span><br><span class=\"line\">cpuinfo</span><br><span class=\"line\">meminfo</span><br><span class=\"line\">pagetypeinfo</span><br><span class=\"line\">slabinfo</span><br><span class=\"line\">vmallocinfo</span><br><span class=\"line\">zoneinfo</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"内存信息\"><a href=\"#内存信息\" class=\"headerlink\" title=\"内存信息\"></a>内存信息</h5><p>lsmem命令或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;proc&#x2F;memeinfo</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"其他信息\"><a href=\"#其他信息\" class=\"headerlink\" title=\"其他信息\"></a>其他信息</h5><p>buddyindo物理内存debug信息，lunux使用buddy算法解决物理内存的碎片问题</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ cat /proc/buddyinfo </span><br><span class=\"line\">Node 0, zone      DMA      1      0      0      1      2      1      1      0      1      2      2 </span><br><span class=\"line\">Node 0, zone    DMA32   2261   1007    541    301    455    234     60     24     12      4    321 </span><br><span class=\"line\">Node 0, zone   Normal   1120    593    346    660    116     36     32      6      5      4      1</span><br></pre></td></tr></table></figure>\n\n<p>zoneinfo显示内存空间的统计信息，对分析虚拟内存行为很有用</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"网络查询、嗅探","slug":"systemstructure/security/netoperate","date":"2020-09-26T15:00:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/security/netoperate.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171718Computer-Networking-Featured.jpg","content":"<p>[toc]</p>\n<h4 id=\"查自己的公网ip\"><a href=\"#查自己的公网ip\" class=\"headerlink\" title=\"查自己的公网ip\"></a>查自己的公网ip</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ curl http://members.3322.org/dyndns/getip</span><br><span class=\"line\">150.118.52.133</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 或者</span></span><br><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ curl ip.</span><br><span class=\"line\">150.118.52.133</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询域名的ip地址\"><a href=\"#查询域名的ip地址\" class=\"headerlink\" title=\"查询域名的ip地址\"></a>查询域名的ip地址</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ nslookup www.baidu.com</span><br><span class=\"line\">Server:\t\t127.0.0.53 #dns服务器</span><br><span class=\"line\">Address:\t127.0.0.53#53</span><br><span class=\"line\"></span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">www.baidu.com\tcanonical name = www.a.shifen.com.# 域名实际对应的主机名记录</span><br><span class=\"line\">Name:\twww.a.shifen.com </span><br><span class=\"line\">Address: 150.101.49.12 #域名负载均衡</span><br><span class=\"line\">Name:\twww.a.shifen.com</span><br><span class=\"line\">Address: 150.101.49.11</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询目标ip对应的mac地址\"><a href=\"#查询目标ip对应的mac地址\" class=\"headerlink\" title=\"查询目标ip对应的mac地址\"></a>查询目标ip对应的mac地址</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 用ping获取arp缓存再查找</span></span><br><span class=\"line\">[root@localhost ~]# ping 127.0.1.21 -c 1 &gt;&gt; /dev/null;arp -a 127.0.1.21|awk -F &quot; &quot; &#x27;&#123;print $4&#125;&#x27;</span><br><span class=\"line\">14:02:ec:32:cc:24</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改网卡mac地址\"><a href=\"#修改网卡mac地址\" class=\"headerlink\" title=\"修改网卡mac地址\"></a>修改网卡mac地址</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig eth0 hw ether B3:00:00:00:00:A2#临时修改</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"嗅探目标ip的信息\"><a href=\"#嗅探目标ip的信息\" class=\"headerlink\" title=\"嗅探目标ip的信息\"></a>嗅探目标ip的信息</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 嗅探目标ip端口开发情况</span></span><br><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ sudo nmap -PS 180.101.49.12</span><br><span class=\"line\">Starting Nmap 7.80 ( https://nmap.org ) at 2021-08-20 15:08 CST</span><br><span class=\"line\">Nmap scan report for 180.101.49.12</span><br><span class=\"line\">Host is up (0.0079s latency).</span><br><span class=\"line\">Not shown: 998 filtered ports</span><br><span class=\"line\">PORT    STATE SERVICE</span><br><span class=\"line\">80/tcp  open  http</span><br><span class=\"line\">443/tcp open  https</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 嗅探目标ip系统信息</span></span><br><span class=\"line\">sudo nmap -O 180.101.49.12</span><br><span class=\"line\">tarting Nmap 7.80 ( https://nmap.org ) at 2021-08-20 14:59 CST</span><br><span class=\"line\">Nmap scan report for 180.101.49.12</span><br><span class=\"line\">Host is up (0.0084s latency).</span><br><span class=\"line\">Not shown: 998 filtered ports</span><br><span class=\"line\">PORT    STATE SERVICE</span><br><span class=\"line\">80/tcp  open  http</span><br><span class=\"line\">443/tcp open  https</span><br><span class=\"line\">Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port</span><br><span class=\"line\">Aggressive OS guesses: Linux 2.6.18 - 2.6.22 (92%), D-Link DWL-624+ or DWL-2000AP, or TRENDnet TEW-432BRP WAP (90%), OneAccess 1641 router (90%), 3Com SuperStack 3 Switch 3870 (88%), HP ProCurve 2524 switch or 9100c Digital Sender printer (86%), Blue Coat PacketShaper appliance (86%), Satel ETHM-2 intruder alarm (86%), Apple TV 5.2.1 or 5.3 (86%), AVtech Room Alert 26W environmental monitor (85%)</span><br><span class=\"line\">No exact OS matches for host (test conditions non-ideal).</span><br><span class=\"line\"></span><br><span class=\"line\">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class=\"line\">Nmap done: 1 IP address (1 host up) scanned in 9.61 seconds</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 扫描整个网段所有ip</span></span><br><span class=\"line\">longtao@longtaoXiaoXinPro13-2020:~$ nmap  172.20.65.0/24</span><br><span class=\"line\">Starting Nmap 7.80 ( https://nmap.org ) at 2021-08-20 15:12 CST</span><br><span class=\"line\">Nmap scan report for 172.20.65.50</span><br><span class=\"line\">Host is up (0.00048s latency).</span><br><span class=\"line\">Not shown: 998 closed ports</span><br><span class=\"line\">PORT   STATE SERVICE</span><br><span class=\"line\">22/tcp open  ssh</span><br><span class=\"line\">80/tcp open  http</span><br><span class=\"line\"></span><br><span class=\"line\">Nmap scan report for 172.20.65.62</span><br><span class=\"line\">Host is up (0.00022s latency).</span><br><span class=\"line\">Not shown: 996 closed ports</span><br><span class=\"line\">PORT     STATE SERVICE</span><br><span class=\"line\">22/tcp   open  ssh</span><br><span class=\"line\">80/tcp   open  http</span><br><span class=\"line\">8080/tcp open  http-proxy</span><br><span class=\"line\">8888/tcp open  sun-answerbook</span><br><span class=\"line\"></span><br><span class=\"line\">Nmap scan report for 172.20.65.77</span><br><span class=\"line\">Host is up (0.00023s latency).</span><br><span class=\"line\">Not shown: 998 closed ports</span><br><span class=\"line\">PORT   STATE SERVICE</span><br><span class=\"line\">22/tcp open  ssh</span><br><span class=\"line\">80/tcp open  http</span><br><span class=\"line\"></span><br><span class=\"line\">Nmap scan report for 172.20.65.84</span><br><span class=\"line\">Host is up (0.00046s latency).</span><br><span class=\"line\">Not shown: 997 closed ports</span><br><span class=\"line\">PORT    STATE SERVICE</span><br><span class=\"line\">22/tcp  open  ssh</span><br><span class=\"line\">80/tcp  open  http</span><br><span class=\"line\">999/tcp open  garcon</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"模拟发包\"><a href=\"#模拟发包\" class=\"headerlink\" title=\"模拟发包\"></a>模拟发包</h4><p>使用hping3模拟发包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c --count count 发送数据包的次数</span><br><span class=\"line\">-i --interval 包发送间隔时间（单位是毫秒）缺省时间是1秒</span><br><span class=\"line\">-n -nmeric 数字输出，象征性输出主机地址。</span><br><span class=\"line\">-I --interface 网络接口名如eth0。</span><br><span class=\"line\">-v --verbose 显示很多信息，</span><br><span class=\"line\">-D --debug 进入debug模式</span><br><span class=\"line\">-z --bind 快捷键的使用。</span><br><span class=\"line\">-Z --unbind 消除快捷键。</span><br><span class=\"line\">-O --rawip RAWIP模式，在此模式下HPING会发送带数据的IP头。</span><br><span class=\"line\">-1 --icmp ICMP模式，此模式下HPING会发送IGMP应答报，你可以用--ICMPTYPE --ICMPCODE选项发送其他类型/模式的ICMP报文。</span><br><span class=\"line\">-2 --udp UDP 模式，缺省下，HPING会发送UDP报文到主机的0端口，你可以用--baseport --destport --keep选项指定其模式。</span><br><span class=\"line\">-9 --listen signatuer hping的listen模式，用此模式，HPING会接收指定的数据。</span><br><span class=\"line\">-a --spoof hostname 伪造IP攻击，防火墙就不会记录你的真实IP了，当然回应的包你也接收不到了。</span><br><span class=\"line\">-t --ttl time to live 可以指定发出包的TTL值。</span><br><span class=\"line\">-H --ipproto 在RAW IP模式里选择IP协议。</span><br><span class=\"line\">-w --WINID UNIX ,WINDIWS的id回应不同的，这选项可以让你的ID回应和WINDOWS一样。</span><br><span class=\"line\">-r --rel 更改ID的，可以让ID曾递减输出，详见HPING-HOWTO。</span><br><span class=\"line\">-F --FRAG 更改包的FRAG，这可以测试对方对于包碎片的处理能力，缺省的“virtual mtu”是16字节。</span><br><span class=\"line\">-x --morefrag 此功能可以发送碎片使主机忙于恢复碎片而造成主机的拒绝服务。</span><br><span class=\"line\">-y -dontfrag 发送不可恢复的IP碎片，这可以让你了解更多的MTU PATH DISCOVERY。</span><br><span class=\"line\">-G --fragoff fragment offset value set the fragment offset</span><br><span class=\"line\">-m --mtu mtu value 用此项后ID数值变得很大，50000没指定此项时3000-20000左右。</span><br><span class=\"line\">-G --rroute 记录路由，可以看到详悉的数据等等，最多可以经过9个路由，即使主机屏蔽了ICMP报文</span><br><span class=\"line\">-C --ICMPTYPE type 指定ICMP类型，缺省是ICMP echo REQUEST</span><br><span class=\"line\">-K --ICMPCODE CODE 指定ICMP代号，缺省0</span><br><span class=\"line\">--icmp-ipver 把IP版本也插入IP头</span><br><span class=\"line\">--icmp-iphlen 设置IP头的长度，缺省为5（32字节）</span><br><span class=\"line\">--icmp-iplen 设置IP包长度</span><br><span class=\"line\">-s --baseport source port hping 用源端口猜测回应的包</span><br><span class=\"line\">-p --deskport [+][+]desk port 设置目标端口，缺省为0，一个加号设置为:每发送一个请求包到达后，端口加1，两个加号为：每发一个包，端口数加1</span><br><span class=\"line\">-w --win 发windows包，64BYTE</span><br><span class=\"line\">-O --tcpoff 设置tcp偏移</span><br><span class=\"line\">-m --tcpseq 设置TCP序列数</span><br><span class=\"line\">-l --tcpck 设置TCP ack</span><br><span class=\"line\">-Q --seqnum 搜集序列号</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"硬盘IO性能估算(IOPS,吞吐量，延时)","slug":"systemstructure/storage/diskperformanceestimation","date":"2021-04-29T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/storage/diskperformanceestimation.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171774R-C.b15aac80564d038ed359e47a066f891d?rik=VW2MMdB7BnKcXw&riu=http%3a%2f%2fsfwallpaper.com%2fimages%2fhdd-wallpaper-12.jpg&ehk=FjTRXCjxUHy0umSxoAK5tGP5r11SxPO17XwKdagy56I%3d&risl=&pid=ImgRaw&r=0","content":"<h1 id=\"硬盘IO性能估算-IOPS-吞吐量，延时\"><a href=\"#硬盘IO性能估算-IOPS-吞吐量，延时\" class=\"headerlink\" title=\"硬盘IO性能估算(IOPS,吞吐量，延时)\"></a>硬盘IO性能估算(IOPS,吞吐量，延时)</h1><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p><strong>磁盘种类</strong></p>\n<p>硬盘有<strong>固态硬盘</strong>(SSD 盘，新式硬盘)、<strong>机械硬盘</strong>(HDD 传统硬盘)、<strong>混合硬盘</strong>(HHD 一块基于传统机械硬盘诞生出来的新硬盘)。SSD采用闪存颗粒来储存，HDD采用磁性碟片来储存，混合硬盘(HHD: Hybrid Hard Disk)是把磁性硬盘和闪存集成到一起的一种硬盘。</p>\n<p><strong>容量</strong></p>\n<p>硬盘的容量以兆字节(MB/MiB)、千兆字节(GB/GiB)或百万兆字节(TB/TiB)为单位，而常见的换算式为：1TB=1024GB,1GB=1024MB而1MB=1024KB。但硬盘厂商通常运用的是GB，也就是1G=1000MB，而Win系统，就依旧以“GB”字样来表示“GiB”单位(1024换算的)，因此我们在BIOS中或在格式化硬盘时看到的容量会比厂家的标称值要小。</p>\n<p><strong>转速</strong>（Rotational Speed 或Spindle speed）</p>\n<p>RPM是Revolutions Per minute的缩写，是转/每分钟。RPM值越大，内部传输率就越快，访问时间就越短，硬盘的整体性能也就越好。</p>\n<p><strong>寻道时间</strong> Tseek是指将读写磁头移动至正确的磁道上所需要的时间。寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms。</p>\n<p><strong>旋转延迟</strong> Trotation是指盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间。旋转延迟取决于磁盘转速，通常使用磁盘旋转一周所需时间的1/2表示。</p>\n<p><strong>数据传输时间</strong> Ttransfer是指完成传输所请求的数据所需要的时间，它取决于数据传输率，其值等于数据大小除以数据传输率。目前IDE/ATA能达到133MB/s，SATA II可达到300MB/s的接口数据传输率，数据传输时间通常远小于前两部分消耗时间。简单计算时可忽略。</p>\n<p><strong>IOPS</strong></p>\n<p>每秒处理的IO次数</p>\n<p><strong>RPM</strong></p>\n<p>转速</p>\n<h3 id=\"性能估算\"><a href=\"#性能估算\" class=\"headerlink\" title=\"性能估算\"></a>性能估算</h3><p><strong>寻道时间估算</strong></p>\n<p>磁头移动到对应磁道上的耗时。</p>\n<p> SATA 7200RPM，平均寻道时间是9ms。</p>\n<p> SAS 10000RPM，平均寻道时间是6ms。 </p>\n<p>SAS 15000RPM，平均寻道时间是4ms。</p>\n<p>具体查看磁盘供应商提供数据。</p>\n<p><strong>旋转延时估算</strong></p>\n<p>平均为磁盘旋转一周所需时间的一半<br>$$<br>旋转延时=60*1000/RPM/2<br>$$<br><strong>传输时间</strong></p>\n<p> 平均数据大小除以接口传输率，耗时很小粗略计算可以忽略。 SATA，300<del>600MB/s。 SAS，3Gbit/s。 FC，2</del>4Gbit/s。 NVME，32Gbit/s。</p>\n<p><strong>吞吐量估算</strong><br>$$<br>I/O 吞吐量(一秒内)＝ IOPS* 平均 I/O SIZE<br>$$<br><strong>IOPS估算</strong><br>$$<br>IOPS = 1000 ms/ (寻道时间 + 旋转延迟)\\<br>物理磁盘总的IOPS = 物理磁盘的IOPS × 磁盘数目\\<br>可用的IOPS = （物理磁盘总的IOPS × 写百分比 ÷ RAID写惩罚） + （物理磁盘总的IOPS × 读百分比）<br>$$<br>其中</p>\n<p><strong>RAID-0：</strong>直接的条带，数据每次写入对应物理磁盘上的一次写入，写惩罚值是1。</p>\n<p><strong>RAID-1和10</strong>：RAID-1 和RAID-10的写惩罚很简单理解，因为数据的镜像存在的，所以一次写入会有两次，写惩罚值是2。</p>\n<p><strong>RAID-5：</strong>RAID-5由于要计算校验位的机制存在，需要读数据、读校验位、写数据、写校验位四个步骤，所以RAID-5的写惩罚值是4。</p>\n<p><strong>RAID-6：</strong>RAID-6由于有两个校验位的存在，与RAID-5相比，需要读取两次校验位和写入两次校验位，所以RAID-6的写惩罚值是6。</p>\n<p><strong>iops估算raid盘数</strong></p>\n<ol>\n<li><p>如果单盘不能满足性能需求，需要通过Raid实现，计算所需硬盘数公式如下。 Raid1、10，Drive IOPS = Read IOPS + 2<em>Write IOPS Raid3、5，Drive IOPS = Read IOPS + 4</em>Write IOPS Raid6，Drive IOPS = Read IOPS + 6*Write IOPS；</p>\n</li>\n<li><p>设需要IOPS 5000，读写比例2:1，则RAID10后IOPS需求为。 RAID10，(2/3) * 5000 + 2 * (1/3) * 5000 = 6666 IOPS；</p>\n</li>\n<li><p>已知SAS 15000RPM机械硬盘IOPS165。 5000IOPS所需硬盘个数, 6666 / 165 = 40。</p>\n</li>\n</ol>\n<p><strong>SSD硬盘IO估算</strong></p>\n<p>固态硬盘没有寻道时间和旋转时间。IO耗时是通过地址查找数据耗时，根据芯片颗粒SLC、MLC，中控芯片、队列深度32~64、接口SATA、PCIE的不同，一般负载非太高时是相对固定值（控制在60%利用率）。 IOPS = 1000 / IO耗时。因为SSD比较固定，比如Intel 320 SSD对8K avgrq-sz耗时0.1ms，1000/0.1ms=10000 IOPS。具体参考后续文章。</p>\n<p><strong>常见存储设备参考性能</strong></p>\n<p>5400 RPM SATA，60 IOPS </p>\n<p>7200 RPM SATA，70 IOPS </p>\n<p>10000 RPM SAS，110 IOPS </p>\n<p>15000 RPM SAS，150 IOPS，Sequential RW 180MB/s、Radom RW 15MB/s。 </p>\n<p>10000 RPM FC，125 IOPS </p>\n<p>15000 RPM FC，150 IOPS</p>\n<p> SSD SATA，3000~40000 IOPS，R 400MB/s、W 250MB/s。 </p>\n<p>SSD PCIE，20000~40000 IOPS，R 500MB/s、W 300MB/s。 </p>\n<p>内存，1000000+ IOPS，30~60 GB/s。</p>\n<h3 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h3><p>对于随机负载，当遇到余下情况时，我们那通常认为存在 I/O 性能问题：</p>\n<ol>\n<li><p>平均读时间大于 15ms</p>\n</li>\n<li><p>在具有写 cache 的条件下，平均写时间大于 2.5ms</p>\n</li>\n</ol>\n<p>对于顺序负载，当遇到余下情况时，我们那通常认为存在 I/O 性能问题：</p>\n<ol start=\"3\">\n<li><p>在一个磁盘上有两个连续的 I/O 流</p>\n</li>\n<li><p>吞吐量不足（即远远小于磁盘 I/O 带宽）</p>\n</li>\n</ol>\n<p>对于一块磁盘来讲，随着 IOPS 数量的增加，I/O service 也会增加，并且会有一个饱和点，即 IOPS 达到某个点以后，IOPS 再增加将会引起 I/O service time 的显著增加。</p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p><strong>判断是ssd还是hdd</strong></p>\n<ol>\n<li>```shell<br>cat /sys/block/*/queue/rotational<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. &#96;&#96;&#96;shell</span><br><span class=\"line\">   lsblk -d -o name,rota</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>0为ssd，1为hdd</p>\n<p><strong>查看磁盘转速</strong></p>\n<ol>\n<li><pre><code>sginfo -g /dev/*\n</code></pre>\n</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"幂等","slug":"systemstructure/web/idempotent","date":"2020-10-23T15:28:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/web/idempotent.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171881678d01b11450c9eb195769dab8e691c6.png","content":"<p>[toc]</p>\n<h2 id=\"幂等去重\"><a href=\"#幂等去重\" class=\"headerlink\" title=\"幂等去重\"></a>幂等去重</h2><p>最近计算节点网络异常时经常出现请求未响应问题，之前的做法是在接收到任务之后与原先存在的任务做比较,进而判断是否为同一个请求的重试，</p>\n<p>主流的MQ实现在 <code>autocommit=true</code> 时天然实现了幂等</p>\n<p>但考虑业务处理可能出错的情况我们一般会将autocommit设置成false，在业务处理成功后再提交，这时就需要使用上述幂等方案了</p>\n<p>在接收到消息时写入请求Token以实现去重判断（Token可为Topic+Offset）提交后删除Token，整体上可以做到对业务透明</p>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><ol>\n<li>没有副作用</li>\n</ol>\n<h3 id=\"什么是幂等性\"><a href=\"#什么是幂等性\" class=\"headerlink\" title=\"什么是幂等性\"></a>什么是幂等性</h3><ol>\n<li>数学表述， 多次调用仍为自身，</li>\n<li>不产生副作用</li>\n<li>带上uuid识别是否是相同的请求，避免重复请求</li>\n<li>ACID 2.0 解释，与分布式中的ACID辨析</li>\n<li>stateless 无状态 何时使用，对内维护状态，对外接口无状态+异步。</li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]},{"title":"cmd执行命令卡住了","slug":"systemstructure/windows/batblock","date":"2020-10-18T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/windows/batblock.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635172010R-C.1295498867d0a14529a15c280d612bf9?rik=tk4p6tmyea33JQ&riu=http%3a%2f%2fzfnb-leiting.oss-cn-beijing.aliyuncs.com%2fmvcroyyj52fcso-2.jpg&ehk=7NXbedYaErtmiwW183CSf2pvdxRWGQhRdnb2jTa1e5o%3d&risl=&pid=ImgRaw&r=0","content":"<p><strong>windows cmd-&gt;属性-&gt;选项-&gt;编辑选项</strong></p>\n<p><strong>取消 快速编辑模式</strong></p>\n<p>cmd默认开启了“快速编辑模式”，只要当鼠标点击cmd任何区域时，就自动进入了编辑模式，之后的程序向控制台输入内容甚至后台的程序都会被阻塞。</p>\n<p>我们在控制台里面回车或者右键鼠标后，自动退出了编辑模式。因此，控制又恢复输出内容，服务端又正常了。</p>\n<p>选择快速编辑模式的时候,鼠标不小心点到cmd某个位置,都可能让正在运行的进程都卡住，直到按下回车后，会跳出一堆。</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"windows","path":"api/tags/windows.json"}]},{"title":"windows实现延时的几种方式","slug":"systemstructure/windows/batdelay","date":"2020-10-27T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/windows/batdelay.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635172159delay.c.png","content":"<p>方法一：ping</p>\n<p>缺点:时间精度为1秒,不够精确</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo <span class=\"keyword\">off</span></span><br><span class=\"line\">@ping <span class=\"number\">127.0</span>.<span class=\"number\">0.1</span> -n <span class=\"number\">6</span> &gt;nul</span><br><span class=\"line\">start gdh.txt</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>方法二：vbs start /wait</p>\n<p>缺点：生成临时文件</p>\n<p>有点：时间精度为0.001秒，精度高</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo <span class=\"keyword\">off</span></span><br><span class=\"line\">echo wscript.sleep <span class=\"number\">5000</span>&gt;sleep.vbs</span><br><span class=\"line\">start /wait sleep.vbs</span><br><span class=\"line\">start gdh.txt</span><br><span class=\"line\">del /f /s /q sleep.vbs</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>方法三：vbs cscript</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo <span class=\"keyword\">off</span></span><br><span class=\"line\">echo wscript.sleep <span class=\"number\">5000</span>&gt;sleep.vbs</span><br><span class=\"line\">@cscript sleep.vbs &gt;nul</span><br><span class=\"line\">start gdh.txt</span><br><span class=\"line\">del /f /s /q sleep.vbs</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>方法四：choice</p>\n<p>ssh过去有问题，停不下来</p>\n<p>优点：时间精确，CPU占用低，是最佳选择</p>\n<p>CHOICE：[/C[:]按键表] [/N] [/S] [/T[:]选择值,秒数] [显示文本]<br>其中，/C表示可选则的按键，/N表示不要显示提示信息，/S表示大小写字符敏感方式，/T表示若在批定的时间内没有选择的话，自动执行/C中定义的某个选择值。显示文本是CHOICE命令执行时的提示信息。选择结果将用ERRORLEVEL值来表示</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo <span class=\"keyword\">off</span></span><br><span class=\"line\">choice /t <span class=\"number\">5</span> /d y /n &gt;nul</span><br><span class=\"line\">start gdh.txt</span><br></pre></td></tr></table></figure>\n\n<p>方法五：for+set+if，时间精度为0.01秒</p>\n<p>缺点：CPU占用高，语句过长，不常用</p>\n<figure class=\"highlight vb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo <span class=\"keyword\">off</span></span><br><span class=\"line\">setlocal enableextensions</span><br><span class=\"line\">echo %time%</span><br><span class=\"line\"><span class=\"keyword\">call</span> :ProcDelay <span class=\"number\">500</span></span><br><span class=\"line\">echo %time%</span><br><span class=\"line\">start gdh.txt</span><br><span class=\"line\">:ProcDelay delayMSec_</span><br><span class=\"line\">setlocal enableextensions</span><br><span class=\"line\"><span class=\"keyword\">for</span> /f <span class=\"string\">&quot;tokens=1-4 delims=:. &quot;</span> %%h <span class=\"keyword\">in</span> (<span class=\"string\">&quot;%time%&quot;</span>) <span class=\"keyword\">do</span> <span class=\"keyword\">set</span> start_=%%h%%i%%j%%k</span><br><span class=\"line\">:_procwaitloop</span><br><span class=\"line\"><span class=\"keyword\">for</span> /f <span class=\"string\">&quot;tokens=1-4 delims=:. &quot;</span> %%h <span class=\"keyword\">in</span> (<span class=\"string\">&quot;%time%&quot;</span>) <span class=\"keyword\">do</span> <span class=\"keyword\">set</span> now_=%%h%%i%%j%%k</span><br><span class=\"line\"><span class=\"keyword\">set</span> /a diff_=%now_%-%start_%</span><br><span class=\"line\"><span class=\"keyword\">if</span> %diff_% LSS %<span class=\"number\">1</span> <span class=\"keyword\">goto</span> _procwaitloop</span><br><span class=\"line\">endlocal &amp; <span class=\"keyword\">goto</span> :EOF</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"windows","path":"api/tags/windows.json"}]},{"title":"什么是hyperv","slug":"systemstructure/windows/hyperv","date":"2020-11-13T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/windows/hyperv.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211026/1635179986966575_original.jpg","content":"<p>Hyper-V是<a href=\"https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF\">微软</a>的一款虚拟化产品，是微软第一个采用类似Vmware ESXi和Citrix Xen的基于hypervisor的技术。这也意味着<a href=\"https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF/124767\">微软</a>会更加直接地与市场先行者VMware展开竞争，但竞争的方式会有所不同。Hyper-V是<a href=\"https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF/124767\">微软</a>提出的一种<a href=\"https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/10844875\">系统管理</a>程序<a href=\"https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/276750\">虚拟化技术</a>，能够实现桌面虚拟化 </p>\n<h2 id=\"系统要求\"><a href=\"#系统要求\" class=\"headerlink\" title=\"系统要求\"></a>系统要求</h2><p>1.<a href=\"https://baike.baidu.com/item/Intel/125450\">Intel</a>或者<a href=\"https://baike.baidu.com/item/AMD/5905\">AMD</a>64位处理器 [1] （从Windows10预览版更新19559开始ARM64位处理器也受支持 [2] ）</p>\n<p>2.Windows Server 2008 R2及以上(服务器操作<a href=\"https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F\">系统</a>)；Windows 7及以上(桌面操作系统)。</p>\n<p>3.硬件辅助虚拟化。这是在现有的<a href=\"https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8\">处理器</a>，包括一个虚拟化的</p>\n<p>选择工具体来说，[Intel vt](<a href=\"https://baike.baidu.com/item/Intel\">https://baike.baidu.com/item/Intel</a> vt/2091588)或AMD-v（ AMD-v，以前的代号为“ Pacifica ”的 ) 。</p>\n<p>4.<a href=\"https://baike.baidu.com/item/CPU/120556\">CPU</a>必须具备硬件的<a href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%89%A7%E8%A1%8C%E4%BF%9D%E6%8A%A4\">数据执行保护</a>（ DEP ）功能，而且该功能必须启动。</p>\n<p>5.内存最低限度为2GB。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635172176resize,m_lfit,w_220,h_220,limit_1\" alt=\"微软虚拟化构架\">微软虚拟化构架</p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"windows","path":"api/tags/windows.json"}]},{"title":"yum使用","slug":"systemstructure/linux/centos/yum","date":"2020-03-25T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/centos/yum.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139119R-C.e7858ea7dbba67337d3f500b54cbcf56?rik=GYzv0YkaAoFURQ&riu=http%3a%2f%2fwww.lixh.cn%2fwp-content%2fuploads%2f2016%2f08%2fyumserver.png&ehk=k4SGsgtCGKTxT0%2bakBQ4bKUDFIBTi7VwHWP8L%2fM3TI4%3d&risl=&pid=ImgRaw&r=0","content":"<p>[toc]</p>\n<h2 id=\"更改centos-yum-源\"><a href=\"#更改centos-yum-源\" class=\"headerlink\" title=\"更改centos yum 源\"></a>更改centos yum 源</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/yum.repos.d/CentOS-Base.rep</span><br></pre></td></tr></table></figure>\n\n<p>更改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[base]</span><br><span class=\"line\">name&#x3D;CentOS-$releasever - Base</span><br><span class=\"line\">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7.6.1810&#x2F;os&#x2F;x86_64&#x2F;</span><br><span class=\"line\">gpgcheck&#x3D;0</span><br><span class=\"line\"></span><br><span class=\"line\">[updates]</span><br><span class=\"line\">name&#x3D;CentOS-$releasever - Updates</span><br><span class=\"line\">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7.6.1810&#x2F;updates&#x2F;x86_64&#x2F;</span><br><span class=\"line\">gpgcheck&#x3D;0</span><br><span class=\"line\"></span><br><span class=\"line\">[extras]</span><br><span class=\"line\">name&#x3D;CentOS-$releasever - Extras</span><br><span class=\"line\">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7.6.1810&#x2F;extras&#x2F;x86_64&#x2F;</span><br><span class=\"line\">gpgcheck&#x3D;0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[serverid]</span><br><span class=\"line\">#其中serverid是用于区别各个不同的repository（仓库;贮藏室;博物馆;亲信），必须有一个独一无二的名称。 重复了 前面覆盖后面--还是反过来呢？？？用enabled 测试是后面覆盖前面</span><br><span class=\"line\"></span><br><span class=\"line\">name&#x3D;Some name for this server</span><br><span class=\"line\">#name，是对repository的描述，支持像$releasever $basearch这样的变量; name&#x3D;Fedora Core $releasever - $basearch - Released Updates</span><br><span class=\"line\"></span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">#baseurl是服务器设置中最重要的部分，只有设置正确，才能从上面获取软件。它的格式是：</span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;server1&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">url:&#x2F;&#x2F;server2&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">url:&#x2F;&#x2F;server3&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">#其中url支持的协议有 http:&#x2F;&#x2F; ftp:&#x2F;&#x2F; file:&#x2F;&#x2F;三种。baseurl后可以跟多个url，你可以自己改为速度比较快的镜像站，但baseurl只能有一个，也就是说不能像如下格式：</span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;server1&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;server2&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">baseurl&#x3D;url:&#x2F;&#x2F;server3&#x2F;path&#x2F;to&#x2F;repository&#x2F;</span><br><span class=\"line\">其中url指向的目录必须是这个repository header目录的上一级，它也支持$releasever $basearch这样的变量。</span><br><span class=\"line\"></span><br><span class=\"line\">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrors.fedoraproject.org&#x2F;mirrorlist?repo&#x3D;fedora-$releasever&amp;arch&#x3D;$basearch</span><br><span class=\"line\">#上面的这一行是指定一个镜像服务器的地址列表，通常是开启的，本例中加了注释符号禁用了，我们可以试试，将$releasever和$basearch替换成自己对应的版本和架构，例如10和i386，在浏览器中打开，我们就能看到一长串镜可用的镜像服务器地址列表。</span><br><span class=\"line\"></span><br><span class=\"line\">url之后可以加上多个选项，如gpgcheck、exclude、failovermethod等，比如：</span><br><span class=\"line\">gpgcheck&#x3D;1</span><br><span class=\"line\">exclude&#x3D;gaim</span><br><span class=\"line\">#其中gpgcheck，exclude的含义和[main]部分相同，但只对此服务器起作用，</span><br><span class=\"line\">failovermethod&#x3D;priority</span><br><span class=\"line\">#failovermethode 有两个选项roundrobin和priority，意思分别是有多个url可供选择时，yum选择的次序，roundrobin是随机选择，如果连接失 败则使用下一个，依次循环，priority则根据url的次序从第一个开始。如果不指明，默认是roundrobin。</span><br><span class=\"line\"></span><br><span class=\"line\">enabled&#x3D;[1 or 0]</span><br><span class=\"line\">#当某个软件仓库被配置成 enabled&#x3D;0 时，yum 在安装或升级软件包时不会将该仓库做为软件包提供源。使用这个选项，可以启用或禁用软件仓库。</span><br><span class=\"line\">#通过 yum 的 --enablerepo&#x3D;[repo_name] 和 --disablerepo&#x3D;[repo_name] 选项，或者通过 PackageKit 的&quot;添加&#x2F;删除软件&quot;工具，也能够方便地启用和禁用指定的软件仓库</span><br></pre></td></tr></table></figure>\n\n<p>由于通过源码安装的qemu没有办法通过系统工具进行卸载，也没有办法通过make uninstall方法卸载，所以只能通过删除文件的方式进行卸载。</p>\n<p>qemu可执行文件默认放在/usr/local/bin，库文件默认放在/usr/local/libexec，配置文件默认放在/usr/local/etc，共享文件默认放在/usr/local/etc/share。要卸载源码编译的qemu，需要到这四个目录中找出相关的文件然后删除掉。</p>\n<p>如果configure时没有通过–target-list=指定编译的目标机体系结构，则/usr/local/bin中的以qemu开头的文件需要删除，总共51个。</p>\n<p>/usr/local/libexec中只有一个文件：qemu-bridge-helper，直接删除即可。</p>\n<p>/usr/local/etc比较简单，只有一个qemu目录，其下有一个文件target-x86_64.conf，直接将qemu目录删除即可。</p>\n<p>同/usr/local/etc一样，qemu相关的共享文件都放在/usr/local/etc/share目录下的qemu子目录中，直接将该子目录删除即可。</p>\n<h2 id=\"设置本地yum源\"><a href=\"#设置本地yum源\" class=\"headerlink\" title=\"设置本地yum源\"></a>设置本地yum源</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建rpm包文件存放目录及复制相关文件</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> mkdir -pv /mnt/CentOS7_ISO</span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /run/media/robin/CentOS\\ 7\\ x86_64/</span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> cp -R * /mnt/CentOS7_ISO/</span></span><br><span class=\"line\"></span><br><span class=\"line\">修改yum源repo文件配置</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /etc/yum.repos.d/</span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> mkdir old</span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> mv *.repo old</span></span><br><span class=\"line\"></span><br><span class=\"line\">编辑repo配置文件</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim /etc/yum.repos.d/longtao.repo</span></span><br><span class=\"line\">[longtao]</span><br><span class=\"line\">name=longtao local repository</span><br><span class=\"line\">baseurl=file/root/qemu-kvm-ev</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">清空yum缓存目录</span><br><span class=\"line\">  [root@centos7-router yum.repos.d]# yum clean all</span><br><span class=\"line\">  Loaded plugins: fastestmirror, langpacks</span><br><span class=\"line\">  Cleaning repos: local-media</span><br><span class=\"line\">  Cleaning up everything</span><br><span class=\"line\">  Cleaning up list of fastest mirrors</span><br><span class=\"line\"></span><br><span class=\"line\">生成yum元数据</span><br><span class=\"line\">  [root@centos7-router yum.repos.d]# yum makecache</span><br><span class=\"line\">  Loaded plugins: fastestmirror, langpacks</span><br><span class=\"line\">  local-media                                                                        | 3.6 kB  00:00:00    </span><br><span class=\"line\">  (1/4): local-media/group_gz                                                      | 155 kB  00:00:00    </span><br><span class=\"line\">  (2/4): local-media/primary_db                                                    | 2.8 MB  00:00:00    </span><br><span class=\"line\">  (3/4): local-media/other_db                                                      | 1.2 MB  00:00:00    </span><br><span class=\"line\">  (4/4): local-media/filelists_db                                                  | 2.9 MB  00:00:00    </span><br><span class=\"line\">  Determining fastest mirrors</span><br><span class=\"line\">  Metadata Cache Created  ###提示元数据缓存创建成功</span><br><span class=\"line\"></span><br><span class=\"line\">查看本机yum repo 仓库</span><br><span class=\"line\">  [root@centos7-router ~]# yum repolist</span><br><span class=\"line\">  Loaded plugins: fastestmirror, langpacks</span><br><span class=\"line\">  Loading mirror speeds from cached hostfile</span><br><span class=\"line\">  repo id                                               repo name                    status</span><br><span class=\"line\">  local-media                                        CentOS-7 - Media                   3,723</span><br><span class=\"line\">  repolist: 3,723</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"临时源\"><a href=\"#临时源\" class=\"headerlink\" title=\"临时源\"></a>临时源</h2><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li><code>yum update</code>别运行，可能把内核和上面的软件都更新了</li>\n<li></li>\n</ol>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"}]},{"title":"golang的bufio包","slug":"language/golang/bufiopackage","date":"2019-09-09T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/bufiopackage.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635134014gopher-48499__340.png","content":"<p>原理</p>\n<p>bufio通过缓冲提高效率</p>\n<p>把文件读取进缓冲(内存)避免每次读取触发系统io</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">participant 程序 as A</span><br><span class=\"line\">participant 缓冲区buf as B</span><br><span class=\"line\">participant 文件 as C</span><br><span class=\"line\">B--A:写入内容小于buf</span><br><span class=\"line\">B--A:</span><br><span class=\"line\">C--B:buf没空间，写入文件，清空buf</span><br><span class=\"line\">C--A:写入内容大于buf</span><br></pre></td></tr></table></figure>\n\n\n\n<p>把文件写入缓冲，多次写入后，最后一次性写入文件·</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序--缓冲区buf:写入内容小于buf</span><br><span class=\"line\">程序--缓冲区buf:</span><br><span class=\"line\">缓冲区buf--文件:buf没空间，写入文件，清空buf</span><br><span class=\"line\">程序--文件:写入内容大于buf</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br><span class=\"line\">619</span><br><span class=\"line\">620</span><br><span class=\"line\">621</span><br><span class=\"line\">622</span><br><span class=\"line\">623</span><br><span class=\"line\">624</span><br><span class=\"line\">625</span><br><span class=\"line\">626</span><br><span class=\"line\">627</span><br><span class=\"line\">628</span><br><span class=\"line\">629</span><br><span class=\"line\">630</span><br><span class=\"line\">631</span><br><span class=\"line\">632</span><br><span class=\"line\">633</span><br><span class=\"line\">634</span><br><span class=\"line\">635</span><br><span class=\"line\">636</span><br><span class=\"line\">637</span><br><span class=\"line\">638</span><br><span class=\"line\">639</span><br><span class=\"line\">640</span><br><span class=\"line\">641</span><br><span class=\"line\">642</span><br><span class=\"line\">643</span><br><span class=\"line\">644</span><br><span class=\"line\">645</span><br><span class=\"line\">646</span><br><span class=\"line\">647</span><br><span class=\"line\">648</span><br><span class=\"line\">649</span><br><span class=\"line\">650</span><br><span class=\"line\">651</span><br><span class=\"line\">652</span><br><span class=\"line\">653</span><br><span class=\"line\">654</span><br><span class=\"line\">655</span><br><span class=\"line\">656</span><br><span class=\"line\">657</span><br><span class=\"line\">658</span><br><span class=\"line\">659</span><br><span class=\"line\">660</span><br><span class=\"line\">661</span><br><span class=\"line\">662</span><br><span class=\"line\">663</span><br><span class=\"line\">664</span><br><span class=\"line\">665</span><br><span class=\"line\">666</span><br><span class=\"line\">667</span><br><span class=\"line\">668</span><br><span class=\"line\">669</span><br><span class=\"line\">670</span><br><span class=\"line\">671</span><br><span class=\"line\">672</span><br><span class=\"line\">673</span><br><span class=\"line\">674</span><br><span class=\"line\">675</span><br><span class=\"line\">676</span><br><span class=\"line\">677</span><br><span class=\"line\">678</span><br><span class=\"line\">679</span><br><span class=\"line\">680</span><br><span class=\"line\">681</span><br><span class=\"line\">682</span><br><span class=\"line\">683</span><br><span class=\"line\">684</span><br><span class=\"line\">685</span><br><span class=\"line\">686</span><br><span class=\"line\">687</span><br><span class=\"line\">688</span><br><span class=\"line\">689</span><br><span class=\"line\">690</span><br><span class=\"line\">691</span><br><span class=\"line\">692</span><br><span class=\"line\">693</span><br><span class=\"line\">694</span><br><span class=\"line\">695</span><br><span class=\"line\">696</span><br><span class=\"line\">697</span><br><span class=\"line\">698</span><br><span class=\"line\">699</span><br><span class=\"line\">700</span><br><span class=\"line\">701</span><br><span class=\"line\">702</span><br><span class=\"line\">703</span><br><span class=\"line\">704</span><br><span class=\"line\">705</span><br><span class=\"line\">706</span><br><span class=\"line\">707</span><br><span class=\"line\">708</span><br><span class=\"line\">709</span><br><span class=\"line\">710</span><br><span class=\"line\">711</span><br><span class=\"line\">712</span><br><span class=\"line\">713</span><br><span class=\"line\">714</span><br><span class=\"line\">715</span><br><span class=\"line\">716</span><br><span class=\"line\">717</span><br><span class=\"line\">718</span><br><span class=\"line\">719</span><br><span class=\"line\">720</span><br><span class=\"line\">721</span><br><span class=\"line\">722</span><br><span class=\"line\">723</span><br><span class=\"line\">724</span><br><span class=\"line\">725</span><br><span class=\"line\">726</span><br><span class=\"line\">727</span><br><span class=\"line\">728</span><br><span class=\"line\">729</span><br><span class=\"line\">730</span><br><span class=\"line\">731</span><br><span class=\"line\">732</span><br><span class=\"line\">733</span><br><span class=\"line\">734</span><br><span class=\"line\">735</span><br><span class=\"line\">736</span><br><span class=\"line\">737</span><br><span class=\"line\">738</span><br><span class=\"line\">739</span><br><span class=\"line\">740</span><br><span class=\"line\">741</span><br><span class=\"line\">742</span><br><span class=\"line\">743</span><br><span class=\"line\">744</span><br><span class=\"line\">745</span><br><span class=\"line\">746</span><br><span class=\"line\">747</span><br><span class=\"line\">748</span><br><span class=\"line\">749</span><br><span class=\"line\">750</span><br><span class=\"line\">751</span><br><span class=\"line\">752</span><br><span class=\"line\">753</span><br><span class=\"line\">754</span><br><span class=\"line\">755</span><br><span class=\"line\">756</span><br><span class=\"line\">757</span><br><span class=\"line\">758</span><br><span class=\"line\">759</span><br><span class=\"line\">760</span><br><span class=\"line\">761</span><br><span class=\"line\">762</span><br><span class=\"line\">763</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">// Use of this source code is governed by a BSD-style</span></span><br><span class=\"line\"><span class=\"comment\">// license that can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer</span></span><br><span class=\"line\"><span class=\"comment\">// object, creating another object (Reader or Writer) that also implements</span></span><br><span class=\"line\"><span class=\"comment\">// the interface but provides buffering and some help for textual I/O.</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> bufio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;unicode/utf8&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tdefaultBufSize = <span class=\"number\">4096</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tErrInvalidUnreadByte = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadByte&quot;</span>)</span><br><span class=\"line\">\tErrInvalidUnreadRune = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadRune&quot;</span>)</span><br><span class=\"line\">\tErrBufferFull        = errors.New(<span class=\"string\">&quot;bufio: buffer full&quot;</span>)</span><br><span class=\"line\">\tErrNegativeCount     = errors.New(<span class=\"string\">&quot;bufio: negative count&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered input.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reader implements buffering for an io.Reader object.对io.Reader的封装</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbuf          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\trd           io.Reader <span class=\"comment\">// reader provided by the client</span></span><br><span class=\"line\">\tr, w         <span class=\"keyword\">int</span>       <span class=\"comment\">// buf read and write positions</span></span><br><span class=\"line\">\terr          error</span><br><span class=\"line\">\tlastByte     <span class=\"keyword\">int</span> <span class=\"comment\">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class=\"line\">\tlastRuneSize <span class=\"keyword\">int</span> <span class=\"comment\">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minReadBufferSize = <span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxConsecutiveEmptyReads = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReaderSize</span><span class=\"params\">(rd io.Reader, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Reader?</span></span><br><span class=\"line\">\tb, ok := rd.(*Reader)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt; minReadBufferSize &#123;</span><br><span class=\"line\">\t\tsize = minReadBufferSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr := <span class=\"built_in\">new</span>(Reader)</span><br><span class=\"line\">\tr.reset(<span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size), rd)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReader</span><span class=\"params\">(rd io.Reader)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any buffered data, resets all state, and switches</span></span><br><span class=\"line\"><span class=\"comment\">// the buffered reader to read from r.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Reset</span><span class=\"params\">(r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\tb.reset(b.buf, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">reset</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>, r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\t*b = Reader&#123;</span><br><span class=\"line\">\t\tbuf:          buf,</span><br><span class=\"line\">\t\trd:           r,</span><br><span class=\"line\">\t\tlastByte:     <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\tlastRuneSize: <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeRead = errors.New(<span class=\"string\">&quot;bufio: reader returned negative count from Read&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fill reads a new chunk into the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">fill</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Slide existing data to beginning.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(b.buf, b.buf[b.r:b.w])</span><br><span class=\"line\">\t\tb.w -= b.r</span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to fill full buffer&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Read new data: try a limited number of times.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := maxConsecutiveEmptyReads; i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tn, err := b.rd.Read(b.buf[b.w:])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tb.err = err</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.err = io.ErrNoProgress</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">readErr</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\terr := b.err</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Peek returns the next n bytes without advancing the reader. The bytes stop</span></span><br><span class=\"line\"><span class=\"comment\">// being valid at the next read call. If Peek returns fewer than n bytes, it</span></span><br><span class=\"line\"><span class=\"comment\">// also returns an error explaining why the read is short. The error is</span></span><br><span class=\"line\"><span class=\"comment\">// ErrBufferFull if n is larger than b&#x27;s buffer size.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Calling Peek prevents a UnreadByte or UnreadRune call from succeeding</span></span><br><span class=\"line\"><span class=\"comment\">// until the next read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Peek</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &gt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.buf[b.r:b.w], ErrBufferFull</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 0 &lt;= n &lt;= len(b.buf)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> avail := b.w - b.r; avail &lt; n &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// not enough data in buffer</span></span><br><span class=\"line\">\t\tn = avail</span><br><span class=\"line\">\t\terr = b.readErr()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b.buf[b.r : b.r+n], err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Discard skips the next n bytes, returning the number of bytes discarded.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If Discard skips fewer than n bytes, it also returns an error.</span></span><br><span class=\"line\"><span class=\"comment\">// If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without</span></span><br><span class=\"line\"><span class=\"comment\">// reading from the underlying io.Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Discard</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(discarded <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tremain := n</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tskip := b.Buffered()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tb.fill()</span><br><span class=\"line\">\t\t\tskip = b.Buffered()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip &gt; remain &#123;</span><br><span class=\"line\">\t\t\tskip = remain</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.r += skip</span><br><span class=\"line\">\t\tremain -= skip</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> remain == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n - remain, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read reads data into p.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes read into p.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes are taken from at most one Read on the underlying Reader,</span></span><br><span class=\"line\"><span class=\"comment\">// hence n may be less than len(p).</span></span><br><span class=\"line\"><span class=\"comment\">// To read exactly len(p) bytes, use io.ReadFull(b, p).</span></span><br><span class=\"line\"><span class=\"comment\">// At EOF, the count will be zero and err will be io.EOF.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Read</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn = <span class=\"built_in\">len</span>(p)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(p) &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large read, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Read directly into p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.rd.Read(p)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tb.lastByte = <span class=\"keyword\">int</span>(p[n<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// One read.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Do not use b.fill, which will loop.</span></span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tn, b.err = b.rd.Read(b.buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// copy as much as we can</span></span><br><span class=\"line\">\tn = <span class=\"built_in\">copy</span>(p, b.buf[b.r:b.w])</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadByte reads and returns a single byte.</span></span><br><span class=\"line\"><span class=\"comment\">// If no byte is available, returns an error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadByte</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := b.buf[b.r]</span><br><span class=\"line\">\tb.r++</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(c)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte unreads the last byte. Only the most recently read byte can be unread.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte returns an error if the most recent method called on the</span></span><br><span class=\"line\"><span class=\"comment\">// Reader was not a read operation. Notably, Peek is not considered a</span></span><br><span class=\"line\"><span class=\"comment\">// read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadByte</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastByte &lt; <span class=\"number\">0</span> || b.r == <span class=\"number\">0</span> &amp;&amp; b.w &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadByte</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// b.r &gt; 0 || b.w == 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.r--</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r == 0 &amp;&amp; b.w == 0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.r] = <span class=\"keyword\">byte</span>(b.lastByte)</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadRune reads a single UTF-8 encoded Unicode character and returns the</span></span><br><span class=\"line\"><span class=\"comment\">// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte</span></span><br><span class=\"line\"><span class=\"comment\">// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadRune</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">rune</span>, size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r+utf8.UTFMax &gt; b.w &amp;&amp; !utf8.FullRune(b.buf[b.r:b.w]) &amp;&amp; b.err == <span class=\"literal\">nil</span> &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr, size = <span class=\"keyword\">rune</span>(b.buf[b.r]), <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &gt;= utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\tr, size = utf8.DecodeRune(b.buf[b.r:b.w])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += size</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r, size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadRune unreads the last rune. If the most recent method called on</span></span><br><span class=\"line\"><span class=\"comment\">// the Reader was not a ReadRune, UnreadRune returns an error. (In this</span></span><br><span class=\"line\"><span class=\"comment\">// regard it is stricter than UnreadByte, which will unread the last byte</span></span><br><span class=\"line\"><span class=\"comment\">// from any read operation.)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadRune</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastRuneSize &lt; <span class=\"number\">0</span> || b.r &lt; b.lastRuneSize &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadRune</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r -= b.lastRuneSize</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that can be read from the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.w - b.r &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice pointing at the bytes in the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes stop being valid at the next read.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadSlice encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns all the data in the buffer and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.</span></span><br><span class=\"line\"><span class=\"comment\">// Because the data returned from ReadSlice will be overwritten</span></span><br><span class=\"line\"><span class=\"comment\">// by the next I/O operation, most clients should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes or ReadString instead.</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice returns err != nil if and only if line does not end in delim.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadSlice</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\ts := <span class=\"number\">0</span> <span class=\"comment\">// search start index</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Search buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ti += s</span><br><span class=\"line\">\t\t\tline = b.buf[b.r : b.r+i+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tb.r += i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Pending error?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = b.buf[b.r:b.w]</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\terr = b.readErr()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Buffer full?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\tline = b.buf</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts = b.w - b.r <span class=\"comment\">// do not rescan area we scanned before</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Handle last byte, if any.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i := <span class=\"built_in\">len</span>(line) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.lastByte = <span class=\"keyword\">int</span>(line[i])</span><br><span class=\"line\">\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadLine is a low-level line-reading primitive. Most callers should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes(&#x27;\\n&#x27;) or ReadString(&#x27;\\n&#x27;) instead or use a Scanner.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine tries to return a single line, not including the end-of-line bytes.</span></span><br><span class=\"line\"><span class=\"comment\">// If the line was too long for the buffer then isPrefix is set and the</span></span><br><span class=\"line\"><span class=\"comment\">// beginning of the line is returned. The rest of the line will be returned</span></span><br><span class=\"line\"><span class=\"comment\">// from future calls. isPrefix will be false when returning the last fragment</span></span><br><span class=\"line\"><span class=\"comment\">// of the line. The returned buffer is only valid until the next call to</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine. ReadLine either returns a non-nil line or it returns an error,</span></span><br><span class=\"line\"><span class=\"comment\">// never both.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// The text returned from ReadLine does not include the line end (&quot;\\r\\n&quot; or &quot;\\n&quot;).</span></span><br><span class=\"line\"><span class=\"comment\">// No indication or error is given if the input ends without a final line end.</span></span><br><span class=\"line\"><span class=\"comment\">// Calling UnreadByte after ReadLine will always unread the last byte read</span></span><br><span class=\"line\"><span class=\"comment\">// (possibly a character belonging to the line end) even if that byte is not</span></span><br><span class=\"line\"><span class=\"comment\">// part of the line returned by ReadLine.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadLine</span><span class=\"params\">()</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, isPrefix <span class=\"keyword\">bool</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tline, err = b.ReadSlice(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == ErrBufferFull &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Handle the case where &quot;\\r\\n&quot; straddles the buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">0</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Put the &#x27;\\r&#x27; back on buf and drop it from line.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Let the next call to ReadLine check for &quot;\\r\\n&quot;.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> b.r == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// should be unreachable</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to rewind past start of buffer&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tb.r--</span><br><span class=\"line\">\t\t\tline = line[:<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> line, <span class=\"literal\">true</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\n&#x27;</span> &#123;</span><br><span class=\"line\">\t\tdrop := <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">1</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-2</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\tdrop = <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tline = line[:<span class=\"built_in\">len</span>(line)-drop]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadBytes encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadBytes</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Use ReadSlice to look for array,</span></span><br><span class=\"line\">\t<span class=\"comment\">// accumulating full buffers.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> frag []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> full [][]<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e error</span><br><span class=\"line\">\t\tfrag, e = b.ReadSlice(delim)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">// got final fragment</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e != ErrBufferFull &#123; <span class=\"comment\">// unexpected error</span></span><br><span class=\"line\">\t\t\terr = e</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Make a copy of the buffer.</span></span><br><span class=\"line\">\t\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(frag))</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(buf, frag)</span><br><span class=\"line\">\t\tfull = <span class=\"built_in\">append</span>(full, buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Allocate new buffer to hold the full pieces and the fragment.</span></span><br><span class=\"line\">\tn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">len</span>(full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn += <span class=\"built_in\">len</span>(frag)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Copy full pieces and fragment in.</span></span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\tn = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">copy</span>(buf[n:], full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(buf[n:], frag)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> buf, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadString reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a string containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadString encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadString returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadString</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tbytes, err := b.ReadBytes(delim)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(bytes), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteTo implements io.WriterTo.</span></span><br><span class=\"line\"><span class=\"comment\">// This may make multiple calls to the Read method of the underlying Reader.</span></span><br><span class=\"line\"><span class=\"comment\">// If the underlying reader supports the WriteTo method,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying WriteTo without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">WriteTo</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn, err = b.writeBuf(w)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r, ok := b.rd.(io.WriterTo); ok &#123;</span><br><span class=\"line\">\t\tm, err := r.WriteTo(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> w, ok := w.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\tm, err := w.ReadFrom(b.rd)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r &lt; b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r &lt; b.w =&gt; buffer is not empty</span></span><br><span class=\"line\">\t\tm, err := b.writeBuf(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err == io.EOF &#123;</span><br><span class=\"line\">\t\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeWrite = errors.New(<span class=\"string\">&quot;bufio: writer returned negative count from Write&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// writeBuf writes the Reader&#x27;s buffer to the writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">writeBuf</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(<span class=\"keyword\">int64</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tn, err := w.Write(b.buf[b.r:b.w])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(errNegativeWrite)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int64</span>(n), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Writer implements buffering for an io.Writer object.</span></span><br><span class=\"line\"><span class=\"comment\">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class=\"line\"><span class=\"comment\">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class=\"line\"><span class=\"comment\">// After all data has been written, the client should call the</span></span><br><span class=\"line\"><span class=\"comment\">// Flush method to guarantee all data has been forwarded to</span></span><br><span class=\"line\"><span class=\"comment\">// the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\terr error</span><br><span class=\"line\">\tbuf []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\tn   <span class=\"keyword\">int</span></span><br><span class=\"line\">\twr  io.Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriterSize returns a new Writer whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Writer is already a Writer with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriterSize</span><span class=\"params\">(w io.Writer, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Writer?</span></span><br><span class=\"line\">\tb, ok := w.(*Writer)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tsize = defaultBufSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Writer&#123;</span><br><span class=\"line\">\t\tbuf: <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size),</span><br><span class=\"line\">\t\twr:  w,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriter returns a new Writer whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriter</span><span class=\"params\">(w io.Writer)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewWriterSize(w, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any unflushed buffered data, clears any error, and</span></span><br><span class=\"line\"><span class=\"comment\">// resets b to write its output to w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Reset</span><span class=\"params\">(w io.Writer)</span></span> &#123;</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\tb.wr = w</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Flush writes any buffered data to the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Flush</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn, err := b.wr.Write(b.buf[<span class=\"number\">0</span>:b.n])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; b.n &amp;&amp; err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = io.ErrShortWrite</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &amp;&amp; n &lt; b.n &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">copy</span>(b.buf[<span class=\"number\">0</span>:b.n-n], b.buf[n:b.n])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n -= n</span><br><span class=\"line\">\t\tb.err = err</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Available returns how many bytes are unused in the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Available</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) - b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that have been written into the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Write writes the contents of p into the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If nn &lt; len(p), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Write</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(nn <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(p) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> n <span class=\"keyword\">int</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large write, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Write directly from p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.wr.Write(p)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tn = <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\t\t\tb.n += n</span><br><span class=\"line\">\t\t\tb.Flush()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\tp = p[n:]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteByte writes a single byte.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteByte</span><span class=\"params\">(c <span class=\"keyword\">byte</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Available() &lt;= <span class=\"number\">0</span> &amp;&amp; b.Flush() != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.n] = c</span><br><span class=\"line\">\tb.n++</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteRune writes a single Unicode code point, returning</span></span><br><span class=\"line\"><span class=\"comment\">// the number of bytes written and any error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteRune</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"params\">(size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &lt; utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\terr = b.WriteByte(<span class=\"keyword\">byte</span>(r))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := b.Available()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Flush(); b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tn = b.Available()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Can only happen if buffer is silly small.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> b.WriteString(<span class=\"keyword\">string</span>(r))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsize = utf8.EncodeRune(b.buf[b.n:], r)</span><br><span class=\"line\">\tb.n += size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteString writes a string.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If the count is less than len(s), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteString</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tnn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(s) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\t\tb.n += n</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\ts = s[n:]</span><br><span class=\"line\">\t\tb.Flush()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadFrom implements io.ReaderFrom. If the underlying writer</span></span><br><span class=\"line\"><span class=\"comment\">// supports the ReadFrom method, and b has no buffered data yet,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying ReadFrom without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">ReadFrom</span><span class=\"params\">(r io.Reader)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> w, ok := b.wr.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> w.ReadFrom(r)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err1 := b.Flush(); err1 != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> n, err1</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnr := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> nr &lt; maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\tm, err = r.Read(b.buf[b.n:])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> m != <span class=\"number\">0</span> || err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnr++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nr == maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, io.ErrNoProgress</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n += m</span><br><span class=\"line\">\t\tn += <span class=\"keyword\">int64</span>(m)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If we filled the buffer exactly, flush preemptively.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\terr = b.Flush()</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered input and output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadWriter stores pointers to a Reader and a Writer.</span></span><br><span class=\"line\"><span class=\"comment\">// It implements io.ReadWriter.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*Reader</span><br><span class=\"line\">\t*Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReadWriter allocates a new ReadWriter that dispatches to r and w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReadWriter</span><span class=\"params\">(r *Reader, w *Writer)</span> *<span class=\"title\">ReadWriter</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ReadWriter&#123;r, w&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"golang","path":"api/tags/golang.json"}]},{"title":"Linux IO模式","slug":"systemstructure/linux/linuxio","date":"2021-03-25T13:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/linuxio.json","excerpt":null,"keywords":"云计算","cover":"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139551R-C.33d57d1aac13ec6a4e7f917e0a47bb69?rik=o%2fuWsKRpOPc7MA&riu=http%3a%2f%2fwww.thomas-krenn.com%2fde%2fwikiDE%2fimages%2fd%2fda%2fLinux-io-stack-diagram_v1.0.png&ehk=1OGRYIpfyG0jiVPRMEKwfpXnNXxZpCQUOMRDg4u7Pz0%3d&risl=&pid=ImgRaw&r=0","content":"<p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本文讨论的背景是Linux环境下的network IO。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"概念说明\"><a href=\"#概念说明\" class=\"headerlink\" title=\"概念说明\"></a>概念说明</h3><p>在进行解释之前，首先要说明几个概念：<br>- 用户空间和内核空间<br>- 进程切换<br>- 进程的阻塞<br>- 文件描述符<br>- 缓存 I/O</p>\n<h4 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a>用户空间与内核空间</h4><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>\n<h4 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h4><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>\n<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：<br>\\1. 保存处理机上下文，包括程序计数器和其他寄存器。<br>\\2. 更新PCB信息。<br>\\3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<br>\\4. 选择另一个进程执行，并更新其PCB。<br>\\5. 更新内存管理的数据结构。<br>\\6. 恢复处理机上下文。</p>\n<p>注：<strong>总而言之就是很耗资源</strong>，具体的可以参考这篇文章：<a href=\"http://guojing.me/linux-kernel-architecture/posts/process-switch/\">进程切换</a></p>\n<h4 id=\"进程的阻塞\"><a href=\"#进程的阻塞\" class=\"headerlink\" title=\"进程的阻塞\"></a>进程的阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p>\n<h4 id=\"文件描述符fd\"><a href=\"#文件描述符fd\" class=\"headerlink\" title=\"文件描述符fd\"></a>文件描述符fd</h4><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>\n<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>\n<h4 id=\"缓存-I-O\"><a href=\"#缓存-I-O\" class=\"headerlink\" title=\"缓存 I/O\"></a>缓存 I/O</h4><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>\n<p><strong>缓存 I/O 的缺点：</strong><br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>\n<h3 id=\"IO模式\"><a href=\"#IO模式\" class=\"headerlink\" title=\"IO模式\"></a>IO模式</h3><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：<br>\\1. 等待数据准备 (Waiting for the data to be ready)<br>\\2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p>\n<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。<br>- 阻塞 I/O（blocking IO）<br>- 非阻塞 I/O（nonblocking IO）<br>- I/O 多路复用（ IO multiplexing）<br>- 信号驱动 I/O（ signal driven IO）<br>- 异步 I/O（asynchronous IO）</p>\n<p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>\n<h4 id=\"阻塞-I-O（blocking-IO）\"><a href=\"#阻塞-I-O（blocking-IO）\" class=\"headerlink\" title=\"阻塞 I/O（blocking IO）\"></a>阻塞 I/O（blocking IO）</h4><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://segmentfault.com/img/bVm1c3\" alt=\"clipboard.png\"></p>\n<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>\n<blockquote>\n<p>  所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>\n</blockquote>\n<h4 id=\"非阻塞-I-O（nonblocking-IO）\"><a href=\"#非阻塞-I-O（nonblocking-IO）\" class=\"headerlink\" title=\"非阻塞 I/O（nonblocking IO）\"></a>非阻塞 I/O（nonblocking IO）</h4><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://segmentfault.com/img/bVm1c4\" alt=\"clipboard.png\"></p>\n<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>\n<blockquote>\n<p>  所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p>\n</blockquote>\n<h4 id=\"I-O-多路复用（-IO-multiplexing）\"><a href=\"#I-O-多路复用（-IO-multiplexing）\" class=\"headerlink\" title=\"I/O 多路复用（ IO multiplexing）\"></a>I/O 多路复用（ IO multiplexing）</h4><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://segmentfault.com/img/bVm1c5\" alt=\"clipboard.png\"></p>\n<p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>\n<blockquote>\n<p>  所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>\n</blockquote>\n<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>\n<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>\n<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>\n<h4 id=\"异步-I-O（asynchronous-IO）\"><a href=\"#异步-I-O（asynchronous-IO）\" class=\"headerlink\" title=\"异步 I/O（asynchronous IO）\"></a>异步 I/O（asynchronous IO）</h4><p>inux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139536bVm1c8\" alt=\"clipboard.png\"></p>\n<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><h5 id=\"blocking和non-blocking的区别\"><a href=\"#blocking和non-blocking的区别\" class=\"headerlink\" title=\"blocking和non-blocking的区别\"></a>blocking和non-blocking的区别</h5><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>\n<h5 id=\"synchronous-IO和asynchronous-IO的区别\"><a href=\"#synchronous-IO和asynchronous-IO的区别\" class=\"headerlink\" title=\"synchronous IO和asynchronous IO的区别\"></a>synchronous IO和asynchronous IO的区别</h5><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>- An asynchronous I/O operation does not cause the requesting process to be blocked;</p>\n<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>\n<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>\n<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>\n<p><strong>各个IO Model的比较如图所示：</strong><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139539bVm1c9\" alt=\"clipboard.png\"></p>\n<p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>\n<h3 id=\"I-O-多路复用之select、poll、epoll详解\"><a href=\"#I-O-多路复用之select、poll、epoll详解\" class=\"headerlink\" title=\"I/O 多路复用之select、poll、epoll详解\"></a>I/O 多路复用之select、poll、epoll详解</h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p>\n<h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>\n\n<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>\n<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>\n<h4 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>\n\n<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct pollfd &#123;</span><br><span class=\"line\">    int fd; &#x2F;* file descriptor *&#x2F;</span><br><span class=\"line\">    short events; &#x2F;* requested events to watch *&#x2F;</span><br><span class=\"line\">    short revents; &#x2F;* returned events witnessed *&#x2F;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>\n<blockquote>\n<p>  从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>\n</blockquote>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>\n<h5 id=\"epoll操作过程\"><a href=\"#epoll操作过程\" class=\"headerlink\" title=\"epoll操作过程\"></a>epoll操作过程</h5><p>epoll操作过程需要三个接口，分别如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int epoll_create(int size)；&#x2F;&#x2F;创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class=\"line\">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class=\"line\">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>\n\n<p><strong>1. int epoll_create(int size);</strong><br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>\n<p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong><br>函数是对指定描述符fd执行op操作。<br>- epfd：是epoll_create()的返回值。<br>- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。<br>- fd：是需要监听的fd（文件描述符）<br>- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct epoll_event &#123;</span><br><span class=\"line\">  __uint32_t events;  &#x2F;* Epoll events *&#x2F;</span><br><span class=\"line\">  epoll_data_t data;  &#x2F;* User data variable *&#x2F;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;events可以是以下几个宏的集合：</span><br><span class=\"line\">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class=\"line\">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class=\"line\">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class=\"line\">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class=\"line\">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class=\"line\">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class=\"line\">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>\n<h5 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h5><p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>\n<h6 id=\"LT模式\"><a href=\"#LT模式\" class=\"headerlink\" title=\"LT模式\"></a>LT模式</h6><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>\n<h6 id=\"ET模式\"><a href=\"#ET模式\" class=\"headerlink\" title=\"ET模式\"></a>ET模式</h6><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>\n<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h6 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h6><p><strong>假如有这样一个例子：</strong><br>\\1. 我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符<br>\\2. 这个时候从管道的另一端被写入了2KB的数据<br>\\3. 调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作<br>\\4. 然后我们读取了1KB的数据<br>\\5. 调用epoll_wait(2)……</p>\n<p><strong>LT模式：</strong><br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p>\n<p><strong>ET模式：</strong><br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>\n<p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，<br>读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(rs)&#123;</span><br><span class=\"line\">  buflen &#x3D; recv(activeevents[i].data.fd, buf, sizeof(buf), 0);</span><br><span class=\"line\">  if(buflen &lt; 0)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span><br><span class=\"line\">    &#x2F;&#x2F; 在这里就当作是该次事件已处理处.</span><br><span class=\"line\">    if(errno &#x3D;&#x3D; EAGAIN)&#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else if(buflen &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">     &#x2F;&#x2F; 这里表示对端的socket已正常关闭.</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> if(buflen &#x3D;&#x3D; sizeof(buf)&#123;</span><br><span class=\"line\">      rs &#x3D; 1;   &#x2F;&#x2F; 需要再次读取</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> else&#123;</span><br><span class=\"line\">      rs &#x3D; 0;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  <strong>Linux中的EAGAIN含义</strong></p>\n</blockquote>\n<p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p>\n<p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p>\n<h5 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h5><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define IPADDRESS   &quot;127.0.0.1&quot;</span><br><span class=\"line\">#define PORT        8787</span><br><span class=\"line\">#define MAXSIZE     1024</span><br><span class=\"line\">#define LISTENQ     5</span><br><span class=\"line\">#define FDSIZE      1000</span><br><span class=\"line\">#define EPOLLEVENTS 100</span><br><span class=\"line\"></span><br><span class=\"line\">listenfd &#x3D; socket_bind(IPADDRESS,PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">struct epoll_event events[EPOLLEVENTS];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;创建一个描述符</span><br><span class=\"line\">epollfd &#x3D; epoll_create(FDSIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;添加监听描述符事件</span><br><span class=\"line\">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;循环等待</span><br><span class=\"line\">for ( ; ; )&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;该函数返回已经准备好的描述符事件数目</span><br><span class=\"line\">    ret &#x3D; epoll_wait(epollfd,events,EPOLLEVENTS,-1);</span><br><span class=\"line\">    &#x2F;&#x2F;处理接收到的连接</span><br><span class=\"line\">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;事件处理函数</span><br><span class=\"line\">static void handle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     int i;</span><br><span class=\"line\">     int fd;</span><br><span class=\"line\">     &#x2F;&#x2F;进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span><br><span class=\"line\">     for (i &#x3D; 0;i &lt; num;i++)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         fd &#x3D; events[i].data.fd;</span><br><span class=\"line\">        &#x2F;&#x2F;根据描述符的类型和事件类型进行处理</span><br><span class=\"line\">         if ((fd &#x3D;&#x3D; listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class=\"line\">            handle_accpet(epollfd,listenfd);</span><br><span class=\"line\">         else if (events[i].events &amp; EPOLLIN)</span><br><span class=\"line\">            do_read(epollfd,fd,buf);</span><br><span class=\"line\">         else if (events[i].events &amp; EPOLLOUT)</span><br><span class=\"line\">            do_write(epollfd,fd,buf);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;添加事件</span><br><span class=\"line\">static void add_event(int epollfd,int fd,int state)&#123;</span><br><span class=\"line\">    struct epoll_event ev;</span><br><span class=\"line\">    ev.events &#x3D; state;</span><br><span class=\"line\">    ev.data.fd &#x3D; fd;</span><br><span class=\"line\">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;处理接收到的连接</span><br><span class=\"line\">static void handle_accpet(int epollfd,int listenfd)&#123;</span><br><span class=\"line\">     int clifd;     </span><br><span class=\"line\">     struct sockaddr_in cliaddr;     </span><br><span class=\"line\">     socklen_t  cliaddrlen;     </span><br><span class=\"line\">     clifd &#x3D; accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class=\"line\">     if (clifd &#x3D;&#x3D; -1)         </span><br><span class=\"line\">     perror(&quot;accpet error:&quot;);     </span><br><span class=\"line\">     else &#123;         </span><br><span class=\"line\">         printf(&quot;accept a new client: %s:%d\\n&quot;,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       &#x2F;&#x2F;添加一个客户描述符和事件         </span><br><span class=\"line\">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;读处理</span><br><span class=\"line\">static void do_read(int epollfd,int fd,char *buf)&#123;</span><br><span class=\"line\">    int nread;</span><br><span class=\"line\">    nread &#x3D; read(fd,buf,MAXSIZE);</span><br><span class=\"line\">    if (nread &#x3D;&#x3D; -1)     &#123;         </span><br><span class=\"line\">        perror(&quot;read error:&quot;);         </span><br><span class=\"line\">        close(fd); &#x2F;&#x2F;记住close fd        </span><br><span class=\"line\">        delete_event(epollfd,fd,EPOLLIN); &#x2F;&#x2F;删除监听 </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (nread &#x3D;&#x3D; 0)     &#123;         </span><br><span class=\"line\">        fprintf(stderr,&quot;client close.\\n&quot;);</span><br><span class=\"line\">        close(fd); &#x2F;&#x2F;记住close fd       </span><br><span class=\"line\">        delete_event(epollfd,fd,EPOLLIN); &#x2F;&#x2F;删除监听 </span><br><span class=\"line\">    &#125;     </span><br><span class=\"line\">    else &#123;         </span><br><span class=\"line\">        printf(&quot;read message is : %s&quot;,buf);        </span><br><span class=\"line\">        &#x2F;&#x2F;修改描述符对应的事件，由读改为写         </span><br><span class=\"line\">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;写处理</span><br><span class=\"line\">static void do_write(int epollfd,int fd,char *buf) &#123;     </span><br><span class=\"line\">    int nwrite;     </span><br><span class=\"line\">    nwrite &#x3D; write(fd,buf,strlen(buf));     </span><br><span class=\"line\">    if (nwrite &#x3D;&#x3D; -1)&#123;         </span><br><span class=\"line\">        perror(&quot;write error:&quot;);        </span><br><span class=\"line\">        close(fd);   &#x2F;&#x2F;记住close fd       </span><br><span class=\"line\">        delete_event(epollfd,fd,EPOLLOUT);  &#x2F;&#x2F;删除监听    </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    memset(buf,0,MAXSIZE); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;删除事件</span><br><span class=\"line\">static void delete_event(int epollfd,int fd,int state) &#123;</span><br><span class=\"line\">    struct epoll_event ev;</span><br><span class=\"line\">    ev.events &#x3D; state;</span><br><span class=\"line\">    ev.data.fd &#x3D; fd;</span><br><span class=\"line\">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;修改事件</span><br><span class=\"line\">static void modify_event(int epollfd,int fd,int state)&#123;     </span><br><span class=\"line\">    struct epoll_event ev;</span><br><span class=\"line\">    ev.events &#x3D; state;</span><br><span class=\"line\">    ev.data.fd &#x3D; fd;</span><br><span class=\"line\">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;注：另外一端我就省了</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"epoll总结\"><a href=\"#epoll总结\" class=\"headerlink\" title=\"epoll总结\"></a>epoll总结</h5><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p>\n<p><strong>epoll的优点主要是一下几个方面：</strong><br>\\1. 监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>\n<ol>\n<li> IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>\n</ol>\n<blockquote>\n<p>  如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p>\n</blockquote>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139551R-C.33d57d1aac13ec6a4e7f917e0a47bb69?rik=o/uWsKRpOPc7MA&riu=http://www.thomas-krenn.com/de/wikiDE/images/d/da/Linux-io-stack-diagram_v1.0.png&ehk=1OGRYIpfyG0jiVPRMEKwfpXnNXxZpCQUOMRDg4u7Pz0=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/Anker/p/3269106.html\">用户空间与内核空间，进程上下文与中断上下文总结]</a><br><a href=\"http://guojing.me/linux-kernel-architecture/posts/process-switch/\">进程切换</a><br><a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">维基百科-文件描述符</a><br><a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-directio/\">Linux 中直接 I/O 机制的介绍</a><br><a href=\"http://blog.csdn.net/historyasamirror/article/details/5778378\">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a><br><a href=\"http://www.cnblogs.com/bigwangdi/p/3182958.html\">Linux中select poll和epoll的区别</a><br><a href=\"http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html\">IO多路复用之select总结</a><br><a href=\"http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html\">IO多路复用之poll总结</a><br><a href=\"http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html\">IO多路复用之epoll总结</a></p>\n","raw":null,"categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]}]}