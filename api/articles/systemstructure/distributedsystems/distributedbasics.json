{"title":"三分钟入门分布式系统","slug":"systemstructure/distributedsystems/distributedbasics","date":"2021-06-25T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/distributedsystems/distributedbasics.json","excerpt":null,"covers":null,"content":"<p>[toc]</p>\n<h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>为了完成共同的任务，通过某种通信方式(一般是网络)使用多个计算机节点。这个由多个计算节点组成的系统就是分布式系统。通俗来说就是使用更多机器来处理问题，其实我们的互联网就是一个分布式系统。</p>\n<h2 id=\"为什么要使用分布式系统\"><a href=\"#为什么要使用分布式系统\" class=\"headerlink\" title=\"为什么要使用分布式系统\"></a>为什么要使用分布式系统</h2><p>单节点计算、存储能力弱，硬件提升性价比低，应用消耗资源过于高时；要实现高可用、高并发时；可以无限的横向扩展</p>\n<h2 id=\"如何实现分布式\"><a href=\"#如何实现分布式\" class=\"headerlink\" title=\"如何实现分布式\"></a>如何实现分布式</h2><p>简单来说就是对任务分而治之(贯穿整个计算机上下的底层思想，而且来源于生活)，即是分片(partition),把不同分片交给不同节点处理即可，在未来保证可用性与并发性时，我们将分片冗余处理(一个分片交给多个节点处理)</p>\n<h2 id=\"CAP定理\"><a href=\"#CAP定理\" class=\"headerlink\" title=\"CAP定理\"></a>CAP定理</h2><p>定理指的是一个经过逻辑证明的猜想；2000年布鲁尔提出此猜想2002年MIT的大佬给出证明</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>CAP定理指出一个分布式系统不能同时满足一下三点</p>\n<ul>\n<li>一致性(Consistency)所有节点访问同一份最新的数据副本</li>\n<li>可用性(Availability)每次请求都能获取到非错的响应</li>\n<li>分区容错性(Partition tolerance)一个分布式系统中出现故障导致分裂成多个计算节点（区）；这些区应能使系统正常运行，一般来说P应该一定要满足的，弱不满足那么就违背了分布式系统初衷</li>\n</ul>\n<h3 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h3><p>CAP只能三选二，那么我们就有三种策略，我们看一下有哪些情况会用到</p>\n<p>CA：放弃P，会导致分布式节点无法进行扩展，传统的关系型数据库就是如此，一般P是必选项</p>\n<p>CP：牺牲用户体验，常见分布式数据库以及银行系统就是</p>\n<p>AP：牺牲一致性，淘宝、12306等就是</p>\n<h2 id=\"BASE理论\"><a href=\"#BASE理论\" class=\"headerlink\" title=\"BASE理论\"></a>BASE理论</h2><p>为平衡CAP提出，包含</p>\n<p>基本可用(Basically Available): 在出现故障时，允许部分可用性（基础可用）</p>\n<p>软状态(Soft State):允许出现中间状态，不同节点之间数据不一致</p>\n<p>最终一致性(Eventual Consistency):软状态不可持续，在有限期限后应能保证数据的最终一致</p>\n<h2 id=\"一致性算法\"><a href=\"#一致性算法\" class=\"headerlink\" title=\"一致性算法\"></a>一致性算法</h2><p>后续文章会详细介绍这些算法</p>\n<h3 id=\"强一致性算法\"><a href=\"#强一致性算法\" class=\"headerlink\" title=\"强一致性算法\"></a>强一致性算法</h3><p>Paxos：我最喜欢的图灵奖获得者Leslie Lamport于90年提出，几乎所有强一致性算法鼻祖，后续文章会详细介绍</p>\n<p>Raft(Paxos变种)：etcd使用</p>\n<p>ZAB(Paxos变种)：ZooKeeper使用</p>\n<h3 id=\"最终一致性算法\"><a href=\"#最终一致性算法\" class=\"headerlink\" title=\"最终一致性算法\"></a>最终一致性算法</h3><p>DNS系统：域名解析，超过TTL逐步向上询问</p>\n<p>Gossip算法：逆熵算法，Cassandra中使用</p>\n<h2 id=\"不要做那些假设\"><a href=\"#不要做那些假设\" class=\"headerlink\" title=\"不要做那些假设\"></a>不要做那些假设</h2><p>还记得我们前几天发的极客法则吗，不要做以下假设，在实际生产上会遇到不同问题需要实际处理</p>\n<ul>\n<li>网络可靠</li>\n<li>延迟为零</li>\n<li>带宽无限</li>\n<li>网络安全</li>\n<li>拓扑恒定</li>\n<li>单一管理员</li>\n<li>运输成本为零</li>\n<li>网络为同构的</li>\n</ul>\n","more":"<p>[toc]</p>\n<h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>为了完成共同的任务，通过某种通信方式(一般是网络)使用多个计算机节点。这个由多个计算节点组成的系统就是分布式系统。通俗来说就是使用更多机器来处理问题，其实我们的互联网就是一个分布式系统。</p>\n<h2 id=\"为什么要使用分布式系统\"><a href=\"#为什么要使用分布式系统\" class=\"headerlink\" title=\"为什么要使用分布式系统\"></a>为什么要使用分布式系统</h2><p>单节点计算、存储能力弱，硬件提升性价比低，应用消耗资源过于高时；要实现高可用、高并发时；可以无限的横向扩展</p>\n<h2 id=\"如何实现分布式\"><a href=\"#如何实现分布式\" class=\"headerlink\" title=\"如何实现分布式\"></a>如何实现分布式</h2><p>简单来说就是对任务分而治之(贯穿整个计算机上下的底层思想，而且来源于生活)，即是分片(partition),把不同分片交给不同节点处理即可，在未来保证可用性与并发性时，我们将分片冗余处理(一个分片交给多个节点处理)</p>\n<h2 id=\"CAP定理\"><a href=\"#CAP定理\" class=\"headerlink\" title=\"CAP定理\"></a>CAP定理</h2><p>定理指的是一个经过逻辑证明的猜想；2000年布鲁尔提出此猜想2002年MIT的大佬给出证明</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>CAP定理指出一个分布式系统不能同时满足一下三点</p>\n<ul>\n<li>一致性(Consistency)所有节点访问同一份最新的数据副本</li>\n<li>可用性(Availability)每次请求都能获取到非错的响应</li>\n<li>分区容错性(Partition tolerance)一个分布式系统中出现故障导致分裂成多个计算节点（区）；这些区应能使系统正常运行，一般来说P应该一定要满足的，弱不满足那么就违背了分布式系统初衷</li>\n</ul>\n<h3 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h3><p>CAP只能三选二，那么我们就有三种策略，我们看一下有哪些情况会用到</p>\n<p>CA：放弃P，会导致分布式节点无法进行扩展，传统的关系型数据库就是如此，一般P是必选项</p>\n<p>CP：牺牲用户体验，常见分布式数据库以及银行系统就是</p>\n<p>AP：牺牲一致性，淘宝、12306等就是</p>\n<h2 id=\"BASE理论\"><a href=\"#BASE理论\" class=\"headerlink\" title=\"BASE理论\"></a>BASE理论</h2><p>为平衡CAP提出，包含</p>\n<p>基本可用(Basically Available): 在出现故障时，允许部分可用性（基础可用）</p>\n<p>软状态(Soft State):允许出现中间状态，不同节点之间数据不一致</p>\n<p>最终一致性(Eventual Consistency):软状态不可持续，在有限期限后应能保证数据的最终一致</p>\n<h2 id=\"一致性算法\"><a href=\"#一致性算法\" class=\"headerlink\" title=\"一致性算法\"></a>一致性算法</h2><p>后续文章会详细介绍这些算法</p>\n<h3 id=\"强一致性算法\"><a href=\"#强一致性算法\" class=\"headerlink\" title=\"强一致性算法\"></a>强一致性算法</h3><p>Paxos：我最喜欢的图灵奖获得者Leslie Lamport于90年提出，几乎所有强一致性算法鼻祖，后续文章会详细介绍</p>\n<p>Raft(Paxos变种)：etcd使用</p>\n<p>ZAB(Paxos变种)：ZooKeeper使用</p>\n<h3 id=\"最终一致性算法\"><a href=\"#最终一致性算法\" class=\"headerlink\" title=\"最终一致性算法\"></a>最终一致性算法</h3><p>DNS系统：域名解析，超过TTL逐步向上询问</p>\n<p>Gossip算法：逆熵算法，Cassandra中使用</p>\n<h2 id=\"不要做那些假设\"><a href=\"#不要做那些假设\" class=\"headerlink\" title=\"不要做那些假设\"></a>不要做那些假设</h2><p>还记得我们前几天发的极客法则吗，不要做以下假设，在实际生产上会遇到不同问题需要实际处理</p>\n<ul>\n<li>网络可靠</li>\n<li>延迟为零</li>\n<li>带宽无限</li>\n<li>网络安全</li>\n<li>拓扑恒定</li>\n<li>单一管理员</li>\n<li>运输成本为零</li>\n<li>网络为同构的</li>\n</ul>\n","categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"分布式","path":"api/tags/分布式.json"}]}