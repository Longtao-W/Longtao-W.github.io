{"title":"计算机启动到操作系统运行","slug":"systemstructure/linux/bootofcomputer","date":"2020-04-25T12:13:31.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/bootofcomputer.json","excerpt":null,"covers":["https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139328640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1","https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139335949069-20190421160331677-268089991.png","https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351393421635139306R-C.81d56db1bef63aa01cbba73b33caedf3?rik=3YtNM7LX/wHS5Q&riu=http://www.linuxidc.com/upload/2016_06/160617100110611.png&ehk=0SHzV/qNHRE7jk8jqfwwge4teKMqurNw7sM4KipqkaA=&risl=&pid=ImgRaw&r=0"],"content":"<p>首先学一个东西，一定要有一个<strong>前置</strong>的知识，我们把它当做已知的，我不可能从原子组成分子开始讲原理。那学习计算机启动过程的前置知识是什么呢？我要求你已知以下几点：</p>\n<ol>\n<li>内存是存储数据的地方，给出一个地址信号，内存可以返回该地址所对应的数据。</li>\n<li>CPU 的工作方式就是不断从内存中取出指令，并执行。</li>\n<li>CPU 从内存的哪个地址取出指令，是由一个寄存器中的值决定的，这个值会不断进行 +1 操作，或者由某条跳转指令指定其值是多少。</li>\n</ol>\n<p>好了，只需要知道这三点<strong>前置</strong>知识，你就能专业地解释计算机的启动过程了。</p>\n<h2 id=\"一、为什么是-BIOS-主导？\"><a href=\"#一、为什么是-BIOS-主导？\" class=\"headerlink\" title=\"一、为什么是 BIOS 主导？\"></a>一、为什么是 BIOS 主导？</h2><p>都说开机后，BIOS 就开始运行自己的程序了，又硬件自检，又加载启动区的。我就不服了，为什么开机后是执行 BIOS 里的程序？为啥不是内存里的？为啥不是硬盘里的？</p>\n<p>好的，不要怀疑前置知识，CPU 的工作方式，就是不断从内存中取指令并执行，那为什么会说是执行 BIOS 里的程序呢？这就不得不说说<strong>内存映射</strong>了。</p>\n<h2 id=\"二、内存映射\"><a href=\"#二、内存映射\" class=\"headerlink\" title=\"二、内存映射\"></a>二、内存映射</h2><p><strong>CPU 地址总线的宽度决定了可访问的内存空间的大小</strong>。比如 16 位的 CPU 地址总线宽度为 20 位，地址范围是 1M。32 位的 CPU 地址总线宽度为 32 位，地址范围是 4G。你可以算算我们现在的 64 位机的地址范围。</p>\n<p>可是，可访问的内存空间这么大，并不等于说全都给内存使用，也就是说寻址的对象不只有内存，还有一些外设也要通过地址总线的方式去访问，那怎么去访问这些外设呢？就是在地址范围中划出一片片的区域，这块给显存使用，那块给硬盘控制器使用，等等 。</p>\n<p>这样说，其实就不符合我们的前置知识了，所以可以有一种不太正确的理解方式，那就是内存中的这块位置就是显存，那块位置就是硬盘控制器。我们在相应的位置上读取或者写入，就相当于在显存等外设的相应位置上读取或者写入，就好像这些外设的存储区域，被<strong>映射</strong>到了内存中的某一片区域一样。这样我们就不用管那些外设啦，关注点仍然是一个简简单单的内存。这就是所谓的<strong>内存映射</strong>。</p>\n<p>太好了，现在又用简单的前置知识就能解释得通了，我们继续往下推。</p>\n<h2 id=\"三、实模式下的内存分布\"><a href=\"#三、实模式下的内存分布\" class=\"headerlink\" title=\"三、实模式下的内存分布\"></a>三、实模式下的内存分布</h2><p>刚刚说到内存中划分出了一片一片区域给各种外设，那么问题自然就来了，哪块区域，分给了哪块外设了呢？如果是规定，那应该有一张表比较好吧。嗯没错，还真有，它就是实模式下的内存分布，笔者给它画了一张图：</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139328640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">在这里插入图片描述</p>\n<p>哎哟我真是个小天使，把比例都表现出来了，网上能再找出比我这个更直观的请给我留言。实模式之后再解释，现在简单理解就是计算机刚开机的时候只有 1M 的内存可用。</p>\n<p>我们看到，内存被各种外设瓜分了，即映射在了内存中。BIOS 更狠，不但其空间被映射到了内存 0xC0000 - 0xFFFFF 位置，其里面的程序还占用了开头的一些区域，比如把中断向量表写在了内存开始的位置，真所谓先到先得啊。</p>\n<h2 id=\"四、怎么就从-BIOS-里的程序开始执行了\"><a href=\"#四、怎么就从-BIOS-里的程序开始执行了\" class=\"headerlink\" title=\"四、怎么就从 BIOS 里的程序开始执行了\"></a>四、怎么就从 BIOS 里的程序开始执行了</h2><p>好了，现在我们知道 BIOS 里的信息被映射到了内存 0xC0000 - 0xFFFFF 位置，其中最为关键的系统 BIOS 被映射到了 0xF0000 - 0xFFFFF 位置。假如我现在说，CPU 开机就是执行了这块区域的代码，然后巴拉巴拉一顿操作就开机了，你肯定要喷我了，为什么就执行到这了呢，那咋不从头开始执行？</p>\n<p>这就自然有了一种猜想，我们要用到另一个前置知识了，就是 CPU 从内存的哪个位置取出执行并执行呢？<strong>是 PC 寄存器中的地址值</strong>。BIOS 程序的入口地址也就是开始地址是 0xFFFF0（人家就那么写的），也就是开机键一按下，一定有一个神奇的力量，将 pc 寄存器中的值变成 0xFFFF0，然后 CPU 就开始马不停蹄地跑了起来。没错，接下来这句话，可能就是你找了很久的答案，请做好准备：</p>\n<p><strong>在你开机的一瞬间，CPU 的 PC 寄存器被强制初始化为 0xFFFF0</strong>。如果再说具体些，CPU 将段基址寄存器 cs 初始化为 0xF000，将偏移地址寄存器 IP 初始化为 0xFFF0，根据实模式下的最终地址计算规则，将段基址左移 4 位，加上偏移地址，得到最终的物理地址也就是抽象出来的 PC 寄存器地址为 0xFFFF0。</p>\n<p>当我在学习这段知识时，看到这句话才让将我心里积压了很久的疑惑解开，多么简单粗暴的道理啊。写到这里我也是长舒了一口气，因为剩下的过程，就几乎只是流水账一样的正推了。</p>\n<p>至于怎么强制初始化的，我觉得就越过了前置知识的边界了，况且各个厂商的硬件实现也不一定相同，有很多办法，也很简单。讨论起来意义就不大了。</p>\n<h2 id=\"五、BIOS-里到底写了什么程序\"><a href=\"#五、BIOS-里到底写了什么程序\" class=\"headerlink\" title=\"五、BIOS 里到底写了什么程序\"></a>五、BIOS 里到底写了什么程序</h2><p>好了，我们现在知道了 BIOS 被映射到了内存的某个位置，并且开机一瞬间 CPU 强制将自己的 pc 寄存器初始化为 BIOS 程序的入口地址，从这里开始 CPU 马不停蹄地向前跑了起来。那接下来的问题似乎也非常自然地就问出来了，那就是 BIOS 程序里到底写了啥？</p>\n<p>把 BIOS 程序里的二进制信息全贴出来也不合适，我们分析一些主要的。我们首先还是来猜测，你看入口地址是 0xFFFF0，说明程序是从这执行的。实模式下内存的下边界就是 0xFFFFF，也就是只剩下 16 个字节的空间可以写代码了，这够干啥的呢？如果你有心的话应该能猜出，入口地址处可能是个跳转指令，跳到一个更大范围的空间去执行自己的任务。没错就是这样，0xFFFF0 处存储的机器指令，翻译成汇编语言是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp far f000:e05b</span><br></pre></td></tr></table></figure>\n\n<p>意思是跳转到物理地址 0xfe05b 处开始执行（回忆下前面说的实模式下的地址计算方式）。</p>\n<p>地址 0xfe05b 处开始，便是 BIOS 真正发挥作用的代码了，这块代码会检测一些外设信息，并初始化好硬件，建立中断向量表并填写中断例程。这里的部分不要展开，这只是一段写死的程序而已，而且对理解开机启动过程无帮助，我们看后面精彩的部分，也就是 BIOS 的最后一项工作：<strong>加载启动区</strong>。</p>\n<h2 id=\"六、0x7c00-是啥\"><a href=\"#六、0x7c00-是啥\" class=\"headerlink\" title=\"六、0x7c00 是啥\"></a>六、0x7c00 是啥</h2><p>该较真的地方就是要较真，我绝对不会让<strong>加载</strong>这种魔幻的词出现在这里，我们现在就来把它拆解成人话。</p>\n<p>其实这个词也并不魔幻，加载在计算机领域就是指，<strong>把某设备上（比如硬盘）的程序复制到内存中的过程</strong>。那加载启动区这个过程，翻译过来就是，<strong>BIOS 程序把启动区的内容复制到了内存中的某个区域</strong>。好了，问题又自然出来了，启动区是哪里？被复制到了内存的哪个位置？然后呢？我们一个个来回答。</p>\n<p>什么是启动区呢？即使你不知道，你也应该能够猜到，一定是符合某种特征的一块区域，于是人们把它就叫做启动区了，那要符合什么特征呢？先不急，不知道你有没有过设置 BIOS 启动顺序的经历，通常有 U 盘启动、硬盘启动、软盘启动、光盘启动等等，<strong>BIOS 会按照顺序，读取这些启动盘中位于 0 盘 0 道 1 扇区的内容</strong>。</p>\n<p>至于磁盘格式的划分，本篇就不做讲解了，总之对于内存，我们给出一个数字地址就能获取到该地址的数据，而对于磁盘，我们需要给出磁头、柱面、扇区这三个信息才能定位某个位置的数据，都是描述位置的一种方式而已。</p>\n<p>接着说， 这 0 盘 0 道 1 扇区的内容一共有 512 个字节，<strong>如果末尾的两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区</strong>。如果不是，那么按顺序继续向下个设备中寻找位于 0 盘 0 道 1 扇区的内容。如果最后发现都没找到符合条件的，那直接报出一个无启动区的错误。</p>\n<p>BIOS 找到了这个启动区之后干嘛呢？哦，前面说过了是加载，<strong>就是把这 512 个字节的内容，一个比特都不少的全部复制到内存的 0x7c00 这个位置</strong>。怎么复制的？当然是指令啦。哪些指令呢？这里我只能简单说指令集中是有 in 和 out 的，用来将外设中的数据复制到内存，或者将内存中的数据复制到外设，用这两个指令，以及外设给我们提供的读取方式，就能做到这一点啦。</p>\n<p>启动区内容此时已经被 BIOS 程序复制到了内存的 0x7c00 这个位置，然后呢？这个其实也不难猜测，启动区的内容就是我们自己写的代码了，复制到这里之后，就开始执行呗，之后我们的程序就接管了接下来的流程，BIOS 的使命也就结束啦。所以复制完之后，接下来应该是一个跳转指令吧！没错，正是这样，PC 寄存器的值变为 0x7c00，指令开始从这里执行。</p>\n<p>咦？不知道你有没有发现，我们似乎不知不觉又把之前的一句魔法语言翻译成人话了，开头我们说：</p>\n<blockquote>\n<p>BIOS 把控制权转交给排在第一位的存储设备。</p>\n</blockquote>\n<p>所以这句话是什么意思呢？<strong>就是 BIOS 把启动区的 512 字节复制到内存的 0x7c00 位置，并且用一条跳转指令将 pc 寄存器的值指向 0x7c00</strong>。你看，这不是也没多几个字嘛，就把这个问题说得明明白白，简简单单。</p>\n<p>哦，对了，现在似乎就剩下一个问题了，为什么非要是 0x7c00 呢？好问题，当然答案也很简单，那就是人家 BIOS 开发团队就是这样定的，之后也不好改了，不然不兼容。为什么不好改？我们看一个简单的启动区 512 字节的代码。（代码摘抄自《30 天自制操作系统》）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; hello-os</span><br><span class=\"line\">; TAB&#x3D;4</span><br><span class=\"line\"></span><br><span class=\"line\">  ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置</span><br><span class=\"line\"></span><br><span class=\"line\">;程序主体</span><br><span class=\"line\"></span><br><span class=\"line\">entry:</span><br><span class=\"line\">  MOV  AX,0   ;初始化寄存器</span><br><span class=\"line\">  MOV  SS,AX</span><br><span class=\"line\">  MOV  SP,0x7c00</span><br><span class=\"line\">  MOV  DS,AX   ;段寄存器初始化为 0</span><br><span class=\"line\">  MOV  ES,AX</span><br><span class=\"line\">  MOV  SI,msg</span><br><span class=\"line\">putloop:</span><br><span class=\"line\">  MOV  AL,[SI]</span><br><span class=\"line\">  ADD  SI,1</span><br><span class=\"line\">  CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符</span><br><span class=\"line\">  JE  fin</span><br><span class=\"line\">  MOV  AH,0x0e   ;指定文字</span><br><span class=\"line\">  MOV  BX,15   ;指定颜色</span><br><span class=\"line\">  INT  0x10   ;调用 BIOS 显示字符函数</span><br><span class=\"line\">  JMP  putloop</span><br><span class=\"line\">fin:</span><br><span class=\"line\">  HLT</span><br><span class=\"line\">  JMP  fin</span><br><span class=\"line\">msg:</span><br><span class=\"line\">  DB  0x0a,0x0a  ;换行、换行</span><br><span class=\"line\">  DB  &quot;hello-os&quot;</span><br><span class=\"line\">  DB  0x0a   ;换行</span><br><span class=\"line\">  DB  0    ;0 结尾</span><br><span class=\"line\"></span><br><span class=\"line\">  RESB 0x7dfe-$   ;填充0到512字节</span><br><span class=\"line\">  DB 0x55, 0xaa   ;可启动设备标识</span><br></pre></td></tr></table></figure>\n\n<p>我们看第一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ORG  0x7c00</span><br></pre></td></tr></table></figure>\n\n<p>这个数字就是刚刚说的启动区加载位置，这行汇编代码简单说就表示把下面的地址统统加上 0x7c00。正因为 BIOS 将启动区的代码加载到了这里，因此有了一个偏移量，所以所有写启动区代码的人就需要在开头写死一个这样的代码，不然全都串位了。</p>\n<p>然后正因为所有写操作系统的，启动区的第一行汇编代码都写死了这个数字，那 BIOS 开发者最初定的这个数字就不好改了，否则它得挨个联系各个操作系统的开发厂商，说唉我这个地址改一下哈，你们跟着改改。在公司推动另一个团队改个代码都得大费周折，想想看这样的推动得耗费多大人力。况且即使改了，之前的代码也都不兼容了，这不得被人们骂死啊。</p>\n<p>再看最后一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DB 0x55, 0xaa</span><br></pre></td></tr></table></figure>\n\n<p>这也验证了我们之前说的这 512 字节的最后两个字节得是 0x55 0xaa，BIOS 才会认为它是一个启动区，才会去加载它，仅此而已。</p>\n<p>回过头来说 0x7c00 这个值，它其实就是一个规定死的值，但还是会有人问，那必然有它的合理性吧。其实，我的解释也只能说是人家规定了这个值，后人们替他们解释这个合理性，并不是说当初人家就一定是这样想的，就好比我们做语文的阅读理解题一样。</p>\n<p>第一个 BIOS 开发团队是 IBM PC 5150 BIOS，当时被认为的第一个操作系统是 DOS 1.0 操作系统，BIOS 团队就假设是为它服务的。但操作系统还没出，BIOS 团队假设其操作系统需要的最小内存为 32 KB。BIOS 希望自己所加载的启动区代码尽量靠后，这样比较“安全”，不至于过早的被其他程序覆盖掉。可是如果仅仅留 512 字节又感觉太悬了，还有一些栈空间需要预留，那扩大到 1 KB 吧。这样 32 KB 的末尾是 0x8000，减去 1KB(0x400) ，刚好等于 0x7c00。哇塞，太精准了，这可以是一种解释方式。</p>\n<h2 id=\"七、启动区里的代码写了啥\"><a href=\"#七、启动区里的代码写了啥\" class=\"headerlink\" title=\"七、启动区里的代码写了啥\"></a>七、启动区里的代码写了啥</h2><p>其实写到这，我这篇文章就应该戛然而止了，因为最初的那个问题已经解决了，CPU 已经开始马不停蹄地从我们预期的位置跑起来了，万事开头难，剩下的内容，就是操作系统想怎么玩就怎么玩了。</p>\n<p>但我觉得还不够味，似乎还有些问题萦绕在你脑海里。比如说这个问题：</p>\n<blockquote>\n<p>启动区里的代码写了啥？就 512 字节就是全部操作系统内容了？</p>\n</blockquote>\n<p>这是一个好问题，512 个字节确实干不了啥，现在的操作系统怎么也得按 M 为单位算吧，512 个字节远远不够呢，那是怎么回事呢？</p>\n<p>其实我们可以按照之前的思路猜测，BIOS 用很少的代码就把 512 字节的启动区内容加载到了内存，并跳转过去开始执行。那按照这个套路，这 512 字节的启动区代码，是不是也可以把更多磁盘中存储的操作系统程序，加载到内存的某个位置，然后跳转过去呢？</p>\n<p>没错，就是这个套路。<strong>所以 BIOS 负责加载了启动区，而启动区又负责加载真正的操作系统内核</strong>，这配合默契吧？</p>\n<p>由于用于启动盘的磁盘是人家写操作系统的厂商制作的，俗称制作启动盘，所以他也肯定知道操作系统的核心代码存储在磁盘的哪个扇区，因此启动区就把这个扇区，以及之后的好多好多扇区（具体取决于操作系统有多大）都读到内存中，然后跳转到开始的程序开始的位置。跳转到哪里呢？这个就不像 0x7c00 这个数那么经典了，不同的操作系统肯定也不一样，也不用事先规定好，反正写操作系统的人给自己定一个就好了，别覆盖其他关键设备用到的区域就好。</p>\n<h2 id=\"八、操作系统内核写了啥\"><a href=\"#八、操作系统内核写了啥\" class=\"headerlink\" title=\"八、操作系统内核写了啥\"></a>八、操作系统内核写了啥</h2><p>好了现在经过好几轮跳跳跳，终于跳到内核代码啦，我们来一起回顾一下：</p>\n<ol>\n<li>按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址（一跳）</li>\n<li>该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）</li>\n<li>执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）</li>\n<li>启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）</li>\n</ol>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139335949069-20190421160331677-268089991.png\" alt=\"img\"></p>\n<h1 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h1><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351393421635139306R-C.81d56db1bef63aa01cbba73b33caedf3?rik=3YtNM7LX/wHS5Q&riu=http://www.linuxidc.com/upload/2016_06/160617100110611.png&ehk=0SHzV/qNHRE7jk8jqfwwge4teKMqurNw7sM4KipqkaA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","more":"<p>首先学一个东西，一定要有一个<strong>前置</strong>的知识，我们把它当做已知的，我不可能从原子组成分子开始讲原理。那学习计算机启动过程的前置知识是什么呢？我要求你已知以下几点：</p>\n<ol>\n<li>内存是存储数据的地方，给出一个地址信号，内存可以返回该地址所对应的数据。</li>\n<li>CPU 的工作方式就是不断从内存中取出指令，并执行。</li>\n<li>CPU 从内存的哪个地址取出指令，是由一个寄存器中的值决定的，这个值会不断进行 +1 操作，或者由某条跳转指令指定其值是多少。</li>\n</ol>\n<p>好了，只需要知道这三点<strong>前置</strong>知识，你就能专业地解释计算机的启动过程了。</p>\n<h2 id=\"一、为什么是-BIOS-主导？\"><a href=\"#一、为什么是-BIOS-主导？\" class=\"headerlink\" title=\"一、为什么是 BIOS 主导？\"></a>一、为什么是 BIOS 主导？</h2><p>都说开机后，BIOS 就开始运行自己的程序了，又硬件自检，又加载启动区的。我就不服了，为什么开机后是执行 BIOS 里的程序？为啥不是内存里的？为啥不是硬盘里的？</p>\n<p>好的，不要怀疑前置知识，CPU 的工作方式，就是不断从内存中取指令并执行，那为什么会说是执行 BIOS 里的程序呢？这就不得不说说<strong>内存映射</strong>了。</p>\n<h2 id=\"二、内存映射\"><a href=\"#二、内存映射\" class=\"headerlink\" title=\"二、内存映射\"></a>二、内存映射</h2><p><strong>CPU 地址总线的宽度决定了可访问的内存空间的大小</strong>。比如 16 位的 CPU 地址总线宽度为 20 位，地址范围是 1M。32 位的 CPU 地址总线宽度为 32 位，地址范围是 4G。你可以算算我们现在的 64 位机的地址范围。</p>\n<p>可是，可访问的内存空间这么大，并不等于说全都给内存使用，也就是说寻址的对象不只有内存，还有一些外设也要通过地址总线的方式去访问，那怎么去访问这些外设呢？就是在地址范围中划出一片片的区域，这块给显存使用，那块给硬盘控制器使用，等等 。</p>\n<p>这样说，其实就不符合我们的前置知识了，所以可以有一种不太正确的理解方式，那就是内存中的这块位置就是显存，那块位置就是硬盘控制器。我们在相应的位置上读取或者写入，就相当于在显存等外设的相应位置上读取或者写入，就好像这些外设的存储区域，被<strong>映射</strong>到了内存中的某一片区域一样。这样我们就不用管那些外设啦，关注点仍然是一个简简单单的内存。这就是所谓的<strong>内存映射</strong>。</p>\n<p>太好了，现在又用简单的前置知识就能解释得通了，我们继续往下推。</p>\n<h2 id=\"三、实模式下的内存分布\"><a href=\"#三、实模式下的内存分布\" class=\"headerlink\" title=\"三、实模式下的内存分布\"></a>三、实模式下的内存分布</h2><p>刚刚说到内存中划分出了一片一片区域给各种外设，那么问题自然就来了，哪块区域，分给了哪块外设了呢？如果是规定，那应该有一张表比较好吧。嗯没错，还真有，它就是实模式下的内存分布，笔者给它画了一张图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139328640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">在这里插入图片描述</p>\n<p>哎哟我真是个小天使，把比例都表现出来了，网上能再找出比我这个更直观的请给我留言。实模式之后再解释，现在简单理解就是计算机刚开机的时候只有 1M 的内存可用。</p>\n<p>我们看到，内存被各种外设瓜分了，即映射在了内存中。BIOS 更狠，不但其空间被映射到了内存 0xC0000 - 0xFFFFF 位置，其里面的程序还占用了开头的一些区域，比如把中断向量表写在了内存开始的位置，真所谓先到先得啊。</p>\n<h2 id=\"四、怎么就从-BIOS-里的程序开始执行了\"><a href=\"#四、怎么就从-BIOS-里的程序开始执行了\" class=\"headerlink\" title=\"四、怎么就从 BIOS 里的程序开始执行了\"></a>四、怎么就从 BIOS 里的程序开始执行了</h2><p>好了，现在我们知道 BIOS 里的信息被映射到了内存 0xC0000 - 0xFFFFF 位置，其中最为关键的系统 BIOS 被映射到了 0xF0000 - 0xFFFFF 位置。假如我现在说，CPU 开机就是执行了这块区域的代码，然后巴拉巴拉一顿操作就开机了，你肯定要喷我了，为什么就执行到这了呢，那咋不从头开始执行？</p>\n<p>这就自然有了一种猜想，我们要用到另一个前置知识了，就是 CPU 从内存的哪个位置取出执行并执行呢？<strong>是 PC 寄存器中的地址值</strong>。BIOS 程序的入口地址也就是开始地址是 0xFFFF0（人家就那么写的），也就是开机键一按下，一定有一个神奇的力量，将 pc 寄存器中的值变成 0xFFFF0，然后 CPU 就开始马不停蹄地跑了起来。没错，接下来这句话，可能就是你找了很久的答案，请做好准备：</p>\n<p><strong>在你开机的一瞬间，CPU 的 PC 寄存器被强制初始化为 0xFFFF0</strong>。如果再说具体些，CPU 将段基址寄存器 cs 初始化为 0xF000，将偏移地址寄存器 IP 初始化为 0xFFF0，根据实模式下的最终地址计算规则，将段基址左移 4 位，加上偏移地址，得到最终的物理地址也就是抽象出来的 PC 寄存器地址为 0xFFFF0。</p>\n<p>当我在学习这段知识时，看到这句话才让将我心里积压了很久的疑惑解开，多么简单粗暴的道理啊。写到这里我也是长舒了一口气，因为剩下的过程，就几乎只是流水账一样的正推了。</p>\n<p>至于怎么强制初始化的，我觉得就越过了前置知识的边界了，况且各个厂商的硬件实现也不一定相同，有很多办法，也很简单。讨论起来意义就不大了。</p>\n<h2 id=\"五、BIOS-里到底写了什么程序\"><a href=\"#五、BIOS-里到底写了什么程序\" class=\"headerlink\" title=\"五、BIOS 里到底写了什么程序\"></a>五、BIOS 里到底写了什么程序</h2><p>好了，我们现在知道了 BIOS 被映射到了内存的某个位置，并且开机一瞬间 CPU 强制将自己的 pc 寄存器初始化为 BIOS 程序的入口地址，从这里开始 CPU 马不停蹄地向前跑了起来。那接下来的问题似乎也非常自然地就问出来了，那就是 BIOS 程序里到底写了啥？</p>\n<p>把 BIOS 程序里的二进制信息全贴出来也不合适，我们分析一些主要的。我们首先还是来猜测，你看入口地址是 0xFFFF0，说明程序是从这执行的。实模式下内存的下边界就是 0xFFFFF，也就是只剩下 16 个字节的空间可以写代码了，这够干啥的呢？如果你有心的话应该能猜出，入口地址处可能是个跳转指令，跳到一个更大范围的空间去执行自己的任务。没错就是这样，0xFFFF0 处存储的机器指令，翻译成汇编语言是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp far f000:e05b</span><br></pre></td></tr></table></figure>\n\n<p>意思是跳转到物理地址 0xfe05b 处开始执行（回忆下前面说的实模式下的地址计算方式）。</p>\n<p>地址 0xfe05b 处开始，便是 BIOS 真正发挥作用的代码了，这块代码会检测一些外设信息，并初始化好硬件，建立中断向量表并填写中断例程。这里的部分不要展开，这只是一段写死的程序而已，而且对理解开机启动过程无帮助，我们看后面精彩的部分，也就是 BIOS 的最后一项工作：<strong>加载启动区</strong>。</p>\n<h2 id=\"六、0x7c00-是啥\"><a href=\"#六、0x7c00-是啥\" class=\"headerlink\" title=\"六、0x7c00 是啥\"></a>六、0x7c00 是啥</h2><p>该较真的地方就是要较真，我绝对不会让<strong>加载</strong>这种魔幻的词出现在这里，我们现在就来把它拆解成人话。</p>\n<p>其实这个词也并不魔幻，加载在计算机领域就是指，<strong>把某设备上（比如硬盘）的程序复制到内存中的过程</strong>。那加载启动区这个过程，翻译过来就是，<strong>BIOS 程序把启动区的内容复制到了内存中的某个区域</strong>。好了，问题又自然出来了，启动区是哪里？被复制到了内存的哪个位置？然后呢？我们一个个来回答。</p>\n<p>什么是启动区呢？即使你不知道，你也应该能够猜到，一定是符合某种特征的一块区域，于是人们把它就叫做启动区了，那要符合什么特征呢？先不急，不知道你有没有过设置 BIOS 启动顺序的经历，通常有 U 盘启动、硬盘启动、软盘启动、光盘启动等等，<strong>BIOS 会按照顺序，读取这些启动盘中位于 0 盘 0 道 1 扇区的内容</strong>。</p>\n<p>至于磁盘格式的划分，本篇就不做讲解了，总之对于内存，我们给出一个数字地址就能获取到该地址的数据，而对于磁盘，我们需要给出磁头、柱面、扇区这三个信息才能定位某个位置的数据，都是描述位置的一种方式而已。</p>\n<p>接着说， 这 0 盘 0 道 1 扇区的内容一共有 512 个字节，<strong>如果末尾的两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区</strong>。如果不是，那么按顺序继续向下个设备中寻找位于 0 盘 0 道 1 扇区的内容。如果最后发现都没找到符合条件的，那直接报出一个无启动区的错误。</p>\n<p>BIOS 找到了这个启动区之后干嘛呢？哦，前面说过了是加载，<strong>就是把这 512 个字节的内容，一个比特都不少的全部复制到内存的 0x7c00 这个位置</strong>。怎么复制的？当然是指令啦。哪些指令呢？这里我只能简单说指令集中是有 in 和 out 的，用来将外设中的数据复制到内存，或者将内存中的数据复制到外设，用这两个指令，以及外设给我们提供的读取方式，就能做到这一点啦。</p>\n<p>启动区内容此时已经被 BIOS 程序复制到了内存的 0x7c00 这个位置，然后呢？这个其实也不难猜测，启动区的内容就是我们自己写的代码了，复制到这里之后，就开始执行呗，之后我们的程序就接管了接下来的流程，BIOS 的使命也就结束啦。所以复制完之后，接下来应该是一个跳转指令吧！没错，正是这样，PC 寄存器的值变为 0x7c00，指令开始从这里执行。</p>\n<p>咦？不知道你有没有发现，我们似乎不知不觉又把之前的一句魔法语言翻译成人话了，开头我们说：</p>\n<blockquote>\n<p>BIOS 把控制权转交给排在第一位的存储设备。</p>\n</blockquote>\n<p>所以这句话是什么意思呢？<strong>就是 BIOS 把启动区的 512 字节复制到内存的 0x7c00 位置，并且用一条跳转指令将 pc 寄存器的值指向 0x7c00</strong>。你看，这不是也没多几个字嘛，就把这个问题说得明明白白，简简单单。</p>\n<p>哦，对了，现在似乎就剩下一个问题了，为什么非要是 0x7c00 呢？好问题，当然答案也很简单，那就是人家 BIOS 开发团队就是这样定的，之后也不好改了，不然不兼容。为什么不好改？我们看一个简单的启动区 512 字节的代码。（代码摘抄自《30 天自制操作系统》）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; hello-os</span><br><span class=\"line\">; TAB&#x3D;4</span><br><span class=\"line\"></span><br><span class=\"line\">  ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置</span><br><span class=\"line\"></span><br><span class=\"line\">;程序主体</span><br><span class=\"line\"></span><br><span class=\"line\">entry:</span><br><span class=\"line\">  MOV  AX,0   ;初始化寄存器</span><br><span class=\"line\">  MOV  SS,AX</span><br><span class=\"line\">  MOV  SP,0x7c00</span><br><span class=\"line\">  MOV  DS,AX   ;段寄存器初始化为 0</span><br><span class=\"line\">  MOV  ES,AX</span><br><span class=\"line\">  MOV  SI,msg</span><br><span class=\"line\">putloop:</span><br><span class=\"line\">  MOV  AL,[SI]</span><br><span class=\"line\">  ADD  SI,1</span><br><span class=\"line\">  CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符</span><br><span class=\"line\">  JE  fin</span><br><span class=\"line\">  MOV  AH,0x0e   ;指定文字</span><br><span class=\"line\">  MOV  BX,15   ;指定颜色</span><br><span class=\"line\">  INT  0x10   ;调用 BIOS 显示字符函数</span><br><span class=\"line\">  JMP  putloop</span><br><span class=\"line\">fin:</span><br><span class=\"line\">  HLT</span><br><span class=\"line\">  JMP  fin</span><br><span class=\"line\">msg:</span><br><span class=\"line\">  DB  0x0a,0x0a  ;换行、换行</span><br><span class=\"line\">  DB  &quot;hello-os&quot;</span><br><span class=\"line\">  DB  0x0a   ;换行</span><br><span class=\"line\">  DB  0    ;0 结尾</span><br><span class=\"line\"></span><br><span class=\"line\">  RESB 0x7dfe-$   ;填充0到512字节</span><br><span class=\"line\">  DB 0x55, 0xaa   ;可启动设备标识</span><br></pre></td></tr></table></figure>\n\n<p>我们看第一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ORG  0x7c00</span><br></pre></td></tr></table></figure>\n\n<p>这个数字就是刚刚说的启动区加载位置，这行汇编代码简单说就表示把下面的地址统统加上 0x7c00。正因为 BIOS 将启动区的代码加载到了这里，因此有了一个偏移量，所以所有写启动区代码的人就需要在开头写死一个这样的代码，不然全都串位了。</p>\n<p>然后正因为所有写操作系统的，启动区的第一行汇编代码都写死了这个数字，那 BIOS 开发者最初定的这个数字就不好改了，否则它得挨个联系各个操作系统的开发厂商，说唉我这个地址改一下哈，你们跟着改改。在公司推动另一个团队改个代码都得大费周折，想想看这样的推动得耗费多大人力。况且即使改了，之前的代码也都不兼容了，这不得被人们骂死啊。</p>\n<p>再看最后一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DB 0x55, 0xaa</span><br></pre></td></tr></table></figure>\n\n<p>这也验证了我们之前说的这 512 字节的最后两个字节得是 0x55 0xaa，BIOS 才会认为它是一个启动区，才会去加载它，仅此而已。</p>\n<p>回过头来说 0x7c00 这个值，它其实就是一个规定死的值，但还是会有人问，那必然有它的合理性吧。其实，我的解释也只能说是人家规定了这个值，后人们替他们解释这个合理性，并不是说当初人家就一定是这样想的，就好比我们做语文的阅读理解题一样。</p>\n<p>第一个 BIOS 开发团队是 IBM PC 5150 BIOS，当时被认为的第一个操作系统是 DOS 1.0 操作系统，BIOS 团队就假设是为它服务的。但操作系统还没出，BIOS 团队假设其操作系统需要的最小内存为 32 KB。BIOS 希望自己所加载的启动区代码尽量靠后，这样比较“安全”，不至于过早的被其他程序覆盖掉。可是如果仅仅留 512 字节又感觉太悬了，还有一些栈空间需要预留，那扩大到 1 KB 吧。这样 32 KB 的末尾是 0x8000，减去 1KB(0x400) ，刚好等于 0x7c00。哇塞，太精准了，这可以是一种解释方式。</p>\n<h2 id=\"七、启动区里的代码写了啥\"><a href=\"#七、启动区里的代码写了啥\" class=\"headerlink\" title=\"七、启动区里的代码写了啥\"></a>七、启动区里的代码写了啥</h2><p>其实写到这，我这篇文章就应该戛然而止了，因为最初的那个问题已经解决了，CPU 已经开始马不停蹄地从我们预期的位置跑起来了，万事开头难，剩下的内容，就是操作系统想怎么玩就怎么玩了。</p>\n<p>但我觉得还不够味，似乎还有些问题萦绕在你脑海里。比如说这个问题：</p>\n<blockquote>\n<p>启动区里的代码写了啥？就 512 字节就是全部操作系统内容了？</p>\n</blockquote>\n<p>这是一个好问题，512 个字节确实干不了啥，现在的操作系统怎么也得按 M 为单位算吧，512 个字节远远不够呢，那是怎么回事呢？</p>\n<p>其实我们可以按照之前的思路猜测，BIOS 用很少的代码就把 512 字节的启动区内容加载到了内存，并跳转过去开始执行。那按照这个套路，这 512 字节的启动区代码，是不是也可以把更多磁盘中存储的操作系统程序，加载到内存的某个位置，然后跳转过去呢？</p>\n<p>没错，就是这个套路。<strong>所以 BIOS 负责加载了启动区，而启动区又负责加载真正的操作系统内核</strong>，这配合默契吧？</p>\n<p>由于用于启动盘的磁盘是人家写操作系统的厂商制作的，俗称制作启动盘，所以他也肯定知道操作系统的核心代码存储在磁盘的哪个扇区，因此启动区就把这个扇区，以及之后的好多好多扇区（具体取决于操作系统有多大）都读到内存中，然后跳转到开始的程序开始的位置。跳转到哪里呢？这个就不像 0x7c00 这个数那么经典了，不同的操作系统肯定也不一样，也不用事先规定好，反正写操作系统的人给自己定一个就好了，别覆盖其他关键设备用到的区域就好。</p>\n<h2 id=\"八、操作系统内核写了啥\"><a href=\"#八、操作系统内核写了啥\" class=\"headerlink\" title=\"八、操作系统内核写了啥\"></a>八、操作系统内核写了啥</h2><p>好了现在经过好几轮跳跳跳，终于跳到内核代码啦，我们来一起回顾一下：</p>\n<ol>\n<li>按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址（一跳）</li>\n<li>该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）</li>\n<li>执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）</li>\n<li>启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635139335949069-20190421160331677-268089991.png\" alt=\"img\"></p>\n<h1 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h1><p><img src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/16351393421635139306R-C.81d56db1bef63aa01cbba73b33caedf3?rik=3YtNM7LX/wHS5Q&riu=http://www.linuxidc.com/upload/2016_06/160617100110611.png&ehk=0SHzV/qNHRE7jk8jqfwwge4teKMqurNw7sM4KipqkaA=&risl=&pid=ImgRaw&r=0\" alt=\"See the source image\"></p>\n","categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]}