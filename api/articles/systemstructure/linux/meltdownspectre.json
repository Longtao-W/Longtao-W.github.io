{"title":"幽灵熔断","slug":"systemstructure/linux/meltdownspectre","date":"2020-08-25T14:24:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/linux/meltdownspectre.json","excerpt":null,"covers":["https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211027/16353092843-4-257058.jpg"],"content":"<p>[toc]</p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>Meltdown/Spectre被发现于2018年, 是很有影响力的cpu漏洞。</p>\n<p>Meltdown（熔断）对应编号恶意数据缓存加载 CVE-2017-5754 。</p>\n<p>Spectre （幽灵）对应编号边界检查绕过 CVE-2017-5753 、分支目标注入 CVE-2017-5715 。</p>\n<p>Meltdown 影响几乎所有的 Intel CPU（从1995年起）以及部分 ARM CPU。 Spectre 拥有更广的影响范围，在 Meltdown 的情况下，恶意程序可读取某些自身无权限访问的数据。利用此漏洞低权限用户可以访问到本身无权限访问的内容，例如用户密码、加密密钥。</p>\n<p>Spectre 恶意利用程序，可导致用户的帐号、密码泄漏。在公共云服务器上，可能打破界限，从一台虚拟机器获取到另一个用户的权限。</p>\n<h3 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h3><p>指令周期：CPU取出一条指令并执行该指令所需的时间称为指令周期，指令周期的长短与指令的复杂程度有关，一般多个CPU周期组成指令周期。</p>\n<p>CPU周期：又称机器周期，通常用从主存读取一条指令的最短时间来规定CPU周期，一般多个时钟周期组成CPU周期</p>\n<p>时钟周期：时钟周期是处理操作的最基本时间单位，由机器的主频决定（超到20GHZ，全人类感谢你）</p>\n<h3 id=\"CPU的执行\"><a href=\"#CPU的执行\" class=\"headerlink\" title=\"CPU的执行\"></a>CPU的执行</h3><h4 id=\"基本过程\"><a href=\"#基本过程\" class=\"headerlink\" title=\"基本过程\"></a>基本过程</h4><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211027/16353092843-4-257058.jpg\" alt=\"img\"></p>\n<p>cpu一般按照 取指令–&gt;指令译码—&gt;指令执行–&gt;存储访问–&gt;写回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">取指令 --&gt; 指令译码;</span><br><span class=\"line\">指令译码--&gt;指令执行;</span><br><span class=\"line\">指令执行--&gt;存储访问;</span><br><span class=\"line\">存储访问--&gt;写回;</span><br></pre></td></tr></table></figure>\n\n<p> 取指令:Instruction Fetch,从存储器取指令到CPU</p>\n<p>指令译码:Instruction Decode，对取回的指令进行拆分和解释，识别和区分出不同的指令类别及各种获取操作数的方法</p>\n<p>指令执行:Instruction Execute，使用硬件功能单元执行指令，最常见功能单元为算术逻辑部件运算器（Arithmetic Logical Unit，ALU）</p>\n<p>存储访问:Memory Access，根据指令需要，有可能要访问主存，读取操作数，具体见下表</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>算法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>隐含寻址</td>\n<td>默认操作数地址</td>\n<td>不访存</td>\n<td>数据范围受限</td>\n</tr>\n<tr>\n<td>立即寻址</td>\n<td>D = A</td>\n<td>不访存</td>\n<td>操作数值范围受限</td>\n</tr>\n<tr>\n<td>直接寻址</td>\n<td>EA = A</td>\n<td>简单</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>间接寻址</td>\n<td>EA = (A)</td>\n<td>地址范围大</td>\n<td>多次访存</td>\n</tr>\n<tr>\n<td>寄存器寻址</td>\n<td>EA = R</td>\n<td>不访存</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>寄存器间接寻址</td>\n<td>EA = ®</td>\n<td>地址范围大</td>\n<td>访存</td>\n</tr>\n<tr>\n<td>偏移寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>段寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>堆栈寻址</td>\n<td>EA = SP</td>\n<td>不访存</td>\n<td>应用受限</td>\n</tr>\n</tbody></table>\n<p>写回:把执行指令阶段的运行结果数据“写回”到某种存储形式，经常是写到cpu内部寄存器以便下次快速使用</p>\n<h4 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h4><p>若处理器无流水线结构，一条指令执行一般需要五个处理器周期；流水线使用锁存器（latch，用来缓存电信号）让不同指令的各步操作重叠，从而实现多条指令在不同周期并行处理，只执行一条指令的话，流水线不会提高效率。</p>\n<h4 id=\"分支预测\"><a href=\"#分支预测\" class=\"headerlink\" title=\"分支预测\"></a>分支预测</h4><p>流水线架构对顺序执行的命令，性能提升明显，但遇到命令跳转（goto系列等）就会性能降低，那么就出现了分支预测期，提前把预测到的指令存入流水线，分支跳转指令完成后如果预测正确，流水线正常运行，若错误，清空流水线然后执行正确的指令</p>\n<h4 id=\"乱序执行\"><a href=\"#乱序执行\" class=\"headerlink\" title=\"乱序执行\"></a>乱序执行</h4><p>打乱程序原本的执行顺序（类似上层使用异步，编译器也会乱序执行）</p>\n<p>cpu的乱序执行一般都使用Tomasulo算法，包括</p>\n<ul>\n<li>Common Data Bus (CDB).</li>\n<li>Unified Reservation Station (Scheduler).</li>\n<li>Register Renaming (Reorder Buffer).</li>\n</ul>\n<p>该算法虽然是乱序执行, 但是会顺序完成 (retire), 只有在retire后它的输出才会architectually visible (简单地说, 不影响程序逻辑), 但是没有architectually visible不等于没有影响, 当输出更新到reservation station后, 因为cdb的存在, 其他指令已经可以读到. 另外, 非常重要的一点, 异常只有在指令retire的时候才会触发, 对于上面的例子, 即使cpu已经检查到第一条指令没有访问权限, 也只能等到该指令retire时才会触发, 取决于该指令在ROB的位置, 可能马上触发也可能很久之后, ROB容量可以很容易做到比如192这个级别.</p>\n<h3 id=\"熔断漏洞（利用乱序执行）\"><a href=\"#熔断漏洞（利用乱序执行）\" class=\"headerlink\" title=\"熔断漏洞（利用乱序执行）\"></a>熔断漏洞（利用乱序执行）</h3><p>cpu在执行A语句的同时将B语句中的内存位置的信息加载到cache中，这个加载的过程忽略了权限的判断之后再执行B、C语句，在执行B语句时发现并没有权限，所以放弃乱序执行的结果，回滚到最初的状态依次执行。此时cache中的信息没有还原。之后通过边信道攻击来测试数据，发现对于某一个数据的访问要远远快于其他数据的访问，那么就可推断数据在cache中，并且可以反推回它的内存地址。</p>\n<h3 id=\"幽灵漏洞（利用分支预测）\"><a href=\"#幽灵漏洞（利用分支预测）\" class=\"headerlink\" title=\"幽灵漏洞（利用分支预测）\"></a>幽灵漏洞（利用分支预测）</h3><p>和熔断差不多，比如if else 中，提前预测某一条，预测错误，状态回滚，边信道攻击，反推内存地址</p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>打补丁，关闭乱序执行、分支预测，不过个人电脑建议别关，关了会影响性能。</p>\n","more":"<p>[toc]</p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>Meltdown/Spectre被发现于2018年, 是很有影响力的cpu漏洞。</p>\n<p>Meltdown（熔断）对应编号恶意数据缓存加载 CVE-2017-5754 。</p>\n<p>Spectre （幽灵）对应编号边界检查绕过 CVE-2017-5753 、分支目标注入 CVE-2017-5715 。</p>\n<p>Meltdown 影响几乎所有的 Intel CPU（从1995年起）以及部分 ARM CPU。 Spectre 拥有更广的影响范围，在 Meltdown 的情况下，恶意程序可读取某些自身无权限访问的数据。利用此漏洞低权限用户可以访问到本身无权限访问的内容，例如用户密码、加密密钥。</p>\n<p>Spectre 恶意利用程序，可导致用户的帐号、密码泄漏。在公共云服务器上，可能打破界限，从一台虚拟机器获取到另一个用户的权限。</p>\n<h3 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h3><p>指令周期：CPU取出一条指令并执行该指令所需的时间称为指令周期，指令周期的长短与指令的复杂程度有关，一般多个CPU周期组成指令周期。</p>\n<p>CPU周期：又称机器周期，通常用从主存读取一条指令的最短时间来规定CPU周期，一般多个时钟周期组成CPU周期</p>\n<p>时钟周期：时钟周期是处理操作的最基本时间单位，由机器的主频决定（超到20GHZ，全人类感谢你）</p>\n<h3 id=\"CPU的执行\"><a href=\"#CPU的执行\" class=\"headerlink\" title=\"CPU的执行\"></a>CPU的执行</h3><h4 id=\"基本过程\"><a href=\"#基本过程\" class=\"headerlink\" title=\"基本过程\"></a>基本过程</h4><p><img src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211027/16353092843-4-257058.jpg\" alt=\"img\"></p>\n<p>cpu一般按照 取指令–&gt;指令译码—&gt;指令执行–&gt;存储访问–&gt;写回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">取指令 --&gt; 指令译码;</span><br><span class=\"line\">指令译码--&gt;指令执行;</span><br><span class=\"line\">指令执行--&gt;存储访问;</span><br><span class=\"line\">存储访问--&gt;写回;</span><br></pre></td></tr></table></figure>\n\n<p> 取指令:Instruction Fetch,从存储器取指令到CPU</p>\n<p>指令译码:Instruction Decode，对取回的指令进行拆分和解释，识别和区分出不同的指令类别及各种获取操作数的方法</p>\n<p>指令执行:Instruction Execute，使用硬件功能单元执行指令，最常见功能单元为算术逻辑部件运算器（Arithmetic Logical Unit，ALU）</p>\n<p>存储访问:Memory Access，根据指令需要，有可能要访问主存，读取操作数，具体见下表</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>算法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>隐含寻址</td>\n<td>默认操作数地址</td>\n<td>不访存</td>\n<td>数据范围受限</td>\n</tr>\n<tr>\n<td>立即寻址</td>\n<td>D = A</td>\n<td>不访存</td>\n<td>操作数值范围受限</td>\n</tr>\n<tr>\n<td>直接寻址</td>\n<td>EA = A</td>\n<td>简单</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>间接寻址</td>\n<td>EA = (A)</td>\n<td>地址范围大</td>\n<td>多次访存</td>\n</tr>\n<tr>\n<td>寄存器寻址</td>\n<td>EA = R</td>\n<td>不访存</td>\n<td>地址范围受限</td>\n</tr>\n<tr>\n<td>寄存器间接寻址</td>\n<td>EA = ®</td>\n<td>地址范围大</td>\n<td>访存</td>\n</tr>\n<tr>\n<td>偏移寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>段寻址</td>\n<td>EA = A + ®</td>\n<td>灵活</td>\n<td>复杂</td>\n</tr>\n<tr>\n<td>堆栈寻址</td>\n<td>EA = SP</td>\n<td>不访存</td>\n<td>应用受限</td>\n</tr>\n</tbody></table>\n<p>写回:把执行指令阶段的运行结果数据“写回”到某种存储形式，经常是写到cpu内部寄存器以便下次快速使用</p>\n<h4 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h4><p>若处理器无流水线结构，一条指令执行一般需要五个处理器周期；流水线使用锁存器（latch，用来缓存电信号）让不同指令的各步操作重叠，从而实现多条指令在不同周期并行处理，只执行一条指令的话，流水线不会提高效率。</p>\n<h4 id=\"分支预测\"><a href=\"#分支预测\" class=\"headerlink\" title=\"分支预测\"></a>分支预测</h4><p>流水线架构对顺序执行的命令，性能提升明显，但遇到命令跳转（goto系列等）就会性能降低，那么就出现了分支预测期，提前把预测到的指令存入流水线，分支跳转指令完成后如果预测正确，流水线正常运行，若错误，清空流水线然后执行正确的指令</p>\n<h4 id=\"乱序执行\"><a href=\"#乱序执行\" class=\"headerlink\" title=\"乱序执行\"></a>乱序执行</h4><p>打乱程序原本的执行顺序（类似上层使用异步，编译器也会乱序执行）</p>\n<p>cpu的乱序执行一般都使用Tomasulo算法，包括</p>\n<ul>\n<li>Common Data Bus (CDB).</li>\n<li>Unified Reservation Station (Scheduler).</li>\n<li>Register Renaming (Reorder Buffer).</li>\n</ul>\n<p>该算法虽然是乱序执行, 但是会顺序完成 (retire), 只有在retire后它的输出才会architectually visible (简单地说, 不影响程序逻辑), 但是没有architectually visible不等于没有影响, 当输出更新到reservation station后, 因为cdb的存在, 其他指令已经可以读到. 另外, 非常重要的一点, 异常只有在指令retire的时候才会触发, 对于上面的例子, 即使cpu已经检查到第一条指令没有访问权限, 也只能等到该指令retire时才会触发, 取决于该指令在ROB的位置, 可能马上触发也可能很久之后, ROB容量可以很容易做到比如192这个级别.</p>\n<h3 id=\"熔断漏洞（利用乱序执行）\"><a href=\"#熔断漏洞（利用乱序执行）\" class=\"headerlink\" title=\"熔断漏洞（利用乱序执行）\"></a>熔断漏洞（利用乱序执行）</h3><p>cpu在执行A语句的同时将B语句中的内存位置的信息加载到cache中，这个加载的过程忽略了权限的判断之后再执行B、C语句，在执行B语句时发现并没有权限，所以放弃乱序执行的结果，回滚到最初的状态依次执行。此时cache中的信息没有还原。之后通过边信道攻击来测试数据，发现对于某一个数据的访问要远远快于其他数据的访问，那么就可推断数据在cache中，并且可以反推回它的内存地址。</p>\n<h3 id=\"幽灵漏洞（利用分支预测）\"><a href=\"#幽灵漏洞（利用分支预测）\" class=\"headerlink\" title=\"幽灵漏洞（利用分支预测）\"></a>幽灵漏洞（利用分支预测）</h3><p>和熔断差不多，比如if else 中，提前预测某一条，预测错误，状态回滚，边信道攻击，反推内存地址</p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>打补丁，关闭乱序执行、分支预测，不过个人电脑建议别关，关了会影响性能。</p>\n","categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"linux","path":"api/tags/linux.json"}]}