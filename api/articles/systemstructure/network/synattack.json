{"title":"SYN攻击","slug":"systemstructure/network/synattack","date":"2020-07-23T12:45:23.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/systemstructure/network/synattack.json","excerpt":null,"covers":["https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171424format,png","https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png","https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171435tcp-three-way-handshake-and-syn-flood-attack.png"],"content":"<p>SYN：同步序列编号（***Synchronize Sequence Numbers***）。</p>\n<p>是TCP/IP建立连接时使用的握手信号。在客户机和<a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571\">服务器</a>之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以<a href=\"https://baike.baidu.com/item/ACK/3692629\">ACK</a>消息响应。这样在<a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E6%9C%BA/5168153\">客户机</a>和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递</p>\n<h3 id=\"TCP报文首部\"><a href=\"#TCP报文首部\" class=\"headerlink\" title=\"TCP报文首部\"></a>TCP报文首部</h3><p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>\n<ol>\n<li>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</li>\n<li>序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li>\n<li>确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li>\n<li>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li>\n<li>保留，占6位，保留今后使用，但目前应都位0；</li>\n<li>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li>\n<li>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</li>\n<li>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</li>\n<li>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</li>\n<li>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</li>\n<li>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li>\n<li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li>\n<li>检验和，占2字节，校验首部和数据这两部分；</li>\n<li>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</li>\n<li>选项，长度可变，定义一些其他的可选的参数。</li>\n</ol>\n<h3 id=\"TCP连接的建立（三次握手）\"><a href=\"#TCP连接的建立（三次握手）\" class=\"headerlink\" title=\"TCP连接的建立（三次握手）\"></a>TCP连接的建立（三次握手）</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171424format,png\" alt=\"三次握手\"></p>\n<ol>\n<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>\n<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>\n<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>\n<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>\n<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>\n</ol>\n<p><strong>必须三次握手的原因：</strong>双方必须确认对方正确知道对方的seq序号并以ack返回</p>\n<h3 id=\"TCP连接的释放（四次挥手）\"><a href=\"#TCP连接的释放（四次挥手）\" class=\"headerlink\" title=\"TCP连接的释放（四次挥手）\"></a>TCP连接的释放（四次挥手）</h3><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png\" alt=\"四次挥手\"></p>\n<ol>\n<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>\n<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>\n<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>\n<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>\n<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>\n<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>\n</ol>\n<p><strong>point：</strong></p>\n<ol>\n<li>服务端和客户端都可以主动断开连接</li>\n<li>在收到FIN包，只是发送方这边不再发送数据了，但是接收方可能还有数据在发送给发送方，所以此时不能直接断开连接，也因此不能立马发送FIN包。</li>\n<li><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171435tcp-three-way-handshake-and-syn-flood-attack.png\" alt=\"See the source image\"></li>\n</ol>\n<p>author:longtao.wu</p>\n<p>blog:<a href=\"http://www.longtao.fun/\">www.longtao.fun</a></p>\n<p><strong>refrence：</strong></p>\n<ol>\n<li><a href=\"https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md\">https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md</a></li>\n</ol>\n","more":"<p>SYN：同步序列编号（***Synchronize Sequence Numbers***）。</p>\n<p>是TCP/IP建立连接时使用的握手信号。在客户机和<a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571\">服务器</a>之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以<a href=\"https://baike.baidu.com/item/ACK/3692629\">ACK</a>消息响应。这样在<a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E6%9C%BA/5168153\">客户机</a>和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递</p>\n<h3 id=\"TCP报文首部\"><a href=\"#TCP报文首部\" class=\"headerlink\" title=\"TCP报文首部\"></a>TCP报文首部</h3><p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>\n<ol>\n<li>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</li>\n<li>序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li>\n<li>确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li>\n<li>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li>\n<li>保留，占6位，保留今后使用，但目前应都位0；</li>\n<li>紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li>\n<li>确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</li>\n<li>推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</li>\n<li>复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</li>\n<li>同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</li>\n<li>终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li>\n<li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li>\n<li>检验和，占2字节，校验首部和数据这两部分；</li>\n<li>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</li>\n<li>选项，长度可变，定义一些其他的可选的参数。</li>\n</ol>\n<h3 id=\"TCP连接的建立（三次握手）\"><a href=\"#TCP连接的建立（三次握手）\" class=\"headerlink\" title=\"TCP连接的建立（三次握手）\"></a>TCP连接的建立（三次握手）</h3><p><img src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171424format,png\" alt=\"三次握手\"></p>\n<ol>\n<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>\n<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>\n<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>\n<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>\n<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>\n</ol>\n<p><strong>必须三次握手的原因：</strong>双方必须确认对方正确知道对方的seq序号并以ack返回</p>\n<h3 id=\"TCP连接的释放（四次挥手）\"><a href=\"#TCP连接的释放（四次挥手）\" class=\"headerlink\" title=\"TCP连接的释放（四次挥手）\"></a>TCP连接的释放（四次挥手）</h3><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png\" alt=\"四次挥手\"></p>\n<ol>\n<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>\n<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>\n<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>\n<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>\n<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>\n<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>\n</ol>\n<p><strong>point：</strong></p>\n<ol>\n<li>服务端和客户端都可以主动断开连接</li>\n<li>在收到FIN包，只是发送方这边不再发送数据了，但是接收方可能还有数据在发送给发送方，所以此时不能直接断开连接，也因此不能立马发送FIN包。</li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211025/1635171435tcp-three-way-handshake-and-syn-flood-attack.png\" alt=\"See the source image\"></li>\n</ol>\n<p>author:longtao.wu</p>\n<p>blog:<a href=\"http://www.longtao.fun/\">www.longtao.fun</a></p>\n<p><strong>refrence：</strong></p>\n<ol>\n<li><a href=\"https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md\">https://github.com/zhengweikeng/blog/blob/master/posts/2016/tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE.md</a></li>\n</ol>\n","categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"网络","path":"api/tags/网络.json"}]}