{"title":"GarbledCircuit","slug":"greatprinciple/garbledcircuit","date":"2021-10-17T15:20:21.000Z","updated":"2024-06-30T10:35:56.304Z","comments":true,"path":"api/articles/greatprinciple/garbledcircuit.json","excerpt":null,"covers":["https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211018/16345319921634531766163453174816345291911634526937v2-b70574979c325cdaa52eef57c68eb610_b.png"],"content":"<h1 id=\"Garbled-Circuit\"><a href=\"#Garbled-Circuit\" class=\"headerlink\" title=\"Garbled Circuit\"></a>Garbled Circuit</h1><h2 id=\"零碎知识\"><a href=\"#零碎知识\" class=\"headerlink\" title=\"零碎知识\"></a>零碎知识</h2><p><strong>定律</strong>:是由实验得出的基本结论，由定律进行数学推导可以得到一些物理上的结论或者定理</p>\n<p><strong>定理</strong>: 由公理，原理，定律经过数学推导得出的结论</p>\n<p><strong>公理</strong>: 是没有经过证明，但被当作不证自明的一个命题</p>\n<p><strong>信息守恒定律</strong>: 物理学的绝对性定律,量子力学基石(幺正性:波函数归一化,全空间粒子总概率为1),指孤立物理系统中信息守恒(定律,不一定正确,如黑洞佯谬的挑战)</p>\n<p><strong>黑洞无毛</strong>: 黑洞只有质量、角动量以及电荷三个不能变为电磁辐射的守恒量，其他的信息全都丧失</p>\n<p><strong>黑洞佯谬</strong>: 广义相对论中对黑洞的计算得出黑洞无毛,黑洞层面信息不再守恒,这也是广义相对论和量子理论矛盾之处</p>\n<p><strong>同态</strong>：抽象代数中，同态是两个代数结构（例如群、环、或者向量空间）之间的保持结构不变的映射</p>\n<p><strong>同态加密</strong>: 对经过同态加密的数据进行处理得到一个输出，将这一输出进行解密，其结果与用同一方法处理未加密的原始数据得到的输出结果是一样的</p>\n<p><strong>可信计算(Trusted Computing，TC)</strong>: 可信目的是保证系统和应用的完整性等，从而确定系统或软件运行在期望的可信状态。可信是安全的必要不充分条件,可信计算分为外包计算和多方计算,外包计算是甲方拥有数据和计算方法,使用乙方的算力获取结果,安全常用同态加密</p>\n<p><strong>差分隐私(differential privacy)</strong>: 一种数据共享手段,为了应对差分攻击而生,原理就是给查询结果加噪声</p>\n<p><strong>多方安全计算（Secure Multi-Party Computation）</strong>：主要是针对无可信第三方的情况下，如何安全地计算一个约定函数的问题；安全多方计算（  Secure  Multi-Party  Computation，MPC）于1986  年由姚期智院士提出。安全多方计算协议允许多个数据所有者在互不信任的情况下进行协同计算，输出计算结果，并保证任何一方均无法得到除应得的计算结果之外的其他任何信息。换句话说，MPC技术可以获取数据使用价值，却不泄露原始数据内容</p>\n<p><strong>信息论安全</strong>：一个安全多方计算协议，如果对于拥有无限计算能力攻击者而言是安全的，则称作是信息论安全的或无条件安全的</p>\n<p><strong>密码学安全</strong>: 如果对于拥有多项式计算能力的攻击者是安全的，则称为是密码学安全的或条件安全的。在条件安全模型下，当且仅当恶意参与者的人数少于总人数的一半时，安全的方案才存在</p>\n<p><strong>敌手模型</strong>：</p>\n<p>半诚实（Semi-Honest）模型：假设参与计算的各方都是半诚实的，即参与方可以保留交互时得到的信息。对于想要协作完成计算并得到正确结果的参与方来说，这样的模型符合实际情况。恶意（Malicious）模型、诚实模型不符合实际情况</p>\n<p><strong>多项式时间</strong>：在计算复杂度理论中，指的是一个问题的计算时间不大于问题大小的多项式倍数，可以在机器上以多项式时间求解的问题被称为P问题，可以在多项式时间验证答案的问题被称为NP，数学家有时把“如多项式时间长的算法”视为快速计算，相对应的是超多项式时间</p>\n<p>密钥共享：密钥分享的基本思路是将每个数字拆散成多个数，并将这些数分发到多个参与方，如算工资，设置一个最大数值范围，每个人给别人一个数字，可以提前超支出，但是经过n次分发后进行相加</p>\n<p>随机预言机Random OracleL：如果x和H(x)已经在表里记录过，就输出H(x)如果没有关于x的记录，则RO完全随机地在值域中选取一个0,1字符串（或者从其他希望映射到的元素集合中完全随机的选取）当作H(x)，把这个和x一起记录在表里，然后输出这个H(x)。</p>\n<h2 id=\"OT协议\"><a href=\"#OT协议\" class=\"headerlink\" title=\"OT协议\"></a>OT协议</h2><p><strong>1-out-of-2 OT</strong></p>\n<p>消息提供方Alice有两个消息M0和M1，只想提供给Bob其中一个，并且不会泄露另一个</p>\n<p>消息接收方Bob想要获取其中一个消息(假设为M1),但不想让Alice知道自己想获取的是哪一个</p>\n<h4 id=\"流程演示\"><a href=\"#流程演示\" class=\"headerlink\" title=\"流程演示\"></a>流程演示</h4><p>1-2OT假设Alice有两个消息M0、M1,Bob想获取M1</p>\n<p>假设M1、M0长度相同，要求随机数r长度和两者相同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\"> participant A as Alice(数据提供方，拥有消息M0和M1) </span><br><span class=\"line\"> participant B as Bob(数据请求方，想要获取M1)</span><br><span class=\"line\"> A -&gt;&gt; A: Alice分别产生两个密钥对rsa0,rsa1</span><br><span class=\"line\"> A -&gt;&gt; B : 发送给Bob rsa0-pub,rsa1-pub公钥</span><br><span class=\"line\"> B -&gt;&gt; B : 生成一个随机数r</span><br><span class=\"line\"> B -&gt;&gt; B : Bob想要获取M1,使用rsa1-pub加密r成rsa1-context</span><br><span class=\"line\"> B -&gt;&gt; A : Bob将rsa1-context发送给Alice</span><br><span class=\"line\"> A-&gt;&gt;A : Alice用rsa0-pri,rsa1-pri分别解密rsa1-context得到r&#39;和r</span><br><span class=\"line\"> A-&gt;&gt;A: Alice用r&#39;与M0做xor得到xor(r&#39;,M0)、xor(r&#39;,M0),r与M1得到xor(r,M1)</span><br><span class=\"line\"> A -&gt;&gt;B : Alice把xor(r&#39;,M0)、xor(r,M1)发送给Bob</span><br><span class=\"line\"> B -&gt;&gt;B: xor(xor(r,M1),r)得到消息M1</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<div class=\"mermaid\">sequenceDiagram\n    participant A as Alice(数据提供方，拥有消息M0和M1) \n    participant B as Bob(数据请求方，想要获取M1)\n    A -&gt;&gt; A: Alice分别产生两个密钥对rsa0,rsa1\n    A -&gt;&gt; B : 发送给Bob rsa0-pub,rsa1-pub公钥\n    B -&gt;&gt; B : 生成一个随机数r\n    B -&gt;&gt; B : Bob想要获取M1,使用rsa1-pub加密r成rsa1-context\n    B -&gt;&gt; A : Bob将rsa1-context发送给Alice\n    A-&gt;&gt;A : Alice用rsa0-pri,rsa1-pri分别解密rsa1-context得到r&#39;和r\n    A-&gt;&gt;A: Alice用r&#39;与M0做xor得到xor(r&#39;,M0)、xor(r&#39;,M0),r与M1得到xor(r,M1)\n    A -&gt;&gt;B : Alice把xor(r&#39;,M0)、xor(r,M1)发送给Bob\n    B -&gt;&gt;B: xor(xor(r,M1),r)得到消息M1</div>\n\n<h2 id=\"混淆电路\"><a href=\"#混淆电路\" class=\"headerlink\" title=\"混淆电路\"></a>混淆电路</h2><p>所有可计算的函数问题都可转换为不同的电路，加法电路、乘法电路、移位电路、选择电路等。而电路本质上由门（gate）组成，逻辑门包括与门、非门、或门、与非门等。混淆电路把这些门的真值表进行加密和打乱来掩盖原本的逻辑信息信息。</p>\n<p>基本步骤</p>\n<ol>\n<li>生成：Alice生成混淆电路</li>\n<li>传输：Bob获取Alice的输入和混淆电路，基于OT协议</li>\n<li>计算：Bob计算电路的到混淆结果，发送给Alice，Alice根据混淆结果得到最终结果发送给Bob</li>\n</ol>\n<p>下面我们单看XOR门的混淆电路过程（可逆运算不能达到隐私计算效果）</p>\n<p>XOR的真值表为</p>\n<table>\n<thead>\n<tr>\n<th>Alice</th>\n<th>Bob</th>\n<th>out</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p>Alice首先使用字符串替换真值表，然后使用输入作为对称加密密钥加密输出</p>\n<table>\n<thead>\n<tr>\n<th>Alice</th>\n<th>Bob</th>\n<th>out</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>a1</td>\n<td>b1</td>\n<td>ENCa1b1(r0)</td>\n</tr>\n<tr>\n<td>a1</td>\n<td>b0</td>\n<td>ENCa1b0(r1)</td>\n</tr>\n<tr>\n<td>a0</td>\n<td>b1</td>\n<td>ENCa0b1(r1)</td>\n</tr>\n<tr>\n<td>a0</td>\n<td>b0</td>\n<td>ENCa0b0(r0)</td>\n</tr>\n</tbody></table>\n<p><strong>数据传递</strong></p>\n<ol>\n<li>Alice把自己的输入(假设为a1)和输出(ENCa1b1(r0)、ENCa1b0(r1)、  ENCa0b1(r1)、ENCa0b0(r0))发送给发送给Bob</li>\n<li>Bob通过不经意传输获取自己的输出对应的字符串（假设是b0）</li>\n</ol>\n<p>评估：对于单个逻辑门，显然没有达到隐私计算的目的，混淆电路一般用于不可逆的计算！</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211018/16345319921634531766163453174816345291911634526937v2-b70574979c325cdaa52eef57c68eb610_b.png\" alt=\"img\"></p>\n <iframe  \n height=850 \n width=90% \n src=\"https://longtao.fun/ppt/yaoGC.html\"  \n frameborder=0  \n allowfullscreen>\n </iframe>\n","more":"<h1 id=\"Garbled-Circuit\"><a href=\"#Garbled-Circuit\" class=\"headerlink\" title=\"Garbled Circuit\"></a>Garbled Circuit</h1><h2 id=\"零碎知识\"><a href=\"#零碎知识\" class=\"headerlink\" title=\"零碎知识\"></a>零碎知识</h2><p><strong>定律</strong>:是由实验得出的基本结论，由定律进行数学推导可以得到一些物理上的结论或者定理</p>\n<p><strong>定理</strong>: 由公理，原理，定律经过数学推导得出的结论</p>\n<p><strong>公理</strong>: 是没有经过证明，但被当作不证自明的一个命题</p>\n<p><strong>信息守恒定律</strong>: 物理学的绝对性定律,量子力学基石(幺正性:波函数归一化,全空间粒子总概率为1),指孤立物理系统中信息守恒(定律,不一定正确,如黑洞佯谬的挑战)</p>\n<p><strong>黑洞无毛</strong>: 黑洞只有质量、角动量以及电荷三个不能变为电磁辐射的守恒量，其他的信息全都丧失</p>\n<p><strong>黑洞佯谬</strong>: 广义相对论中对黑洞的计算得出黑洞无毛,黑洞层面信息不再守恒,这也是广义相对论和量子理论矛盾之处</p>\n<p><strong>同态</strong>：抽象代数中，同态是两个代数结构（例如群、环、或者向量空间）之间的保持结构不变的映射</p>\n<p><strong>同态加密</strong>: 对经过同态加密的数据进行处理得到一个输出，将这一输出进行解密，其结果与用同一方法处理未加密的原始数据得到的输出结果是一样的</p>\n<p><strong>可信计算(Trusted Computing，TC)</strong>: 可信目的是保证系统和应用的完整性等，从而确定系统或软件运行在期望的可信状态。可信是安全的必要不充分条件,可信计算分为外包计算和多方计算,外包计算是甲方拥有数据和计算方法,使用乙方的算力获取结果,安全常用同态加密</p>\n<p><strong>差分隐私(differential privacy)</strong>: 一种数据共享手段,为了应对差分攻击而生,原理就是给查询结果加噪声</p>\n<p><strong>多方安全计算（Secure Multi-Party Computation）</strong>：主要是针对无可信第三方的情况下，如何安全地计算一个约定函数的问题；安全多方计算（  Secure  Multi-Party  Computation，MPC）于1986  年由姚期智院士提出。安全多方计算协议允许多个数据所有者在互不信任的情况下进行协同计算，输出计算结果，并保证任何一方均无法得到除应得的计算结果之外的其他任何信息。换句话说，MPC技术可以获取数据使用价值，却不泄露原始数据内容</p>\n<p><strong>信息论安全</strong>：一个安全多方计算协议，如果对于拥有无限计算能力攻击者而言是安全的，则称作是信息论安全的或无条件安全的</p>\n<p><strong>密码学安全</strong>: 如果对于拥有多项式计算能力的攻击者是安全的，则称为是密码学安全的或条件安全的。在条件安全模型下，当且仅当恶意参与者的人数少于总人数的一半时，安全的方案才存在</p>\n<p><strong>敌手模型</strong>：</p>\n<p>半诚实（Semi-Honest）模型：假设参与计算的各方都是半诚实的，即参与方可以保留交互时得到的信息。对于想要协作完成计算并得到正确结果的参与方来说，这样的模型符合实际情况。恶意（Malicious）模型、诚实模型不符合实际情况</p>\n<p><strong>多项式时间</strong>：在计算复杂度理论中，指的是一个问题的计算时间不大于问题大小的多项式倍数，可以在机器上以多项式时间求解的问题被称为P问题，可以在多项式时间验证答案的问题被称为NP，数学家有时把“如多项式时间长的算法”视为快速计算，相对应的是超多项式时间</p>\n<p>密钥共享：密钥分享的基本思路是将每个数字拆散成多个数，并将这些数分发到多个参与方，如算工资，设置一个最大数值范围，每个人给别人一个数字，可以提前超支出，但是经过n次分发后进行相加</p>\n<p>随机预言机Random OracleL：如果x和H(x)已经在表里记录过，就输出H(x)如果没有关于x的记录，则RO完全随机地在值域中选取一个0,1字符串（或者从其他希望映射到的元素集合中完全随机的选取）当作H(x)，把这个和x一起记录在表里，然后输出这个H(x)。</p>\n<h2 id=\"OT协议\"><a href=\"#OT协议\" class=\"headerlink\" title=\"OT协议\"></a>OT协议</h2><p><strong>1-out-of-2 OT</strong></p>\n<p>消息提供方Alice有两个消息M0和M1，只想提供给Bob其中一个，并且不会泄露另一个</p>\n<p>消息接收方Bob想要获取其中一个消息(假设为M1),但不想让Alice知道自己想获取的是哪一个</p>\n<h4 id=\"流程演示\"><a href=\"#流程演示\" class=\"headerlink\" title=\"流程演示\"></a>流程演示</h4><p>1-2OT假设Alice有两个消息M0、M1,Bob想获取M1</p>\n<p>假设M1、M0长度相同，要求随机数r长度和两者相同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\"> participant A as Alice(数据提供方，拥有消息M0和M1) </span><br><span class=\"line\"> participant B as Bob(数据请求方，想要获取M1)</span><br><span class=\"line\"> A -&gt;&gt; A: Alice分别产生两个密钥对rsa0,rsa1</span><br><span class=\"line\"> A -&gt;&gt; B : 发送给Bob rsa0-pub,rsa1-pub公钥</span><br><span class=\"line\"> B -&gt;&gt; B : 生成一个随机数r</span><br><span class=\"line\"> B -&gt;&gt; B : Bob想要获取M1,使用rsa1-pub加密r成rsa1-context</span><br><span class=\"line\"> B -&gt;&gt; A : Bob将rsa1-context发送给Alice</span><br><span class=\"line\"> A-&gt;&gt;A : Alice用rsa0-pri,rsa1-pri分别解密rsa1-context得到r&#39;和r</span><br><span class=\"line\"> A-&gt;&gt;A: Alice用r&#39;与M0做xor得到xor(r&#39;,M0)、xor(r&#39;,M0),r与M1得到xor(r,M1)</span><br><span class=\"line\"> A -&gt;&gt;B : Alice把xor(r&#39;,M0)、xor(r,M1)发送给Bob</span><br><span class=\"line\"> B -&gt;&gt;B: xor(xor(r,M1),r)得到消息M1</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<div class=\"mermaid\">sequenceDiagram\n    participant A as Alice(数据提供方，拥有消息M0和M1) \n    participant B as Bob(数据请求方，想要获取M1)\n    A -&gt;&gt; A: Alice分别产生两个密钥对rsa0,rsa1\n    A -&gt;&gt; B : 发送给Bob rsa0-pub,rsa1-pub公钥\n    B -&gt;&gt; B : 生成一个随机数r\n    B -&gt;&gt; B : Bob想要获取M1,使用rsa1-pub加密r成rsa1-context\n    B -&gt;&gt; A : Bob将rsa1-context发送给Alice\n    A-&gt;&gt;A : Alice用rsa0-pri,rsa1-pri分别解密rsa1-context得到r&#39;和r\n    A-&gt;&gt;A: Alice用r&#39;与M0做xor得到xor(r&#39;,M0)、xor(r&#39;,M0),r与M1得到xor(r,M1)\n    A -&gt;&gt;B : Alice把xor(r&#39;,M0)、xor(r,M1)发送给Bob\n    B -&gt;&gt;B: xor(xor(r,M1),r)得到消息M1</div>\n\n<h2 id=\"混淆电路\"><a href=\"#混淆电路\" class=\"headerlink\" title=\"混淆电路\"></a>混淆电路</h2><p>所有可计算的函数问题都可转换为不同的电路，加法电路、乘法电路、移位电路、选择电路等。而电路本质上由门（gate）组成，逻辑门包括与门、非门、或门、与非门等。混淆电路把这些门的真值表进行加密和打乱来掩盖原本的逻辑信息信息。</p>\n<p>基本步骤</p>\n<ol>\n<li>生成：Alice生成混淆电路</li>\n<li>传输：Bob获取Alice的输入和混淆电路，基于OT协议</li>\n<li>计算：Bob计算电路的到混淆结果，发送给Alice，Alice根据混淆结果得到最终结果发送给Bob</li>\n</ol>\n<p>下面我们单看XOR门的混淆电路过程（可逆运算不能达到隐私计算效果）</p>\n<p>XOR的真值表为</p>\n<table>\n<thead>\n<tr>\n<th>Alice</th>\n<th>Bob</th>\n<th>out</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p>Alice首先使用字符串替换真值表，然后使用输入作为对称加密密钥加密输出</p>\n<table>\n<thead>\n<tr>\n<th>Alice</th>\n<th>Bob</th>\n<th>out</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>a1</td>\n<td>b1</td>\n<td>ENCa1b1(r0)</td>\n</tr>\n<tr>\n<td>a1</td>\n<td>b0</td>\n<td>ENCa1b0(r1)</td>\n</tr>\n<tr>\n<td>a0</td>\n<td>b1</td>\n<td>ENCa0b1(r1)</td>\n</tr>\n<tr>\n<td>a0</td>\n<td>b0</td>\n<td>ENCa0b0(r0)</td>\n</tr>\n</tbody></table>\n<p><strong>数据传递</strong></p>\n<ol>\n<li>Alice把自己的输入(假设为a1)和输出(ENCa1b1(r0)、ENCa1b0(r1)、  ENCa0b1(r1)、ENCa0b0(r0))发送给发送给Bob</li>\n<li>Bob通过不经意传输获取自己的输出对应的字符串（假设是b0）</li>\n</ol>\n<p>评估：对于单个逻辑门，显然没有达到隐私计算的目的，混淆电路一般用于不可逆的计算！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Longtao-W/pics@main/20211018/16345319921634531766163453174816345291911634526937v2-b70574979c325cdaa52eef57c68eb610_b.png\" alt=\"img\"></p>\n <iframe  \n height=850 \n width=90% \n src=\"https://longtao.fun/ppt/yaoGC.html\"  \n frameborder=0  \n allowfullscreen>\n </iframe>\n","categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"Garbled Circuit","path":"api/tags/Garbled Circuit.json"}]}