{"title":"golang的bufio包","slug":"language/golang/bufiopackage","date":"2019-09-09T15:20:21.000Z","updated":"2024-06-30T10:35:56.308Z","comments":true,"path":"api/articles/language/golang/bufiopackage.json","excerpt":null,"covers":null,"content":"<p>原理</p>\n<p>bufio通过缓冲提高效率</p>\n<p>把文件读取进缓冲(内存)避免每次读取触发系统io</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">participant 程序 as A</span><br><span class=\"line\">participant 缓冲区buf as B</span><br><span class=\"line\">participant 文件 as C</span><br><span class=\"line\">B--A:写入内容小于buf</span><br><span class=\"line\">B--A:</span><br><span class=\"line\">C--B:buf没空间，写入文件，清空buf</span><br><span class=\"line\">C--A:写入内容大于buf</span><br></pre></td></tr></table></figure>\n\n\n\n<p>把文件写入缓冲，多次写入后，最后一次性写入文件·</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序--缓冲区buf:写入内容小于buf</span><br><span class=\"line\">程序--缓冲区buf:</span><br><span class=\"line\">缓冲区buf--文件:buf没空间，写入文件，清空buf</span><br><span class=\"line\">程序--文件:写入内容大于buf</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br><span class=\"line\">619</span><br><span class=\"line\">620</span><br><span class=\"line\">621</span><br><span class=\"line\">622</span><br><span class=\"line\">623</span><br><span class=\"line\">624</span><br><span class=\"line\">625</span><br><span class=\"line\">626</span><br><span class=\"line\">627</span><br><span class=\"line\">628</span><br><span class=\"line\">629</span><br><span class=\"line\">630</span><br><span class=\"line\">631</span><br><span class=\"line\">632</span><br><span class=\"line\">633</span><br><span class=\"line\">634</span><br><span class=\"line\">635</span><br><span class=\"line\">636</span><br><span class=\"line\">637</span><br><span class=\"line\">638</span><br><span class=\"line\">639</span><br><span class=\"line\">640</span><br><span class=\"line\">641</span><br><span class=\"line\">642</span><br><span class=\"line\">643</span><br><span class=\"line\">644</span><br><span class=\"line\">645</span><br><span class=\"line\">646</span><br><span class=\"line\">647</span><br><span class=\"line\">648</span><br><span class=\"line\">649</span><br><span class=\"line\">650</span><br><span class=\"line\">651</span><br><span class=\"line\">652</span><br><span class=\"line\">653</span><br><span class=\"line\">654</span><br><span class=\"line\">655</span><br><span class=\"line\">656</span><br><span class=\"line\">657</span><br><span class=\"line\">658</span><br><span class=\"line\">659</span><br><span class=\"line\">660</span><br><span class=\"line\">661</span><br><span class=\"line\">662</span><br><span class=\"line\">663</span><br><span class=\"line\">664</span><br><span class=\"line\">665</span><br><span class=\"line\">666</span><br><span class=\"line\">667</span><br><span class=\"line\">668</span><br><span class=\"line\">669</span><br><span class=\"line\">670</span><br><span class=\"line\">671</span><br><span class=\"line\">672</span><br><span class=\"line\">673</span><br><span class=\"line\">674</span><br><span class=\"line\">675</span><br><span class=\"line\">676</span><br><span class=\"line\">677</span><br><span class=\"line\">678</span><br><span class=\"line\">679</span><br><span class=\"line\">680</span><br><span class=\"line\">681</span><br><span class=\"line\">682</span><br><span class=\"line\">683</span><br><span class=\"line\">684</span><br><span class=\"line\">685</span><br><span class=\"line\">686</span><br><span class=\"line\">687</span><br><span class=\"line\">688</span><br><span class=\"line\">689</span><br><span class=\"line\">690</span><br><span class=\"line\">691</span><br><span class=\"line\">692</span><br><span class=\"line\">693</span><br><span class=\"line\">694</span><br><span class=\"line\">695</span><br><span class=\"line\">696</span><br><span class=\"line\">697</span><br><span class=\"line\">698</span><br><span class=\"line\">699</span><br><span class=\"line\">700</span><br><span class=\"line\">701</span><br><span class=\"line\">702</span><br><span class=\"line\">703</span><br><span class=\"line\">704</span><br><span class=\"line\">705</span><br><span class=\"line\">706</span><br><span class=\"line\">707</span><br><span class=\"line\">708</span><br><span class=\"line\">709</span><br><span class=\"line\">710</span><br><span class=\"line\">711</span><br><span class=\"line\">712</span><br><span class=\"line\">713</span><br><span class=\"line\">714</span><br><span class=\"line\">715</span><br><span class=\"line\">716</span><br><span class=\"line\">717</span><br><span class=\"line\">718</span><br><span class=\"line\">719</span><br><span class=\"line\">720</span><br><span class=\"line\">721</span><br><span class=\"line\">722</span><br><span class=\"line\">723</span><br><span class=\"line\">724</span><br><span class=\"line\">725</span><br><span class=\"line\">726</span><br><span class=\"line\">727</span><br><span class=\"line\">728</span><br><span class=\"line\">729</span><br><span class=\"line\">730</span><br><span class=\"line\">731</span><br><span class=\"line\">732</span><br><span class=\"line\">733</span><br><span class=\"line\">734</span><br><span class=\"line\">735</span><br><span class=\"line\">736</span><br><span class=\"line\">737</span><br><span class=\"line\">738</span><br><span class=\"line\">739</span><br><span class=\"line\">740</span><br><span class=\"line\">741</span><br><span class=\"line\">742</span><br><span class=\"line\">743</span><br><span class=\"line\">744</span><br><span class=\"line\">745</span><br><span class=\"line\">746</span><br><span class=\"line\">747</span><br><span class=\"line\">748</span><br><span class=\"line\">749</span><br><span class=\"line\">750</span><br><span class=\"line\">751</span><br><span class=\"line\">752</span><br><span class=\"line\">753</span><br><span class=\"line\">754</span><br><span class=\"line\">755</span><br><span class=\"line\">756</span><br><span class=\"line\">757</span><br><span class=\"line\">758</span><br><span class=\"line\">759</span><br><span class=\"line\">760</span><br><span class=\"line\">761</span><br><span class=\"line\">762</span><br><span class=\"line\">763</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">// Use of this source code is governed by a BSD-style</span></span><br><span class=\"line\"><span class=\"comment\">// license that can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer</span></span><br><span class=\"line\"><span class=\"comment\">// object, creating another object (Reader or Writer) that also implements</span></span><br><span class=\"line\"><span class=\"comment\">// the interface but provides buffering and some help for textual I/O.</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> bufio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;unicode/utf8&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tdefaultBufSize = <span class=\"number\">4096</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tErrInvalidUnreadByte = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadByte&quot;</span>)</span><br><span class=\"line\">\tErrInvalidUnreadRune = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadRune&quot;</span>)</span><br><span class=\"line\">\tErrBufferFull        = errors.New(<span class=\"string\">&quot;bufio: buffer full&quot;</span>)</span><br><span class=\"line\">\tErrNegativeCount     = errors.New(<span class=\"string\">&quot;bufio: negative count&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered input.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reader implements buffering for an io.Reader object.对io.Reader的封装</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbuf          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\trd           io.Reader <span class=\"comment\">// reader provided by the client</span></span><br><span class=\"line\">\tr, w         <span class=\"keyword\">int</span>       <span class=\"comment\">// buf read and write positions</span></span><br><span class=\"line\">\terr          error</span><br><span class=\"line\">\tlastByte     <span class=\"keyword\">int</span> <span class=\"comment\">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class=\"line\">\tlastRuneSize <span class=\"keyword\">int</span> <span class=\"comment\">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minReadBufferSize = <span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxConsecutiveEmptyReads = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReaderSize</span><span class=\"params\">(rd io.Reader, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Reader?</span></span><br><span class=\"line\">\tb, ok := rd.(*Reader)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt; minReadBufferSize &#123;</span><br><span class=\"line\">\t\tsize = minReadBufferSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr := <span class=\"built_in\">new</span>(Reader)</span><br><span class=\"line\">\tr.reset(<span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size), rd)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReader</span><span class=\"params\">(rd io.Reader)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any buffered data, resets all state, and switches</span></span><br><span class=\"line\"><span class=\"comment\">// the buffered reader to read from r.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Reset</span><span class=\"params\">(r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\tb.reset(b.buf, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">reset</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>, r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\t*b = Reader&#123;</span><br><span class=\"line\">\t\tbuf:          buf,</span><br><span class=\"line\">\t\trd:           r,</span><br><span class=\"line\">\t\tlastByte:     <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\tlastRuneSize: <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeRead = errors.New(<span class=\"string\">&quot;bufio: reader returned negative count from Read&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fill reads a new chunk into the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">fill</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Slide existing data to beginning.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(b.buf, b.buf[b.r:b.w])</span><br><span class=\"line\">\t\tb.w -= b.r</span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to fill full buffer&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Read new data: try a limited number of times.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := maxConsecutiveEmptyReads; i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tn, err := b.rd.Read(b.buf[b.w:])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tb.err = err</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.err = io.ErrNoProgress</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">readErr</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\terr := b.err</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Peek returns the next n bytes without advancing the reader. The bytes stop</span></span><br><span class=\"line\"><span class=\"comment\">// being valid at the next read call. If Peek returns fewer than n bytes, it</span></span><br><span class=\"line\"><span class=\"comment\">// also returns an error explaining why the read is short. The error is</span></span><br><span class=\"line\"><span class=\"comment\">// ErrBufferFull if n is larger than b&#x27;s buffer size.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Calling Peek prevents a UnreadByte or UnreadRune call from succeeding</span></span><br><span class=\"line\"><span class=\"comment\">// until the next read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Peek</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &gt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.buf[b.r:b.w], ErrBufferFull</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 0 &lt;= n &lt;= len(b.buf)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> avail := b.w - b.r; avail &lt; n &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// not enough data in buffer</span></span><br><span class=\"line\">\t\tn = avail</span><br><span class=\"line\">\t\terr = b.readErr()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b.buf[b.r : b.r+n], err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Discard skips the next n bytes, returning the number of bytes discarded.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If Discard skips fewer than n bytes, it also returns an error.</span></span><br><span class=\"line\"><span class=\"comment\">// If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without</span></span><br><span class=\"line\"><span class=\"comment\">// reading from the underlying io.Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Discard</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(discarded <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tremain := n</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tskip := b.Buffered()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tb.fill()</span><br><span class=\"line\">\t\t\tskip = b.Buffered()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip &gt; remain &#123;</span><br><span class=\"line\">\t\t\tskip = remain</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.r += skip</span><br><span class=\"line\">\t\tremain -= skip</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> remain == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n - remain, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read reads data into p.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes read into p.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes are taken from at most one Read on the underlying Reader,</span></span><br><span class=\"line\"><span class=\"comment\">// hence n may be less than len(p).</span></span><br><span class=\"line\"><span class=\"comment\">// To read exactly len(p) bytes, use io.ReadFull(b, p).</span></span><br><span class=\"line\"><span class=\"comment\">// At EOF, the count will be zero and err will be io.EOF.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Read</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn = <span class=\"built_in\">len</span>(p)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(p) &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large read, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Read directly into p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.rd.Read(p)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tb.lastByte = <span class=\"keyword\">int</span>(p[n<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// One read.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Do not use b.fill, which will loop.</span></span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tn, b.err = b.rd.Read(b.buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// copy as much as we can</span></span><br><span class=\"line\">\tn = <span class=\"built_in\">copy</span>(p, b.buf[b.r:b.w])</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadByte reads and returns a single byte.</span></span><br><span class=\"line\"><span class=\"comment\">// If no byte is available, returns an error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadByte</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := b.buf[b.r]</span><br><span class=\"line\">\tb.r++</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(c)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte unreads the last byte. Only the most recently read byte can be unread.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte returns an error if the most recent method called on the</span></span><br><span class=\"line\"><span class=\"comment\">// Reader was not a read operation. Notably, Peek is not considered a</span></span><br><span class=\"line\"><span class=\"comment\">// read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadByte</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastByte &lt; <span class=\"number\">0</span> || b.r == <span class=\"number\">0</span> &amp;&amp; b.w &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadByte</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// b.r &gt; 0 || b.w == 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.r--</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r == 0 &amp;&amp; b.w == 0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.r] = <span class=\"keyword\">byte</span>(b.lastByte)</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadRune reads a single UTF-8 encoded Unicode character and returns the</span></span><br><span class=\"line\"><span class=\"comment\">// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte</span></span><br><span class=\"line\"><span class=\"comment\">// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadRune</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">rune</span>, size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r+utf8.UTFMax &gt; b.w &amp;&amp; !utf8.FullRune(b.buf[b.r:b.w]) &amp;&amp; b.err == <span class=\"literal\">nil</span> &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr, size = <span class=\"keyword\">rune</span>(b.buf[b.r]), <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &gt;= utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\tr, size = utf8.DecodeRune(b.buf[b.r:b.w])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += size</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r, size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadRune unreads the last rune. If the most recent method called on</span></span><br><span class=\"line\"><span class=\"comment\">// the Reader was not a ReadRune, UnreadRune returns an error. (In this</span></span><br><span class=\"line\"><span class=\"comment\">// regard it is stricter than UnreadByte, which will unread the last byte</span></span><br><span class=\"line\"><span class=\"comment\">// from any read operation.)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadRune</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastRuneSize &lt; <span class=\"number\">0</span> || b.r &lt; b.lastRuneSize &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadRune</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r -= b.lastRuneSize</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that can be read from the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.w - b.r &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice pointing at the bytes in the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes stop being valid at the next read.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadSlice encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns all the data in the buffer and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.</span></span><br><span class=\"line\"><span class=\"comment\">// Because the data returned from ReadSlice will be overwritten</span></span><br><span class=\"line\"><span class=\"comment\">// by the next I/O operation, most clients should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes or ReadString instead.</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice returns err != nil if and only if line does not end in delim.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadSlice</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\ts := <span class=\"number\">0</span> <span class=\"comment\">// search start index</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Search buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ti += s</span><br><span class=\"line\">\t\t\tline = b.buf[b.r : b.r+i+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tb.r += i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Pending error?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = b.buf[b.r:b.w]</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\terr = b.readErr()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Buffer full?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\tline = b.buf</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts = b.w - b.r <span class=\"comment\">// do not rescan area we scanned before</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Handle last byte, if any.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i := <span class=\"built_in\">len</span>(line) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.lastByte = <span class=\"keyword\">int</span>(line[i])</span><br><span class=\"line\">\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadLine is a low-level line-reading primitive. Most callers should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes(&#x27;\\n&#x27;) or ReadString(&#x27;\\n&#x27;) instead or use a Scanner.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine tries to return a single line, not including the end-of-line bytes.</span></span><br><span class=\"line\"><span class=\"comment\">// If the line was too long for the buffer then isPrefix is set and the</span></span><br><span class=\"line\"><span class=\"comment\">// beginning of the line is returned. The rest of the line will be returned</span></span><br><span class=\"line\"><span class=\"comment\">// from future calls. isPrefix will be false when returning the last fragment</span></span><br><span class=\"line\"><span class=\"comment\">// of the line. The returned buffer is only valid until the next call to</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine. ReadLine either returns a non-nil line or it returns an error,</span></span><br><span class=\"line\"><span class=\"comment\">// never both.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// The text returned from ReadLine does not include the line end (&quot;\\r\\n&quot; or &quot;\\n&quot;).</span></span><br><span class=\"line\"><span class=\"comment\">// No indication or error is given if the input ends without a final line end.</span></span><br><span class=\"line\"><span class=\"comment\">// Calling UnreadByte after ReadLine will always unread the last byte read</span></span><br><span class=\"line\"><span class=\"comment\">// (possibly a character belonging to the line end) even if that byte is not</span></span><br><span class=\"line\"><span class=\"comment\">// part of the line returned by ReadLine.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadLine</span><span class=\"params\">()</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, isPrefix <span class=\"keyword\">bool</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tline, err = b.ReadSlice(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == ErrBufferFull &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Handle the case where &quot;\\r\\n&quot; straddles the buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">0</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Put the &#x27;\\r&#x27; back on buf and drop it from line.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Let the next call to ReadLine check for &quot;\\r\\n&quot;.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> b.r == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// should be unreachable</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to rewind past start of buffer&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tb.r--</span><br><span class=\"line\">\t\t\tline = line[:<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> line, <span class=\"literal\">true</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\n&#x27;</span> &#123;</span><br><span class=\"line\">\t\tdrop := <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">1</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-2</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\tdrop = <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tline = line[:<span class=\"built_in\">len</span>(line)-drop]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadBytes encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadBytes</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Use ReadSlice to look for array,</span></span><br><span class=\"line\">\t<span class=\"comment\">// accumulating full buffers.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> frag []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> full [][]<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e error</span><br><span class=\"line\">\t\tfrag, e = b.ReadSlice(delim)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">// got final fragment</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e != ErrBufferFull &#123; <span class=\"comment\">// unexpected error</span></span><br><span class=\"line\">\t\t\terr = e</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Make a copy of the buffer.</span></span><br><span class=\"line\">\t\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(frag))</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(buf, frag)</span><br><span class=\"line\">\t\tfull = <span class=\"built_in\">append</span>(full, buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Allocate new buffer to hold the full pieces and the fragment.</span></span><br><span class=\"line\">\tn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">len</span>(full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn += <span class=\"built_in\">len</span>(frag)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Copy full pieces and fragment in.</span></span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\tn = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">copy</span>(buf[n:], full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(buf[n:], frag)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> buf, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadString reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a string containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadString encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadString returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadString</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tbytes, err := b.ReadBytes(delim)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(bytes), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteTo implements io.WriterTo.</span></span><br><span class=\"line\"><span class=\"comment\">// This may make multiple calls to the Read method of the underlying Reader.</span></span><br><span class=\"line\"><span class=\"comment\">// If the underlying reader supports the WriteTo method,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying WriteTo without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">WriteTo</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn, err = b.writeBuf(w)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r, ok := b.rd.(io.WriterTo); ok &#123;</span><br><span class=\"line\">\t\tm, err := r.WriteTo(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> w, ok := w.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\tm, err := w.ReadFrom(b.rd)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r &lt; b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r &lt; b.w =&gt; buffer is not empty</span></span><br><span class=\"line\">\t\tm, err := b.writeBuf(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err == io.EOF &#123;</span><br><span class=\"line\">\t\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeWrite = errors.New(<span class=\"string\">&quot;bufio: writer returned negative count from Write&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// writeBuf writes the Reader&#x27;s buffer to the writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">writeBuf</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(<span class=\"keyword\">int64</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tn, err := w.Write(b.buf[b.r:b.w])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(errNegativeWrite)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int64</span>(n), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Writer implements buffering for an io.Writer object.</span></span><br><span class=\"line\"><span class=\"comment\">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class=\"line\"><span class=\"comment\">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class=\"line\"><span class=\"comment\">// After all data has been written, the client should call the</span></span><br><span class=\"line\"><span class=\"comment\">// Flush method to guarantee all data has been forwarded to</span></span><br><span class=\"line\"><span class=\"comment\">// the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\terr error</span><br><span class=\"line\">\tbuf []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\tn   <span class=\"keyword\">int</span></span><br><span class=\"line\">\twr  io.Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriterSize returns a new Writer whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Writer is already a Writer with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriterSize</span><span class=\"params\">(w io.Writer, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Writer?</span></span><br><span class=\"line\">\tb, ok := w.(*Writer)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tsize = defaultBufSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Writer&#123;</span><br><span class=\"line\">\t\tbuf: <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size),</span><br><span class=\"line\">\t\twr:  w,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriter returns a new Writer whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriter</span><span class=\"params\">(w io.Writer)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewWriterSize(w, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any unflushed buffered data, clears any error, and</span></span><br><span class=\"line\"><span class=\"comment\">// resets b to write its output to w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Reset</span><span class=\"params\">(w io.Writer)</span></span> &#123;</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\tb.wr = w</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Flush writes any buffered data to the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Flush</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn, err := b.wr.Write(b.buf[<span class=\"number\">0</span>:b.n])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; b.n &amp;&amp; err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = io.ErrShortWrite</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &amp;&amp; n &lt; b.n &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">copy</span>(b.buf[<span class=\"number\">0</span>:b.n-n], b.buf[n:b.n])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n -= n</span><br><span class=\"line\">\t\tb.err = err</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Available returns how many bytes are unused in the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Available</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) - b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that have been written into the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Write writes the contents of p into the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If nn &lt; len(p), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Write</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(nn <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(p) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> n <span class=\"keyword\">int</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large write, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Write directly from p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.wr.Write(p)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tn = <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\t\t\tb.n += n</span><br><span class=\"line\">\t\t\tb.Flush()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\tp = p[n:]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteByte writes a single byte.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteByte</span><span class=\"params\">(c <span class=\"keyword\">byte</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Available() &lt;= <span class=\"number\">0</span> &amp;&amp; b.Flush() != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.n] = c</span><br><span class=\"line\">\tb.n++</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteRune writes a single Unicode code point, returning</span></span><br><span class=\"line\"><span class=\"comment\">// the number of bytes written and any error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteRune</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"params\">(size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &lt; utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\terr = b.WriteByte(<span class=\"keyword\">byte</span>(r))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := b.Available()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Flush(); b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tn = b.Available()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Can only happen if buffer is silly small.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> b.WriteString(<span class=\"keyword\">string</span>(r))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsize = utf8.EncodeRune(b.buf[b.n:], r)</span><br><span class=\"line\">\tb.n += size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteString writes a string.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If the count is less than len(s), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteString</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tnn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(s) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\t\tb.n += n</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\ts = s[n:]</span><br><span class=\"line\">\t\tb.Flush()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadFrom implements io.ReaderFrom. If the underlying writer</span></span><br><span class=\"line\"><span class=\"comment\">// supports the ReadFrom method, and b has no buffered data yet,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying ReadFrom without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">ReadFrom</span><span class=\"params\">(r io.Reader)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> w, ok := b.wr.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> w.ReadFrom(r)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err1 := b.Flush(); err1 != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> n, err1</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnr := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> nr &lt; maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\tm, err = r.Read(b.buf[b.n:])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> m != <span class=\"number\">0</span> || err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnr++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nr == maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, io.ErrNoProgress</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n += m</span><br><span class=\"line\">\t\tn += <span class=\"keyword\">int64</span>(m)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If we filled the buffer exactly, flush preemptively.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\terr = b.Flush()</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered input and output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadWriter stores pointers to a Reader and a Writer.</span></span><br><span class=\"line\"><span class=\"comment\">// It implements io.ReadWriter.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*Reader</span><br><span class=\"line\">\t*Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReadWriter allocates a new ReadWriter that dispatches to r and w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReadWriter</span><span class=\"params\">(r *Reader, w *Writer)</span> *<span class=\"title\">ReadWriter</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ReadWriter&#123;r, w&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","more":"<p>原理</p>\n<p>bufio通过缓冲提高效率</p>\n<p>把文件读取进缓冲(内存)避免每次读取触发系统io</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">participant 程序 as A</span><br><span class=\"line\">participant 缓冲区buf as B</span><br><span class=\"line\">participant 文件 as C</span><br><span class=\"line\">B--A:写入内容小于buf</span><br><span class=\"line\">B--A:</span><br><span class=\"line\">C--B:buf没空间，写入文件，清空buf</span><br><span class=\"line\">C--A:写入内容大于buf</span><br></pre></td></tr></table></figure>\n\n\n\n<p>把文件写入缓冲，多次写入后，最后一次性写入文件·</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序--缓冲区buf:写入内容小于buf</span><br><span class=\"line\">程序--缓冲区buf:</span><br><span class=\"line\">缓冲区buf--文件:buf没空间，写入文件，清空buf</span><br><span class=\"line\">程序--文件:写入内容大于buf</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br><span class=\"line\">619</span><br><span class=\"line\">620</span><br><span class=\"line\">621</span><br><span class=\"line\">622</span><br><span class=\"line\">623</span><br><span class=\"line\">624</span><br><span class=\"line\">625</span><br><span class=\"line\">626</span><br><span class=\"line\">627</span><br><span class=\"line\">628</span><br><span class=\"line\">629</span><br><span class=\"line\">630</span><br><span class=\"line\">631</span><br><span class=\"line\">632</span><br><span class=\"line\">633</span><br><span class=\"line\">634</span><br><span class=\"line\">635</span><br><span class=\"line\">636</span><br><span class=\"line\">637</span><br><span class=\"line\">638</span><br><span class=\"line\">639</span><br><span class=\"line\">640</span><br><span class=\"line\">641</span><br><span class=\"line\">642</span><br><span class=\"line\">643</span><br><span class=\"line\">644</span><br><span class=\"line\">645</span><br><span class=\"line\">646</span><br><span class=\"line\">647</span><br><span class=\"line\">648</span><br><span class=\"line\">649</span><br><span class=\"line\">650</span><br><span class=\"line\">651</span><br><span class=\"line\">652</span><br><span class=\"line\">653</span><br><span class=\"line\">654</span><br><span class=\"line\">655</span><br><span class=\"line\">656</span><br><span class=\"line\">657</span><br><span class=\"line\">658</span><br><span class=\"line\">659</span><br><span class=\"line\">660</span><br><span class=\"line\">661</span><br><span class=\"line\">662</span><br><span class=\"line\">663</span><br><span class=\"line\">664</span><br><span class=\"line\">665</span><br><span class=\"line\">666</span><br><span class=\"line\">667</span><br><span class=\"line\">668</span><br><span class=\"line\">669</span><br><span class=\"line\">670</span><br><span class=\"line\">671</span><br><span class=\"line\">672</span><br><span class=\"line\">673</span><br><span class=\"line\">674</span><br><span class=\"line\">675</span><br><span class=\"line\">676</span><br><span class=\"line\">677</span><br><span class=\"line\">678</span><br><span class=\"line\">679</span><br><span class=\"line\">680</span><br><span class=\"line\">681</span><br><span class=\"line\">682</span><br><span class=\"line\">683</span><br><span class=\"line\">684</span><br><span class=\"line\">685</span><br><span class=\"line\">686</span><br><span class=\"line\">687</span><br><span class=\"line\">688</span><br><span class=\"line\">689</span><br><span class=\"line\">690</span><br><span class=\"line\">691</span><br><span class=\"line\">692</span><br><span class=\"line\">693</span><br><span class=\"line\">694</span><br><span class=\"line\">695</span><br><span class=\"line\">696</span><br><span class=\"line\">697</span><br><span class=\"line\">698</span><br><span class=\"line\">699</span><br><span class=\"line\">700</span><br><span class=\"line\">701</span><br><span class=\"line\">702</span><br><span class=\"line\">703</span><br><span class=\"line\">704</span><br><span class=\"line\">705</span><br><span class=\"line\">706</span><br><span class=\"line\">707</span><br><span class=\"line\">708</span><br><span class=\"line\">709</span><br><span class=\"line\">710</span><br><span class=\"line\">711</span><br><span class=\"line\">712</span><br><span class=\"line\">713</span><br><span class=\"line\">714</span><br><span class=\"line\">715</span><br><span class=\"line\">716</span><br><span class=\"line\">717</span><br><span class=\"line\">718</span><br><span class=\"line\">719</span><br><span class=\"line\">720</span><br><span class=\"line\">721</span><br><span class=\"line\">722</span><br><span class=\"line\">723</span><br><span class=\"line\">724</span><br><span class=\"line\">725</span><br><span class=\"line\">726</span><br><span class=\"line\">727</span><br><span class=\"line\">728</span><br><span class=\"line\">729</span><br><span class=\"line\">730</span><br><span class=\"line\">731</span><br><span class=\"line\">732</span><br><span class=\"line\">733</span><br><span class=\"line\">734</span><br><span class=\"line\">735</span><br><span class=\"line\">736</span><br><span class=\"line\">737</span><br><span class=\"line\">738</span><br><span class=\"line\">739</span><br><span class=\"line\">740</span><br><span class=\"line\">741</span><br><span class=\"line\">742</span><br><span class=\"line\">743</span><br><span class=\"line\">744</span><br><span class=\"line\">745</span><br><span class=\"line\">746</span><br><span class=\"line\">747</span><br><span class=\"line\">748</span><br><span class=\"line\">749</span><br><span class=\"line\">750</span><br><span class=\"line\">751</span><br><span class=\"line\">752</span><br><span class=\"line\">753</span><br><span class=\"line\">754</span><br><span class=\"line\">755</span><br><span class=\"line\">756</span><br><span class=\"line\">757</span><br><span class=\"line\">758</span><br><span class=\"line\">759</span><br><span class=\"line\">760</span><br><span class=\"line\">761</span><br><span class=\"line\">762</span><br><span class=\"line\">763</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">// Use of this source code is governed by a BSD-style</span></span><br><span class=\"line\"><span class=\"comment\">// license that can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer</span></span><br><span class=\"line\"><span class=\"comment\">// object, creating another object (Reader or Writer) that also implements</span></span><br><span class=\"line\"><span class=\"comment\">// the interface but provides buffering and some help for textual I/O.</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> bufio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;unicode/utf8&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tdefaultBufSize = <span class=\"number\">4096</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tErrInvalidUnreadByte = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadByte&quot;</span>)</span><br><span class=\"line\">\tErrInvalidUnreadRune = errors.New(<span class=\"string\">&quot;bufio: invalid use of UnreadRune&quot;</span>)</span><br><span class=\"line\">\tErrBufferFull        = errors.New(<span class=\"string\">&quot;bufio: buffer full&quot;</span>)</span><br><span class=\"line\">\tErrNegativeCount     = errors.New(<span class=\"string\">&quot;bufio: negative count&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered input.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reader implements buffering for an io.Reader object.对io.Reader的封装</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbuf          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\trd           io.Reader <span class=\"comment\">// reader provided by the client</span></span><br><span class=\"line\">\tr, w         <span class=\"keyword\">int</span>       <span class=\"comment\">// buf read and write positions</span></span><br><span class=\"line\">\terr          error</span><br><span class=\"line\">\tlastByte     <span class=\"keyword\">int</span> <span class=\"comment\">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class=\"line\">\tlastRuneSize <span class=\"keyword\">int</span> <span class=\"comment\">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minReadBufferSize = <span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxConsecutiveEmptyReads = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReaderSize</span><span class=\"params\">(rd io.Reader, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Reader?</span></span><br><span class=\"line\">\tb, ok := rd.(*Reader)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt; minReadBufferSize &#123;</span><br><span class=\"line\">\t\tsize = minReadBufferSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr := <span class=\"built_in\">new</span>(Reader)</span><br><span class=\"line\">\tr.reset(<span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size), rd)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReader</span><span class=\"params\">(rd io.Reader)</span> *<span class=\"title\">Reader</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any buffered data, resets all state, and switches</span></span><br><span class=\"line\"><span class=\"comment\">// the buffered reader to read from r.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Reset</span><span class=\"params\">(r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\tb.reset(b.buf, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">reset</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>, r io.Reader)</span></span> &#123;</span><br><span class=\"line\">\t*b = Reader&#123;</span><br><span class=\"line\">\t\tbuf:          buf,</span><br><span class=\"line\">\t\trd:           r,</span><br><span class=\"line\">\t\tlastByte:     <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\tlastRuneSize: <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeRead = errors.New(<span class=\"string\">&quot;bufio: reader returned negative count from Read&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fill reads a new chunk into the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">fill</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Slide existing data to beginning.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(b.buf, b.buf[b.r:b.w])</span><br><span class=\"line\">\t\tb.w -= b.r</span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to fill full buffer&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Read new data: try a limited number of times.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := maxConsecutiveEmptyReads; i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tn, err := b.rd.Read(b.buf[b.w:])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tb.err = err</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.err = io.ErrNoProgress</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">readErr</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\terr := b.err</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Peek returns the next n bytes without advancing the reader. The bytes stop</span></span><br><span class=\"line\"><span class=\"comment\">// being valid at the next read call. If Peek returns fewer than n bytes, it</span></span><br><span class=\"line\"><span class=\"comment\">// also returns an error explaining why the read is short. The error is</span></span><br><span class=\"line\"><span class=\"comment\">// ErrBufferFull if n is larger than b&#x27;s buffer size.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Calling Peek prevents a UnreadByte or UnreadRune call from succeeding</span></span><br><span class=\"line\"><span class=\"comment\">// until the next read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Peek</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &gt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.buf[b.r:b.w], ErrBufferFull</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 0 &lt;= n &lt;= len(b.buf)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> avail := b.w - b.r; avail &lt; n &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// not enough data in buffer</span></span><br><span class=\"line\">\t\tn = avail</span><br><span class=\"line\">\t\terr = b.readErr()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b.buf[b.r : b.r+n], err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Discard skips the next n bytes, returning the number of bytes discarded.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If Discard skips fewer than n bytes, it also returns an error.</span></span><br><span class=\"line\"><span class=\"comment\">// If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without</span></span><br><span class=\"line\"><span class=\"comment\">// reading from the underlying io.Reader.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Discard</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(discarded <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, ErrNegativeCount</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tremain := n</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tskip := b.Buffered()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tb.fill()</span><br><span class=\"line\">\t\t\tskip = b.Buffered()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip &gt; remain &#123;</span><br><span class=\"line\">\t\t\tskip = remain</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.r += skip</span><br><span class=\"line\">\t\tremain -= skip</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> remain == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n - remain, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read reads data into p.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes read into p.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes are taken from at most one Read on the underlying Reader,</span></span><br><span class=\"line\"><span class=\"comment\">// hence n may be less than len(p).</span></span><br><span class=\"line\"><span class=\"comment\">// To read exactly len(p) bytes, use io.ReadFull(b, p).</span></span><br><span class=\"line\"><span class=\"comment\">// At EOF, the count will be zero and err will be io.EOF.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Read</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn = <span class=\"built_in\">len</span>(p)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(p) &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large read, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Read directly into p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.rd.Read(p)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tb.lastByte = <span class=\"keyword\">int</span>(p[n<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// One read.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Do not use b.fill, which will loop.</span></span><br><span class=\"line\">\t\tb.r = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tn, b.err = b.rd.Read(b.buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(errNegativeRead)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.w += n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// copy as much as we can</span></span><br><span class=\"line\">\tn = <span class=\"built_in\">copy</span>(p, b.buf[b.r:b.w])</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadByte reads and returns a single byte.</span></span><br><span class=\"line\"><span class=\"comment\">// If no byte is available, returns an error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadByte</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := b.buf[b.r]</span><br><span class=\"line\">\tb.r++</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(c)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte unreads the last byte. Only the most recently read byte can be unread.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// UnreadByte returns an error if the most recent method called on the</span></span><br><span class=\"line\"><span class=\"comment\">// Reader was not a read operation. Notably, Peek is not considered a</span></span><br><span class=\"line\"><span class=\"comment\">// read operation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadByte</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastByte &lt; <span class=\"number\">0</span> || b.r == <span class=\"number\">0</span> &amp;&amp; b.w &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadByte</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// b.r &gt; 0 || b.w == 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.r--</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r == 0 &amp;&amp; b.w == 0</span></span><br><span class=\"line\">\t\tb.w = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.r] = <span class=\"keyword\">byte</span>(b.lastByte)</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadRune reads a single UTF-8 encoded Unicode character and returns the</span></span><br><span class=\"line\"><span class=\"comment\">// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte</span></span><br><span class=\"line\"><span class=\"comment\">// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadRune</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">rune</span>, size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r+utf8.UTFMax &gt; b.w &amp;&amp; !utf8.FullRune(b.buf[b.r:b.w]) &amp;&amp; b.err == <span class=\"literal\">nil</span> &amp;&amp; b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// b.w-b.r &lt; len(buf) =&gt; buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.r == b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, <span class=\"number\">0</span>, b.readErr()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr, size = <span class=\"keyword\">rune</span>(b.buf[b.r]), <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &gt;= utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\tr, size = utf8.DecodeRune(b.buf[b.r:b.w])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += size</span><br><span class=\"line\">\tb.lastByte = <span class=\"keyword\">int</span>(b.buf[b.r<span class=\"number\">-1</span>])</span><br><span class=\"line\">\tb.lastRuneSize = size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r, size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UnreadRune unreads the last rune. If the most recent method called on</span></span><br><span class=\"line\"><span class=\"comment\">// the Reader was not a ReadRune, UnreadRune returns an error. (In this</span></span><br><span class=\"line\"><span class=\"comment\">// regard it is stricter than UnreadByte, which will unread the last byte</span></span><br><span class=\"line\"><span class=\"comment\">// from any read operation.)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadRune</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.lastRuneSize &lt; <span class=\"number\">0</span> || b.r &lt; b.lastRuneSize &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalidUnreadRune</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r -= b.lastRuneSize</span><br><span class=\"line\">\tb.lastByte = <span class=\"number\">-1</span></span><br><span class=\"line\">\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that can be read from the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.w - b.r &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice pointing at the bytes in the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// The bytes stop being valid at the next read.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadSlice encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns all the data in the buffer and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.</span></span><br><span class=\"line\"><span class=\"comment\">// Because the data returned from ReadSlice will be overwritten</span></span><br><span class=\"line\"><span class=\"comment\">// by the next I/O operation, most clients should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes or ReadString instead.</span></span><br><span class=\"line\"><span class=\"comment\">// ReadSlice returns err != nil if and only if line does not end in delim.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadSlice</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\ts := <span class=\"number\">0</span> <span class=\"comment\">// search start index</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Search buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ti += s</span><br><span class=\"line\">\t\t\tline = b.buf[b.r : b.r+i+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tb.r += i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Pending error?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = b.buf[b.r:b.w]</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\terr = b.readErr()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Buffer full?</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() &gt;= <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\t\tb.r = b.w</span><br><span class=\"line\">\t\t\tline = b.buf</span><br><span class=\"line\">\t\t\terr = ErrBufferFull</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts = b.w - b.r <span class=\"comment\">// do not rescan area we scanned before</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Handle last byte, if any.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i := <span class=\"built_in\">len</span>(line) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tb.lastByte = <span class=\"keyword\">int</span>(line[i])</span><br><span class=\"line\">\t\tb.lastRuneSize = <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadLine is a low-level line-reading primitive. Most callers should use</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes(&#x27;\\n&#x27;) or ReadString(&#x27;\\n&#x27;) instead or use a Scanner.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine tries to return a single line, not including the end-of-line bytes.</span></span><br><span class=\"line\"><span class=\"comment\">// If the line was too long for the buffer then isPrefix is set and the</span></span><br><span class=\"line\"><span class=\"comment\">// beginning of the line is returned. The rest of the line will be returned</span></span><br><span class=\"line\"><span class=\"comment\">// from future calls. isPrefix will be false when returning the last fragment</span></span><br><span class=\"line\"><span class=\"comment\">// of the line. The returned buffer is only valid until the next call to</span></span><br><span class=\"line\"><span class=\"comment\">// ReadLine. ReadLine either returns a non-nil line or it returns an error,</span></span><br><span class=\"line\"><span class=\"comment\">// never both.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// The text returned from ReadLine does not include the line end (&quot;\\r\\n&quot; or &quot;\\n&quot;).</span></span><br><span class=\"line\"><span class=\"comment\">// No indication or error is given if the input ends without a final line end.</span></span><br><span class=\"line\"><span class=\"comment\">// Calling UnreadByte after ReadLine will always unread the last byte read</span></span><br><span class=\"line\"><span class=\"comment\">// (possibly a character belonging to the line end) even if that byte is not</span></span><br><span class=\"line\"><span class=\"comment\">// part of the line returned by ReadLine.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadLine</span><span class=\"params\">()</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, isPrefix <span class=\"keyword\">bool</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tline, err = b.ReadSlice(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == ErrBufferFull &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Handle the case where &quot;\\r\\n&quot; straddles the buffer.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">0</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Put the &#x27;\\r&#x27; back on buf and drop it from line.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Let the next call to ReadLine check for &quot;\\r\\n&quot;.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> b.r == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// should be unreachable</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;bufio: tried to rewind past start of buffer&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tb.r--</span><br><span class=\"line\">\t\t\tline = line[:<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> line, <span class=\"literal\">true</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tline = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\n&#x27;</span> &#123;</span><br><span class=\"line\">\t\tdrop := <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(line) &gt; <span class=\"number\">1</span> &amp;&amp; line[<span class=\"built_in\">len</span>(line)<span class=\"number\">-2</span>] == <span class=\"string\">&#x27;\\r&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\tdrop = <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tline = line[:<span class=\"built_in\">len</span>(line)-drop]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a slice containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadBytes encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadBytes returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadBytes</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Use ReadSlice to look for array,</span></span><br><span class=\"line\">\t<span class=\"comment\">// accumulating full buffers.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> frag []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> full [][]<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e error</span><br><span class=\"line\">\t\tfrag, e = b.ReadSlice(delim)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">// got final fragment</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e != ErrBufferFull &#123; <span class=\"comment\">// unexpected error</span></span><br><span class=\"line\">\t\t\terr = e</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Make a copy of the buffer.</span></span><br><span class=\"line\">\t\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(frag))</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(buf, frag)</span><br><span class=\"line\">\t\tfull = <span class=\"built_in\">append</span>(full, buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Allocate new buffer to hold the full pieces and the fragment.</span></span><br><span class=\"line\">\tn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">len</span>(full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn += <span class=\"built_in\">len</span>(frag)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Copy full pieces and fragment in.</span></span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\tn = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">copy</span>(buf[n:], full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(buf[n:], frag)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> buf, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadString reads until the first occurrence of delim in the input,</span></span><br><span class=\"line\"><span class=\"comment\">// returning a string containing the data up to and including the delimiter.</span></span><br><span class=\"line\"><span class=\"comment\">// If ReadString encounters an error before finding a delimiter,</span></span><br><span class=\"line\"><span class=\"comment\">// it returns the data read before the error and the error itself (often io.EOF).</span></span><br><span class=\"line\"><span class=\"comment\">// ReadString returns err != nil if and only if the returned data does not end in</span></span><br><span class=\"line\"><span class=\"comment\">// delim.</span></span><br><span class=\"line\"><span class=\"comment\">// For simple uses, a Scanner may be more convenient.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadString</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tbytes, err := b.ReadBytes(delim)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(bytes), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteTo implements io.WriterTo.</span></span><br><span class=\"line\"><span class=\"comment\">// This may make multiple calls to the Read method of the underlying Reader.</span></span><br><span class=\"line\"><span class=\"comment\">// If the underlying reader supports the WriteTo method,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying WriteTo without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">WriteTo</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\tn, err = b.writeBuf(w)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r, ok := b.rd.(io.WriterTo); ok &#123;</span><br><span class=\"line\">\t\tm, err := r.WriteTo(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> w, ok := w.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\tm, err := w.ReadFrom(b.rd)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.w-b.r &lt; <span class=\"built_in\">len</span>(b.buf) &#123;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer not full</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> b.r &lt; b.w &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// b.r &lt; b.w =&gt; buffer is not empty</span></span><br><span class=\"line\">\t\tm, err := b.writeBuf(w)</span><br><span class=\"line\">\t\tn += m</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.fill() <span class=\"comment\">// buffer is empty</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err == io.EOF &#123;</span><br><span class=\"line\">\t\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, b.readErr()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errNegativeWrite = errors.New(<span class=\"string\">&quot;bufio: writer returned negative count from Write&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// writeBuf writes the Reader&#x27;s buffer to the writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">writeBuf</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(<span class=\"keyword\">int64</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tn, err := w.Write(b.buf[b.r:b.w])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(errNegativeWrite)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.r += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int64</span>(n), err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Writer implements buffering for an io.Writer object.</span></span><br><span class=\"line\"><span class=\"comment\">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class=\"line\"><span class=\"comment\">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class=\"line\"><span class=\"comment\">// After all data has been written, the client should call the</span></span><br><span class=\"line\"><span class=\"comment\">// Flush method to guarantee all data has been forwarded to</span></span><br><span class=\"line\"><span class=\"comment\">// the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\terr error</span><br><span class=\"line\">\tbuf []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\tn   <span class=\"keyword\">int</span></span><br><span class=\"line\">\twr  io.Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriterSize returns a new Writer whose buffer has at least the specified</span></span><br><span class=\"line\"><span class=\"comment\">// size. If the argument io.Writer is already a Writer with large enough</span></span><br><span class=\"line\"><span class=\"comment\">// size, it returns the underlying Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriterSize</span><span class=\"params\">(w io.Writer, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Is it already a Writer?</span></span><br><span class=\"line\">\tb, ok := w.(*Writer)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &amp;&amp; <span class=\"built_in\">len</span>(b.buf) &gt;= size &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tsize = defaultBufSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Writer&#123;</span><br><span class=\"line\">\t\tbuf: <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size),</span><br><span class=\"line\">\t\twr:  w,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewWriter returns a new Writer whose buffer has the default size.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriter</span><span class=\"params\">(w io.Writer)</span> *<span class=\"title\">Writer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewWriterSize(w, defaultBufSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Size returns the size of the underlying buffer in bytes.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Size</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reset discards any unflushed buffered data, clears any error, and</span></span><br><span class=\"line\"><span class=\"comment\">// resets b to write its output to w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Reset</span><span class=\"params\">(w io.Writer)</span></span> &#123;</span><br><span class=\"line\">\tb.err = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\tb.wr = w</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Flush writes any buffered data to the underlying io.Writer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Flush</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn, err := b.wr.Write(b.buf[<span class=\"number\">0</span>:b.n])</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; b.n &amp;&amp; err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = io.ErrShortWrite</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &amp;&amp; n &lt; b.n &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">copy</span>(b.buf[<span class=\"number\">0</span>:b.n-n], b.buf[n:b.n])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n -= n</span><br><span class=\"line\">\t\tb.err = err</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.n = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Available returns how many bytes are unused in the buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Available</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b.buf) - b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Buffered returns the number of bytes that have been written into the current buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Buffered</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> b.n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Write writes the contents of p into the buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If nn &lt; len(p), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Write</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(nn <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(p) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> n <span class=\"keyword\">int</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Large write, empty buffer.</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Write directly from p to avoid copy.</span></span><br><span class=\"line\">\t\t\tn, b.err = b.wr.Write(p)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tn = <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\t\t\tb.n += n</span><br><span class=\"line\">\t\t\tb.Flush()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\tp = p[n:]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], p)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteByte writes a single byte.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteByte</span><span class=\"params\">(c <span class=\"keyword\">byte</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Available() &lt;= <span class=\"number\">0</span> &amp;&amp; b.Flush() != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb.buf[b.n] = c</span><br><span class=\"line\">\tb.n++</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteRune writes a single Unicode code point, returning</span></span><br><span class=\"line\"><span class=\"comment\">// the number of bytes written and any error.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteRune</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"params\">(size <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &lt; utf8.RuneSelf &#123;</span><br><span class=\"line\">\t\terr = b.WriteByte(<span class=\"keyword\">byte</span>(r))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := b.Available()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Flush(); b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, b.err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tn = b.Available()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; utf8.UTFMax &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Can only happen if buffer is silly small.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> b.WriteString(<span class=\"keyword\">string</span>(r))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsize = utf8.EncodeRune(b.buf[b.n:], r)</span><br><span class=\"line\">\tb.n += size</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> size, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WriteString writes a string.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written.</span></span><br><span class=\"line\"><span class=\"comment\">// If the count is less than len(s), it also returns an error explaining</span></span><br><span class=\"line\"><span class=\"comment\">// why the write is short.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteString</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tnn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(s) &gt; b.Available() &amp;&amp; b.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\t\tb.n += n</span><br><span class=\"line\">\t\tnn += n</span><br><span class=\"line\">\t\ts = s[n:]</span><br><span class=\"line\">\t\tb.Flush()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nn, b.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">copy</span>(b.buf[b.n:], s)</span><br><span class=\"line\">\tb.n += n</span><br><span class=\"line\">\tnn += n</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nn, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadFrom implements io.ReaderFrom. If the underlying writer</span></span><br><span class=\"line\"><span class=\"comment\">// supports the ReadFrom method, and b has no buffered data yet,</span></span><br><span class=\"line\"><span class=\"comment\">// this calls the underlying ReadFrom without buffering.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">ReadFrom</span><span class=\"params\">(r io.Reader)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> b.Buffered() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> w, ok := b.wr.(io.ReaderFrom); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> w.ReadFrom(r)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err1 := b.Flush(); err1 != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> n, err1</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnr := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> nr &lt; maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\tm, err = r.Read(b.buf[b.n:])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> m != <span class=\"number\">0</span> || err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnr++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nr == maxConsecutiveEmptyReads &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n, io.ErrNoProgress</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb.n += m</span><br><span class=\"line\">\t\tn += <span class=\"keyword\">int64</span>(m)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If we filled the buffer exactly, flush preemptively.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b.Available() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\terr = b.Flush()</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// buffered input and output</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReadWriter stores pointers to a Reader and a Writer.</span></span><br><span class=\"line\"><span class=\"comment\">// It implements io.ReadWriter.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*Reader</span><br><span class=\"line\">\t*Writer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewReadWriter allocates a new ReadWriter that dispatches to r and w.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReadWriter</span><span class=\"params\">(r *Reader, w *Writer)</span> *<span class=\"title\">ReadWriter</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ReadWriter&#123;r, w&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":[{"name":"编程技术","path":"api/categories/编程技术.json"}],"tags":[{"name":"编程原理","path":"api/tags/编程原理.json"},{"name":"golang","path":"api/tags/golang.json"}]}